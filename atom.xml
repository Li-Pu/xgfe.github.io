<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2020-08-26T12:42:25.078Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CoreML简单使用</title>
    <link href="http://xgfe.github.io/2020/08/20/jinwenzhe/CoreML%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://xgfe.github.io/2020/08/20/jinwenzhe/CoreML简单使用/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-08-26T12:42:25.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Core ML 是一个机器学习框架，支持iPhone的一些功能，比如FaceID、Animoji和增强现实AR。<a id="more"></a><br>自从Core ML在2017年发布以来，它已经走过了很长的路，现在它支持大量的工具，可以帮助我们快速构建基于机器学习的应用程序。<br>Core ML通过轻松集成机器学习模型来提供惊人的快速性能，使你仅需几行代码即可构建具有智能新功能的应用程序。<br>使用由Core ML支持的API轻松地将预建的机器学习功能添加到您的应用程序中，或者使用Create ML以获得更大的灵活性，并在Mac上训练自定义的Core ML模型。<br>你还可以使用Core ML Converters转换其他培训库中的模型，或下载即可使用的Core ML模型。<br>Core ML提供了一系列的API，仅需几行代码，即可将设备上的机器学习功能（如图像和视频中的对象检测，语言分析和声音分类）带到您的应用中。</p><p><img src="https://p0.meituan.net/spacex/ceadf7f29a7865d11a79e999447d08ad.png" width="60%"></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="简单、轻量"><a href="#简单、轻量" class="headerlink" title="简单、轻量"></a>简单、轻量</h3><p>模型是将机器学习算法应用于一组训练数据的结果。您可以基于新的输入数据使用模型进行预测。<br>一些很难或者用代码编写起来很困难的任务，可以通过模型来完成。<br>例如，您可以训练模型对照片进行分类，或者直接使用现有照片来进行识别。</p><h3 id="性能、离线、安全"><a href="#性能、离线、安全" class="headerlink" title="性能、离线、安全"></a>性能、离线、安全</h3><p>Core ML通过利用CPU，GPU和神经引擎来优化设备上的性能，同时最大程度地减少其内存占用空间和功耗。<br>只在用户设备上运行模型可以消除对网络连接的任何需求，这有助于保持用户数据的私密性和您的应用程序的响应速度。</p><h2 id="CoreML官网中可供使用的一些关于计算机视觉的模型"><a href="#CoreML官网中可供使用的一些关于计算机视觉的模型" class="headerlink" title="CoreML官网中可供使用的一些关于计算机视觉的模型"></a>CoreML官网中可供使用的一些关于计算机视觉的模型</h2><p>​<img src="https://p0.meituan.net/spacex/3ddf02503149cfe5c10ef3b91d6f10db.png" alt=""></p><h1 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h1><pre><code>Build intelligence into your apps using machine learning models from the research community designed for Core ML.使用研究社区专门为Core ML设计的机器学习模型，将智能构建到您的应用中。</code></pre><h1 id="Demo展示"><a href="#Demo展示" class="headerlink" title="Demo展示"></a>Demo展示</h1><h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><p><img src="https://p0.meituan.net/spacex/12ef25396ce3fd3687801b2cf0582d77.png" width="30%"></p><h2 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h2><div style="float:left;border:solid 1px 000;margin:2px;text-align:center"><div style="display:inline-block; width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/c7a5809a62a5df0506c3a169ba7713ff.png"></div><div style="display:inline-block;width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/5d4462d3316f734ea0677686d501d633.png"></div></div><h2 id="主体识别"><a href="#主体识别" class="headerlink" title="主体识别"></a>主体识别</h2><div style="float:left;border:solid 1px 000;margin:2px;text-align:center"><div style="display:inline-block; width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/620c41f68a181febbd710e1633fc7439.png"></div><div style="display:inline-block;width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/4377a0f840316051156a449d1285dce5.png"></div></div><h2 id="物体检测"><a href="#物体检测" class="headerlink" title="物体检测"></a>物体检测</h2><div style="float:left;border:solid 1px 000;margin:2px;text-align:center"><div style="display:inline-block; width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/f0a2f9ac27c39a27ac2e3af30ae59244.png"></div><div style="display:inline-block;width:30%; margin:5px"><img src="https://p0.meituan.net/spacex/4b286f1bc4b72ed247e280fa744b1bf1.png"></div></div><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="一、下载模型"><a href="#一、下载模型" class="headerlink" title="一、下载模型"></a>一、下载模型</h2><blockquote><p>下载链接：<a href="https://developer.apple.com/machine-learning/models/" target="_blank" rel="noopener">https://developer.apple.com/machine-learning/models/</a></p></blockquote><p>不同的mlmodel区别在于参数精度不同</p><p><img src="https://p0.meituan.net/spacex/4d9c5017d03297ea071508d25195ead2.png" width="50%"></p><h2 id="二、导入工程"><a href="#二、导入工程" class="headerlink" title="二、导入工程"></a>二、导入工程</h2><p>将下载好的mlmodel文件直接拖进工程文件：</p><p><img src="https://p0.meituan.net/spacex/cf9d4fc0556922c6b2fa4795670b7490.png" width="40%"></p><h2 id="三、查看模型输入输出"><a href="#三、查看模型输入输出" class="headerlink" title="三、查看模型输入输出"></a>三、查看模型输入输出</h2><p><img src="https://p0.meituan.net/spacex/6101140a24583fe73f6471843869c561.png" alt=""></p><h2 id="四、导入头文件开始使用"><a href="#四、导入头文件开始使用" class="headerlink" title="四、导入头文件开始使用"></a>四、导入头文件开始使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SqueezeNetFP16.h"</span></span></span><br></pre></td></tr></table></figure><h1 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h1><h2 id="SqueezeNet"><a href="#SqueezeNet" class="headerlink" title="SqueezeNet"></a>SqueezeNet</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>SqueezeNet 发表于ICLR-2017，作者分别来自Berkeley和Stanford，</p><p>SqueezeNet不是模型压缩技术，而是 “design strategies for CNN architectures with few parameters”</p><p>Squeezenet比alexnet参数少50倍，同时大小仅4.8mb</p><p>下图是AlexNet 与 SqueezeNet 相关参数的对照表：<br><img src="https://p0.meituan.net/spacex/d641cb8ddc7c31ad8aad57f2694e0e2b.jpg" alt=""></p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p><img src="https://p0.meituan.net/spacex/6a7664866f8e47ce76378f532e3e2066.png" alt=""></p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载一张需要识别的图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"fruit.jpeg"</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> imgRef = [image <span class="built_in">CGImage</span>];</span><br><span class="line"><span class="comment">//model 只接受CVPixelBufferRef的图片，所以先转一下</span></span><br><span class="line"><span class="comment">// pixelBufferFromCGImage 函数的具体内容见本文附录</span></span><br><span class="line">CVPixelBufferRef img = [<span class="keyword">self</span> pixelBufferFromCGImage:imgRef];</span><br><span class="line">​</span><br><span class="line"><span class="comment">//初始化model</span></span><br><span class="line">SqueezeNetFP16 *mod = [[SqueezeNetFP16 alloc] init];</span><br><span class="line"><span class="comment">//通过model的predictionFromImage函数，入参为image，出参为SqueezeNetFP16Output</span></span><br><span class="line">SqueezeNetFP16Output *res = [mod predictionFromImage:img error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//打印出识别的名称和识别率</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"识别为:%@,概率为:%@"</span>,res.classLabel,res.classLabelProbs[res.classLabel]);</span><br></pre></td></tr></table></figure><h3 id="SqueezeNetFP16Output的classLabelProbs属性"><a href="#SqueezeNetFP16Output的classLabelProbs属性" class="headerlink" title="SqueezeNetFP16Output的classLabelProbs属性"></a>SqueezeNetFP16Output的classLabelProbs属性</h3><p>classLabelProbs属性包含了预测的所有种类对应的概率，</p><p>所以，res.classLabelProbs[res.classLabel]可以取出预测名称所对应的概率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;Afghan hound, Afghan&quot; = &quot;9.044347437864655e-14&quot;;</span><br><span class="line">&quot;African chameleon, Chamaeleo chamaeleon&quot; = &quot;1.968000415408788e-11&quot;;</span><br><span class="line">&quot;African crocodile, Nile crocodile, Crocodylus niloticus&quot; = &quot;2.88645680707883e-13&quot;;</span><br><span class="line">&quot;African elephant, Loxodonta africana&quot; = &quot;9.819910726585612e-13&quot;;</span><br><span class="line">&quot;African grey, African gray, Psittacus erithacus&quot; = &quot;8.513797999931683e-11&quot;;</span><br><span class="line">&quot;African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus&quot; = &quot;1.588692420890006e-13&quot;;</span><br><span class="line">&quot;Airedale, Airedale terrier&quot; = &quot;3.033485734740132e-13&quot;;</span><br><span class="line">&quot;American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier&quot; = &quot;4.295829802991591e-10&quot;;</span><br><span class="line">&quot;American alligator, Alligator mississipiensis&quot; = &quot;1.02866250673711e-12&quot;;</span><br><span class="line">&quot;American black bear, black bear, Ursus americanus, Euarctos americanus&quot; = &quot;9.978090402540385e-13&quot;;</span><br><span class="line">&quot;American chameleon, anole, Anolis carolinensis&quot; = &quot;2.216001861177208e-11&quot;;</span><br><span class="line">&quot;American coot, marsh hen, mud hen, water hen, Fulica americana&quot; = &quot;7.412853967811</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Resnet50"><a href="#Resnet50" class="headerlink" title="Resnet50"></a>Resnet50</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Resnet是残差网络(Residual Network)的缩写,</p><p>该系列网络广泛用于目标分类等领域以及作为计算机视觉任务主干经典神经网络的一部分，</p><p>典型的网络有resnet50, resnet101等。</p><p>Resnet网络的证明网络能够向更深（包含更多隐藏层）的方向发展。</p><h3 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h3><p><img src="https://p0.meituan.net/spacex/49fe90eeb134d8ab5837a3e4b7f755bc.png" alt=""></p><h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ResNet的输入图片大小要求为224*224，这里先将获取的image resize一下</span></span><br><span class="line"><span class="built_in">CGSize</span> size_resNet = <span class="built_in">CGSizeMake</span>(<span class="number">224</span>,<span class="number">224</span>);</span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size_resNet, <span class="literal">NO</span>, <span class="number">1.0</span>);</span><br><span class="line">[img drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">224</span>, <span class="number">224</span>) blendMode:kCGBlendModeNormal alpha:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *resultImage_resNet = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">​</span><br><span class="line"><span class="comment">// UIImage 转 CVPixelBufferRef</span></span><br><span class="line"><span class="built_in">CGImageRef</span> imgRef_resNet = [resultImage_resNet <span class="built_in">CGImage</span>];</span><br><span class="line">CVPixelBufferRef pbimg_resNet = [<span class="keyword">self</span> pixelBufferFromCGImage:imgRef_resNet];</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Resnet50Output的classLabel属性为识别的类别名称</span></span><br><span class="line"><span class="comment">// Resnet50Output的classLabelProbs属性为识别成每个类别的对应概率</span></span><br><span class="line"><span class="comment">//res_resNet.classLabelProbs[res_resNet.classLabel] 可以取出最终识别的类别的概率（即最大概率）</span></span><br><span class="line">Resnet50Output *res_resNet = [<span class="keyword">self</span>.mod_resNet predictionFromImage:pbimg_resNet error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  NSLog(@"resNet识别为:%@,概率为:%@",res_resNet.classLabel,res_resNet.classLabelProbs[res_resNet.classLabel]);</span></span><br></pre></td></tr></table></figure><p>​<br>​</p><h3 id="Resnet50Output的classLabelProbs属性"><a href="#Resnet50Output的classLabelProbs属性" class="headerlink" title="Resnet50Output的classLabelProbs属性"></a>Resnet50Output的classLabelProbs属性</h3><p>同SqueezeNet</p><h2 id="DeepLabV3"><a href="#DeepLabV3" class="headerlink" title="DeepLabV3"></a>DeepLabV3</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>DeepLab是谷歌使用tensorflow基于CNN开发的语义分割模型，至今已更新4个版本。</p><p>最新版本是DeepLabv3+，在此模型中进一步将深度可分离卷积应用到孔空间金字塔池化和解码器模块，从而形成更快，更强大的语义分割编码器-解码器网络</p><p><img src="https://p0.meituan.net/spacex/35f5a3d928e02acaef02092bce2b1e47.jpg" alt=""></p><h3 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h3><p>输入为image，输出一个与image尺寸相同的矩阵，每个矩阵数值代表了对图片前后景的分类（后景为0，前景不为0）</p><p><img src="https://p0.meituan.net/spacex/5cd0408eb81ec16f51400fbf4d27644b.png" alt=""></p><h3 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = info[<span class="string">@"UIImagePickerControllerEditedImage"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入image 规格为513*513</span></span><br><span class="line"><span class="comment">//先resize图片</span></span><br><span class="line"><span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="number">513</span>,<span class="number">513</span>);</span><br><span class="line"><span class="comment">//    UIGraphicsBeginImageContext(size);</span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">1.0</span>);</span><br><span class="line">[img drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">513</span>, <span class="number">513</span>) blendMode:kCGBlendModeNormal alpha:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="comment">//将原图展示在imageView中</span></span><br><span class="line">[<span class="keyword">self</span>.imageView setImage:resultImage];</span><br><span class="line">​</span><br><span class="line"><span class="comment">//UIImage转输入要求的图片格式CVPixelBufferRef</span></span><br><span class="line"><span class="comment">// pixelBufferFromCGImage 函数见附录</span></span><br><span class="line"><span class="built_in">CGImageRef</span> imgRef = [resultImage <span class="built_in">CGImage</span>];</span><br><span class="line">CVPixelBufferRef pbimg = [<span class="keyword">self</span> pixelBufferFromCGImage:imgRef];</span><br><span class="line">​</span><br><span class="line"><span class="comment">//得到模型输出</span></span><br><span class="line">DeepLabV3Output *res = [<span class="keyword">self</span>.mod_deeplab predictionFromImage:pbimg error:<span class="literal">nil</span>];</span><br><span class="line">​</span><br><span class="line"><span class="comment">//使用imageBlackToTransparent 函数处理输出，返回一张处理后的图片</span></span><br><span class="line"><span class="comment">// imageBlackToTransparent函数见附录</span></span><br><span class="line"><span class="built_in">UIImage</span> *myimg = [<span class="keyword">self</span> imageBlackToTransparent:resultImage withArr:res.semanticPredictions];</span><br><span class="line"><span class="comment">//将处理后的图片展示在另一个imageView中</span></span><br><span class="line">[<span class="keyword">self</span>.imageView2 setImage:myimg];</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="CoreML官方文档"><a href="#CoreML官方文档" class="headerlink" title="CoreML官方文档"></a>CoreML官方文档</h2><blockquote><p><a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">https://developer.apple.com/documentation/coreml</a></p></blockquote><h2 id="pixelBufferFromCGImage-函数"><a href="#pixelBufferFromCGImage-函数" class="headerlink" title="pixelBufferFromCGImage: 函数"></a>pixelBufferFromCGImage: 函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIImage 转 CGImageRef</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"fruit.jpeg"</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> imgRef = [image <span class="built_in">CGImage</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CGImageRef 转  CVPixelBufferRef</span></span><br><span class="line">- (CVPixelBufferRef)pixelBufferFromCGImage:(<span class="built_in">CGImageRef</span>)image&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *options = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                             [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>], kCVPixelBufferCGImageCompatibilityKey,</span><br><span class="line">                             [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>], kCVPixelBufferCGBitmapContextCompatibilityKey,</span><br><span class="line">                             <span class="literal">nil</span>];</span><br><span class="line">​</span><br><span class="line">    CVPixelBufferRef pxbuffer = <span class="literal">NULL</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">CGFloat</span> frameWidth = <span class="built_in">CGImageGetWidth</span>(image);</span><br><span class="line">    <span class="built_in">CGFloat</span> frameHeight = <span class="built_in">CGImageGetHeight</span>(image);</span><br><span class="line">​</span><br><span class="line">    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault,</span><br><span class="line">                                          frameWidth,</span><br><span class="line">                                          frameHeight,</span><br><span class="line">                                          kCVPixelFormatType_32ARGB,</span><br><span class="line">                                          (__bridge <span class="built_in">CFDictionaryRef</span>) options,</span><br><span class="line">                                          &amp;pxbuffer);</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(status == kCVReturnSuccess &amp;&amp; pxbuffer != <span class="literal">NULL</span>);</span><br><span class="line">​</span><br><span class="line">    CVPixelBufferLockBaseAddress(pxbuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">void</span> *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(pxdata != <span class="literal">NULL</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> rgbColorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(pxdata,</span><br><span class="line">                                                 frameWidth,</span><br><span class="line">                                                 frameHeight,</span><br><span class="line">                                                 <span class="number">8</span>,</span><br><span class="line">                                                 CVPixelBufferGetBytesPerRow(pxbuffer),</span><br><span class="line">                                                 rgbColorSpace,</span><br><span class="line">                                                 (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNoneSkipFirst);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(context);</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,</span><br><span class="line">                                           <span class="number">0</span>,</span><br><span class="line">                                           frameWidth,</span><br><span class="line">                                           frameHeight),</span><br><span class="line">                       image);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">​</span><br><span class="line">    CVPixelBufferUnlockBaseAddress(pxbuffer, <span class="number">0</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> pxbuffer;​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="imageBlackToTransparent-函数"><a href="#imageBlackToTransparent-函数" class="headerlink" title="imageBlackToTransparent 函数"></a>imageBlackToTransparent 函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对UIImage进行像素值修改，入参为MLMultiArray：</span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)imageBlackToTransparent:(<span class="built_in">UIImage</span>*)image withArr:(MLMultiArray*)arr&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imageWidth = image.size.width;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imageHeight = image.size.height;</span><br><span class="line">    size_t      bytesPerRow = imageWidth * <span class="number">4</span>;</span><br><span class="line">    uint32_t* rgbImageBuf = (uint32_t*)malloc(bytesPerRow * imageHeight);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(rgbImageBuf, imageWidth, imageHeight, <span class="number">8</span>, bytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight), image.CGImage);</span><br><span class="line">    <span class="comment">// 遍历像素</span></span><br><span class="line">    <span class="keyword">int</span> pixelNum = imageWidth * imageHeight;</span><br><span class="line">    uint32_t* pCurPtr = rgbImageBuf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pixelNum; i++, pCurPtr++)&#123;</span><br><span class="line">        </span><br><span class="line">        uint8_t* ptr = (uint8_t*)pCurPtr;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span>(arr[i].intValue == <span class="number">0</span>)&#123;</span><br><span class="line">            ptr[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//0~255</span></span><br><span class="line">            ptr[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            ptr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 输出图片</span></span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(imageWidth, imageHeight, <span class="number">8</span>, <span class="number">32</span>, bytesPerRow, colorSpace,</span><br><span class="line">                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,</span><br><span class="line">                                        <span class="literal">NULL</span>, <span class="literal">true</span>, kCGRenderingIntentDefault);</span><br><span class="line">    <span class="built_in">CGDataProviderRelease</span>(dataProvider);</span><br><span class="line">    <span class="built_in">UIImage</span>* resultUIImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="comment">// 清理空间</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="keyword">return</span> resultUIImage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ProviderReleaseData (<span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data, size_t size)&#123;</span><br><span class="line">    free((<span class="keyword">void</span>*)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Core ML 是一个机器学习框架，支持iPhone的一些功能，比如FaceID、Animoji和增强现实AR。
    
    </summary>
    
      <category term="jinwenzhe" scheme="http://xgfe.github.io/categories/jinwenzhe/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="CoreML" scheme="http://xgfe.github.io/tags/CoreML/"/>
    
  </entry>
  
  <entry>
    <title>Vue中VirtualDOM与diff的实现</title>
    <link href="http://xgfe.github.io/2020/07/03/zhangdezhi/VirtualDOM%E4%B8%8Ediff(Vue%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://xgfe.github.io/2020/07/03/zhangdezhi/VirtualDOM与diff(Vue实现)/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了vue中VirtualDOM的的实现和diff算法<br><a id="more"></a></p><h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><p>在刀耕火种的年代，我们需要在各个事件方法中直接操作DOM来达到修改视图的目的。但是当应用一大就会变得难以维护。<br>那我们是不是可以把真实DOM树抽象成一棵以JavaScript对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实DOM重绘到页面上呢？于是虚拟DOM出现了，它是真实DOM的一层抽象，用属性描述真实DOM的各个特性。当它发生变化的时候，就会去修改视图。<br>但是这样的JavaScript操作DOM进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以Vue.js将DOM抽象成一个以JavaScript对象为节点的虚拟DOM树，以VNode节点模拟真实DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实DOM，只需要操作JavaScript对象，大大提升了性能。修改以后经过diff算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的DOM操作，大大提高了性能。</p><h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><p>周所周知，Vue通过数据绑定来修改视图，当某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher，Watcher通过get方法执行vm._update(vm._render(), hydrating)。</p><p>这里看一下_update方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">/*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/</span></span><br><span class="line">  <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">    callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="comment">/*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(</span><br><span class="line">      vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</span><br><span class="line">      vm.$options._parentElm,</span><br><span class="line">      vm.$options._refElm</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="comment">/*更新新的实例对象的__vue__*/</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>_update方法的第一个参数是一个VNode对象，在内部会将该VNode对象与之前旧的VNode对象进行patch。</p><p>什么是patch呢？</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>patch将新老VNode节点进行比对，然后将根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据新的VNode重绘。patch的核心在于diff算法，这套算法可以高效地比较viturl dom的变更，得出变化以修改视图。</p><p>那么patch如何工作的呢？</p><p>首先说一下patch的核心diff算法，diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。<br><img src="https://km.sankuai.com/api/file/cdn/340540847/340596106?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patch diff"><br><img src="https://km.sankuai.com/api/file/cdn/340540847/340589211?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patch diff"><br>着两张图代表旧的VNode与新VNode进行patch的过程，他们只是在同层级的VNode之间进行比较得到变化（第二张图中相同颜色的方块代表互相进行比较的VNode节点），然后修改变化的视图，所以十分高效。</p><p>让我们看一下patch的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*createPatchFunction的返回值，一个patch函数*/</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">   <span class="comment">/*vnode不存在则直接调用销毁钩子*/</span></span><br><span class="line">   <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">     <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">     <span class="comment">/*oldVnode未定义的时候，其实也就是root节点，创建一个新的节点*/</span></span><br><span class="line">     isInitialPatch = <span class="literal">true</span></span><br><span class="line">     createElm(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">/*标记旧的VNode是否有nodeType*/</span></span><br><span class="line">     <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">     <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">     <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">       <span class="comment">// patch existing root node</span></span><br><span class="line">       <span class="comment">/*是同一个节点的时候直接修改现有的节点*/</span></span><br><span class="line">       patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">         <span class="comment">// mounting to a real element</span></span><br><span class="line">         <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">         <span class="comment">// a successful hydration.</span></span><br><span class="line">         <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">           <span class="comment">/*当旧的VNode是服务端渲染的元素，hydrating记为true*/</span></span><br><span class="line">           oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">           hydrating = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">           <span class="comment">/*需要合并到真实DOM上*/</span></span><br><span class="line">           <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">             <span class="comment">/*调用insert钩子*/</span></span><br><span class="line">             invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">             <span class="keyword">return</span> oldVnode</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">             warn(</span><br><span class="line">               <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">               <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">               <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">               <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">               <span class="string">'full client-side render.'</span></span><br><span class="line">             )</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">         <span class="comment">// create an empty node and replace it</span></span><br><span class="line">         <span class="comment">/*如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它*/</span></span><br><span class="line">         oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// replacing existing element</span></span><br><span class="line">       <span class="comment">/*取代现有元素*/</span></span><br><span class="line">       <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">       <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line">       createElm(</span><br><span class="line">         vnode,</span><br><span class="line">         insertedVnodeQueue,</span><br><span class="line">         <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">         <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">         <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">         oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">         nodeOps.nextSibling(oldElm)</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">         <span class="comment">// component root element replaced.</span></span><br><span class="line">         <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">         <span class="comment">/*组件根节点被替换，遍历更新父节点element*/</span></span><br><span class="line">         <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">         <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">           ancestor.elm = vnode.elm</span><br><span class="line">           ancestor = ancestor.parent</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">           <span class="comment">/*调用create回调*/</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">             cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">         <span class="comment">/*移除老节点*/</span></span><br><span class="line">         removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">         <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">         <span class="comment">/*调用destroy钩子*/</span></span><br><span class="line">         invokeDestroyHook(oldVnode)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*调用insert钩子*/</span></span><br><span class="line">   invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">   <span class="keyword">return</span> vnode.elm</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>从代码中不难发现，当oldVnode与vnode在sameVnode的时候才会进行patchVnode，也就是新旧VNode节点判定为同一节点的时候才会进行patchVnode这个过程，否则就是创建新的DOM，移除旧的DOM。</p><p>怎么样的节点算sameVnode呢？<br>我们来看一下sameVnode的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  判断两个VNode节点是否是同一个节点，需要满足以下条件</span></span><br><span class="line"><span class="comment">  key相同</span></span><br><span class="line"><span class="comment">  tag（当前节点的标签名）相同</span></span><br><span class="line"><span class="comment">  isComment（是否为注释节点）相同</span></span><br><span class="line"><span class="comment">  是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义</span></span><br><span class="line"><span class="comment">  当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    a.tag === b.tag &amp;&amp;</span><br><span class="line">    a.isComment === b.isComment &amp;&amp;</span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">    sameInputType(a, b)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some browsers do not support dynamically changing type for &lt;input&gt;</span></span><br><span class="line"><span class="comment">// so they need to be treated as different nodes</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  判断当标签是&lt;input&gt;的时候，type是否相同</span></span><br><span class="line"><span class="comment">  某些浏览器不支持动态修改&lt;input&gt;类型，所以他们被视为不同类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameInputType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.tag !== <span class="string">'input'</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type</span><br><span class="line">  <span class="keyword">const</span> typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type</span><br><span class="line">  <span class="keyword">return</span> typeA === typeB</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同。这时候这两个VNode则算sameVnode，可以直接进行patchVnode操作。</span></span><br><span class="line"><span class="string">## patchVnode</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">/*patch VNode节点*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*两个VNode节点相同则直接返回*/</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reuse element for static trees.</span></span><br><span class="line">    <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">    <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">    <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），</span></span><br><span class="line"><span class="comment">      并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），</span></span><br><span class="line"><span class="comment">      那么只需要替换elm以及componentInstance即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">        isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">        vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">      vnode.elm = oldVnode.elm</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      <span class="comment">/*i = data.hook.prepatch，如果存在的话，见"./create-component componentVNodeHooks"。*/</span></span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="comment">/*调用update回调以及update钩子*/</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果这个VNode节点没有text文本时*/</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">/*新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren*/</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">/*如果老节点没有子节点而新节点存在子节点，先清空elm的文本内容，然后为当前节点加入子节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        <span class="comment">/*当新节点没有子节点而老节点有子节点的时候，则移除所有ele的子节点*/</span></span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">/*当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以直接去除ele的文本*/</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">/*当新老节点text不一样时，直接替换这段文本*/</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用postpatch钩子*/</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>patchVnode的规则是这样的：</p><p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p><p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p><p>5.当新老节点都无子节点的时候，只是文本的替换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">/*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*/</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）</span></span><br><span class="line"><span class="comment">        比如childre是这样的 [&#123;xx: xx, key: 'key0'&#125;, &#123;xx: xx, key: 'key1'&#125;, &#123;xx: xx, key: 'key2'&#125;]  beginIdx = 0   endIdx = 2  </span></span><br><span class="line"><span class="comment">        结果生成&#123;key0: 0, key1: 1, key2: 2&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*获取同key的老节点*/</span></span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</span><br><span class="line">          <span class="comment">/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">            <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">          <span class="comment">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          <span class="comment">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/</span></span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="comment">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/</span></span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接看源码可能比较难以滤清其中的关系，我们通过图来看一下。<br><img src="https://km.sankuai.com/api/file/cdn/340540847/340577278?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="updateChildren"></p><p>首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx &lt;= oldEndIdx或者newStartIdx &lt;= newEndIdx时结束循环。</p><p>索引与VNode节点的对应关系：<br>oldStartIdx =&gt; oldStartVnode<br>oldEndIdx =&gt; oldEndVnode<br>newStartIdx =&gt; newStartVnode<br>newEndIdx =&gt; newEndVnode</p><p>在遍历中，如果存在key，并且满足sameVnode，会将该DOM节点进行复用，否则则会创建一个新的DOM节点。</p><p>首先，oldStartVnode、oldEndVnode与newStartVnode、newEndVnode两两比较一共有2*2=4种比较方法。</p><p>当新老VNode节点的start或者end满足sameVnode时，也就是sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)，直接将该VNode节点进行patchVnode即可。<br><img src="https://km.sankuai.com/api/file/cdn/340540847/340513802?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p><p>如果oldStartVnode与newEndVnode满足sameVnode，即sameVnode(oldStartVnode, newEndVnode)。</p><p>这时候说明oldStartVnode已经跑到了oldEndVnode后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面。</p><p><img src="https://km.sankuai.com/api/file/cdn/340540847/340513830?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p><p>如果oldEndVnode与newStartVnode满足sameVnode，即sameVnode(oldEndVnode, newStartVnode)。</p><p>这说明oldEndVnode跑到了oldStartVnode的前面，进行patchVnode的同时真实的DOM节点移动到了oldStartVnode的前面。</p><p><img src="https://km.sankuai.com/api/file/cdn/340540847/340610635?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"><br>如果以上情况均不符合，则通过createKeyToOldIdx会得到一个oldKeyToIdx，里面存放了一个key为旧的VNode，value为对应index序列的哈希表。从这个哈希表中可以找到是否有与newStartVnode一致key的旧的VNode节点，如果同时满足sameVnode，patchVnode的同时会将这个真实DOM（elmToMove）移动到oldStartVnode对应的真实DOM的前面。</p><p><img src="https://km.sankuai.com/api/file/cdn/340540847/340610645?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p><p>当然也有可能newStartVnode在旧的VNode节点找不到一致的key，或者是即便key相同却不是sameVnode，这个时候会调用createElm创建一个新的DOM节点。</p><p><img src="https://km.sankuai.com/api/file/cdn/340540847/340513855?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p><p>到这里循环已经结束了，那么剩下我们还需要处理多余或者不够的真实DOM节点。</p><p>1.当结束时oldStartIdx &gt; oldEndIdx，这个时候老的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老的VNode节点多，也就是比真实DOM多，需要将剩下的（也就是新增的）VNode节点插入到真实DOM节点中去，此时调用addVnodes（批量调用createElm的接口将这些节点加入到真实DOM中去）。<br><img src="https://km.sankuai.com/api/file/cdn/340540847/340513939?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p><p>2。同理，当newStartIdx &gt; newEndIdx时，新的VNode节点已经遍历完了，但是老的节点还有剩余，说明真实DOM节点多余了，需要从文档中删除，这时候调用removeVnodes将这些多余的真实DOM删除。<br><img src="https://km.sankuai.com/api/file/cdn/340540847/340578237?contentType=1&amp;isNewContent=false&amp;isNewContent=false" alt="patchVnode"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了vue中VirtualDOM的的实现和diff算法&lt;br&gt;
    
    </summary>
    
      <category term="zhangdezhi" scheme="http://xgfe.github.io/categories/zhangdezhi/"/>
    
    
      <category term="vue" scheme="http://xgfe.github.io/tags/vue/"/>
    
      <category term="VirtualDOM" scheme="http://xgfe.github.io/tags/VirtualDOM/"/>
    
      <category term="diff" scheme="http://xgfe.github.io/tags/diff/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin初探(Java视角)</title>
    <link href="http://xgfe.github.io/2020/06/17/zhangziying/KotlinGuideForA%20GreenHand/"/>
    <id>http://xgfe.github.io/2020/06/17/zhangziying/KotlinGuideForA GreenHand/</id>
    <published>2020-06-17T08:01:00.000Z</published>
    <updated>2020-06-17T08:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kotlin凭什么被称为 “better Java”？本文从Java使用者的角度入门Kotlin，看看Kotlin好处都有啥。<br><a id="more"></a></p><h2 id="Kotlin是什么"><a href="#Kotlin是什么" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h2><h3 id="Kotlin和Java的关系："><a href="#Kotlin和Java的关系：" class="headerlink" title="Kotlin和Java的关系："></a>Kotlin和Java的关系：</h3><p>Kotlin兼容Java，可以直接调用Java代码，因此一切Java的库也适用于Kotlin。Kotlin可以编译成JVM字节码也可以编译成JavaScript方便在没有 JVM 的设备上运行。Java能跑的地方Kotlin也能跑，Kotlin可以看做Java的扩展/优化。<br>在语法糖的加持下Kotlin相比Java可以写出更简洁的代码。Kotlin在无缝兼容Java的基础上还拥有一些其他特性，比如协程、空类型检查等特性。</p><h3 id="Kotlin的社会地位："><a href="#Kotlin的社会地位：" class="headerlink" title="Kotlin的社会地位："></a>Kotlin的社会地位：</h3><p>Kotlin 在2017年被Google宣布为Android官方开发语言。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Kotlin中一切都是对象。可以采用统一的方式进行声明。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Kotlin中可以使用var或val对变量进行定义，其中var定义可变变量，val定义不可变变量。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin中不需要分号了哦</span></span><br><span class="line"><span class="keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure></p><h3 id="null检测"><a href="#null检测" class="headerlink" title="null检测"></a>null检测</h3><p>Java中虽然有@Nullable @NotNull等注解,但是加上这些注解后仅仅会有IDE警告，提示处理null情况。Kotlin编译器则可以强制处理null情况，最大限度避免null问题。Kotlin在声明变量的时候，可以指定变量是否为空，调用可为空对象时，需要进行空判断。<br>在Kotlin的null检查机制中，使用!!以及?进行null检测。其中加上!!后则变量不可为空，否则会NPE(NullPointerException)，而?则可以为空。<br>在声明变量的时候，在类型后面加上相应的符号：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h: String? = <span class="string">"helloworld"</span></span><br></pre></td></tr></table></figure></p><p>在使用变量的时候对于可空的变量可以直接抛出异常或者进行相应的处理或者不作处理。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h: String? = <span class="string">"1"</span> </span><br><span class="line"><span class="comment">//!!抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1 等价于 ages2 = age==null? -1: age;</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3 id="比较与类型判断"><a href="#比较与类型判断" class="headerlink" title="比较与类型判断"></a>比较与类型判断</h3><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c:<span class="built_in">Int</span> = <span class="number">999</span></span><br><span class="line"><span class="keyword">val</span> a:<span class="built_in">Int</span>? = c</span><br><span class="line"><span class="keyword">val</span> b:<span class="built_in">Int</span>? = c</span><br><span class="line">a===b <span class="comment">//false 需要注意两点 1、使用？会进行自动装箱，是Int对象。2、若c在-127到128之间则结果为true 因为会使用IntegerCache里缓存的数据而不是装箱成新对象。</span></span><br><span class="line">a==b <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>类型判断也十分简便，使用 is 进行判断：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">is</span> <span class="built_in">Int</span>) &#123; <span class="comment">//todo &#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="循环相关"><a href="#循环相关" class="headerlink" title="循环相关"></a>循环相关</h2><h3 id="区间遍历"><a href="#区间遍历" class="headerlink" title="区间遍历"></a>区间遍历</h3><p>对于一个区间的遍历，Kotlin提供了Java相比更为简约的写法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间可以通过..进行连接，如A..B表示[A,B] 还可以通过 until 进行连接,比如 A until B 表示[A,B)</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> 区间) </span><br><span class="line"><span class="comment">//还可以通过downTo从大往小取 </span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span>)</span><br><span class="line"><span class="comment">//也可以设定步长，比如每两个数取一次</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span> step <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h3 id="更简洁的switch：when"><a href="#更简洁的switch：when" class="headerlink" title="更简洁的switch：when"></a>更简洁的switch：when</h3><p>在Kotlin中可以使用when来替代Java中的switch：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">3</span> -&gt; print(<span class="string">"1 OR 3"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"3"</span>)</span><br><span class="line">    <span class="keyword">in</span> <span class="number">4.</span><span class="number">.10</span> -&gt; print(<span class="string">"in [4,10]"</span>)<span class="comment">//可以判断区间</span></span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(<span class="string">"is Int"</span>) <span class="comment">// 还可以判断类型</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 除非覆盖所有情况，否则必须写</span></span><br><span class="line">        print(<span class="string">"err"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Kotlin对象支持多个构造函数，其中分为主构造函数和次构造函数。主构造函数的参数放在类的头，具体代码放在类内的 init{} 代码段中。次构造函数直接在类内使用constructor进行声明：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若主构造函数没有任何注解或者可见性修饰符(public、protected、private、internal)，则 constructor 可以省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="title">construcotr</span></span>(name: String) &#123;   </span><br><span class="line">        <span class="comment">//主构造函数</span></span><br><span class="line">   init &#123;</span><br><span class="line">             <span class="comment">// TODO  </span></span><br><span class="line">      &#125;    </span><br><span class="line">    <span class="comment">//次构造函数</span></span><br><span class="line">   construcotr(name: String, key: String)&#123;</span><br><span class="line">   <span class="comment">//TODO</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他内容与Java相似度较大，不再展开。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>首先，协程并不是Kotlin特有的，它已经有十几年的历史了，go Javascript python等语言都支持协程。简单的来说，协程就是轻量级的线程。协程完全由程序控制，因此协程的切换不设计用户态和内核态的转变消耗相对于线程切换更低。一个进程中可以有多个线程，而一个线程中也可以有多个协程。对于同一个线程里面的协程，它们之间的执行是串行的。因此协程序适合于io密集型的程序。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>launch</strong><br>一个最简单协程的创建用launch加上大括号括起来的代码即可，返回Job,可以用来对协程进行取消等操作：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> job = launch&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">//使用delay可以挂起协程</span></span><br><span class="line">    delay(<span class="number">1000</span>L)</span><br><span class="line">    &#125;</span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>runBlocking</strong><br>runBlocking启动的协程任务会阻断当前线程，直到该协程执行结束：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;     </span><br><span class="line">        delay(<span class="number">2000</span>L)  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以用runBlocking来包装一个函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = runBlocking&lt;T&gt; &#123; </span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>async/await</strong><br>async方法的返回值类型是Deferred, 是Job的子类, Deferred里有个await方法, 调用它可得到协程的返回值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = runBlocking&lt;T&gt; &#123; </span><br><span class="line">    <span class="keyword">var</span> deferred = async&#123; <span class="comment">//todo&#125;</span></span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    print(deferred.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其他概念-amp-参数"><a href="#其他概念-amp-参数" class="headerlink" title="其他概念&amp;参数"></a>其他概念&amp;参数</h3><p>上下文：协程运行的上下文包括Job以及调度器等<br>协程调度器：决定协程运行的线程情况，比如指定线程或者不设限<br><strong><em>GlobalScope&amp;CoroutineScope</em></strong><br>GlobalScope继承自CoroutineScope。当一个协程被其它协程在 CoroutineScope中启动的时候则会继承父协程的上下文。当使用 GlobalScope来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。<br>可以在创建协程的时候使用，比如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> job = GlobalScope.launch&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">//使用delay可以挂起协程</span></span><br><span class="line">    delay(<span class="number">1000</span>L)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以直接创建一个作用域，然后在里面创建协程：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope&#123;</span><br><span class="line">        launch&#123;</span><br><span class="line">            <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><em>调度器</em></strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器</span></span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line">launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Kotlin凭什么被称为 “better Java”？本文从Java使用者的角度入门Kotlin，看看Kotlin好处都有啥。&lt;br&gt;
    
    </summary>
    
      <category term="zhangziying03" scheme="http://xgfe.github.io/categories/zhangziying03/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://xgfe.github.io/tags/Kotlin/"/>
    
      <category term="Mobile" scheme="http://xgfe.github.io/tags/Mobile/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack-Navigation使用指南与原理剖析</title>
    <link href="http://xgfe.github.io/2020/05/27/jiangweidong02/navigation/"/>
    <id>http://xgfe.github.io/2020/05/27/jiangweidong02/navigation/</id>
    <published>2020-05-27T02:00:00.000Z</published>
    <updated>2020-08-26T12:42:25.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Navigation是Jetpack全家桶中负责处理界面导航的组件，该组件推崇使用单Activity+多Fragment的方式来进行APP的架构。类似于AndroidManifest.xml文件中对Activity的配置，该组件需配置res/navigation/navigation.xml文件以对所有的Fragment进行集中管控。<br><a id="more"></a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><p>提供一套标准的单Activity+多Fragment的解决方案。<br>可以在Android Studio中直观的查看和编辑导航图。<br>可在目标之间导航和传递数据时提供类型安全的 Gradle 插件。（SafeArgs）<br>使用DeepLink处理Schema形式的跳转。</p></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>我们先来看一下导航图的全貌，相信就凭这一张图我们就能感受到它的重要性。随着频繁的版本迭代，RD同学在找一个页面都有哪些入口的时候只能是去翻代码查引用关系，甚至特殊情况下PM同学有时还会找我们问页面路径。<br>   现在，Navigation提供的导航图可以轻松帮你找到入口，快速看清整体业务的来龙去脉。<br><img src="https://p0.meituan.net/spacex/185b1054649b4aa1b768608328c8871d.png" alt=""></p><h3 id="依赖添加"><a href="#依赖添加" class="headerlink" title="依赖添加"></a>依赖添加</h3><pre><code>build.gradle文件中加入:</code></pre><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> nav_version = <span class="string">"2.3.0-alpha01"</span></span><br><span class="line">implementation <span class="string">"androidx.navigation:navigation-fragment:$nav_version"</span></span><br><span class="line">implementation <span class="string">"androidx.navigation:navigation-ui:$nav_version"</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果要在 Android Studio 中使用 Navigation 组件，则必须使用 Android Studio 3.3 或更高版本。且必须将应用升级为androidX</strong></p><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><table><thead><tr><th>名词</th><th>含义</th></tr></thead><tbody><tr><td>Destination</td><td>想要前往的目的地,可以是Fragment、Activity、或者Graph</td></tr><tr><td>Graph</td><td>一个视图，视图中可包含多个Fragment、Activity、Graph,是模块化的利器</td></tr></tbody></table><h3 id="宿主Activity搭建"><a href="#宿主Activity搭建" class="headerlink" title="宿主Activity搭建"></a>宿主Activity搭建</h3><p>我们需要提供一个宿主Activity作为整体导航框架的依托，这个宿主activity中会提供一块区域用来容纳所有的Fragment。<br>首先看一下宿主Activity的布局文件:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment_host"</span></span></span><br><span class="line"><span class="tag">        //这里我们需要指定一个<span class="attr">NavHostFragment</span>或者是继承自它的一个<span class="attr">Fragment</span>就可以。</span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        //我们知道,一个<span class="attr">activity</span>中可以有多个同级的<span class="attr">fragment</span>，所以这里需要指定一个默认的<span class="attr">Fragment</span>用来响应系统事件，如截获<span class="attr">back</span>键的操作。</span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">"@navigation/navigation"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>再来看一下app:navGraph所引用的文件navigation.xml，后续所有的路由配置都是在这个xml文件中进行的，这个文件是整个Navigation框架的核心。<br><img width="600px" src="https://p0.meituan.net/spacex/8b84a8049eec616cd698d75f6854c2dd.png" alt=""></p><h3 id="携参跳转"><a href="#携参跳转" class="headerlink" title="携参跳转"></a>携参跳转</h3><p>下面的例子中我们尝试从LoginFragment跳转到HomeFragment,并携带一个String类型的参数。<br>首先我们来看一下navigation.xml文件中的基本配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/nav"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@+id/fragment_splash"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment_login"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.LoginFragment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>  //当前<span class="attr">Fragment</span>可以跳到哪个<span class="attr">Fragment</span>去</span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/action_home"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">"@id/fragment_home"</span></span></span><br><span class="line"><span class="tag">         /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment_home"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.HomeFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/home_fragment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">argument</span> //别的<span class="attr">Fragment</span>想要跳过来，需要传递的参数</span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"userName"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:defaultValue</span>=<span class="string">"String"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong><em>需要理解的是，同一个fragment标签下的argument和action标签是没有任何联系的。</em></strong><br>Navigation帮助开发者制定了以下规范：<br>1.规定每个Fragment所接收的参数类型和最大数量是明确的。<br>2.规定每个Fragment可跳转到哪些别的Fragment是明确的。<br>仔细想想，确实只有在规范了这两点的基础上，才可以达到生成导航图的目的。</p><p>由LoginFragment跳转到HomeFragment:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btnLogin?.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">var</span> bundle = Bundle()</span><br><span class="line">    bundle.putString(<span class="string">"userName"</span>,<span class="string">"小驴"</span>)</span><br><span class="line">    findNavController().navigate(R.id.fragment_login, bundle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以发送对象，注意对象需要实现序列化<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/fragment_home"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.HomeFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:argType</span>=<span class="string">"com.example.android.navigation.User"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bundle = Bundle()</span><br><span class="line">bundle.putParcelable(<span class="string">"user"</span>,User())</span><br><span class="line">findNavController().navigate(R.id.fragment_home, bundle)</span><br></pre></td></tr></table></figure><p>除上述的跳转方式外，我们还可以使用Navigation组件提供的SafeArgs方式进行跳转。<br>使用SafeArgs需要添加额外的依赖。<br>root级build.gradle中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="keyword">def</span> nav_version = <span class="string">"2.3.0-alpha01"</span></span><br><span class="line">        classpath <span class="string">"androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app级build.gradle中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"androidx.navigation.safeargs"</span></span><br></pre></td></tr></table></figure></p><p>如果是纯kotlin开发环境，可替换为：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"androidx.navigation.safeargs.kotlin"</span></span><br></pre></td></tr></table></figure></p><p>跳转:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btnHome?.setOnClickListener &#123;</span><br><span class="line">    SplashFragmentDirections.actionHome(<span class="string">"小驴"</span>)</span><br><span class="line">    findNavController().navigate(R.id.fragment_home)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    <span class="keyword">var</span> bundle = HomeFragmentArgs.fromBundle(arguments!!)</span><br><span class="line">    LogUtil.log(<span class="string">"userName=<span class="variable">$bundle</span>.userName"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SafeArgs的作用实际上是将xml文件中的<action>和<argments>标签进行解析,再通过dsl方式在编译期动态生成与跳转和接收参数相关的封装类。</argments></action></p><p>SafeArgs插件的工作流程：SafeArgsPlugin.kt-&gt;ArgumentsGenerationTask.kt-&gt;NavSafeArgsGenerator.kt</p><p><img src="https://p0.meituan.net/spacex/9f07dba339d062a4597e0df8a2ba265b.png" alt=""></p><p>编译后产生的文件示例：</p><p><img width="400px" src="https://p0.meituan.net/spacex/72c95085cf0dd36b67d86f00164d9a98.png" alt=""></p><!--more--><p>使用SafeArgs的好处有：</p><blockquote><p>·规范了页面跳转的方式.<br>·对类型安全做了检测.<br>·代码自动生成，提高开发效率.</p></blockquote><p>想了解代码生成过程的同学可以查看<a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/navigation/navigation-safe-args-gradle-plugin?source=post_page---------------------------%2F&amp;autodive=0%2F/" target="_blank" rel="noopener">SafeArgs插件源码</a>。</p><h2 id="跳转方式"><a href="#跳转方式" class="headerlink" title="跳转方式"></a>跳转方式</h2><p>类似于Activity中的launchMode，Navigation组件也为开发者提供了友好的跳转的方式。</p><h3 id="默认跳转方式"><a href="#默认跳转方式" class="headerlink" title="默认跳转方式"></a>默认跳转方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/fragment_login"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.LoginFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_home"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:destination</span>=<span class="string">"@id/fragment_home"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认跳转方式与activity的默认跳转方式规则一致,保持正常的入栈顺序和出栈顺序。</p><h3 id="launchSingleTop属性"><a href="#launchSingleTop属性" class="headerlink" title="launchSingleTop属性"></a>launchSingleTop属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/fragment_login"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.LoginFragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_home"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:launchSingleTop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:destination</span>=<span class="string">"@id/fragment_home"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>launchSingleTop与activity的singleTop理解是一致的，都是栈顶复用的含义。<br>这里需要注意的是，在AndroidManifest.xml中我们配置singleTop属性是在<activity>标签中，意味着默认情况下，从任何地方跳转到该Activity都是栈顶复用的模式。<br>而在navigation.xml中，launchSingleTop配置在了<action>标签下，这相当于将以下代码做成了配置:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intent= Intent();</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br></pre></td></tr></table></figure></action></activity></p><h3 id="popUpTo-amp-popUpToInclusive"><a href="#popUpTo-amp-popUpToInclusive" class="headerlink" title="popUpTo&amp;popUpToInclusive"></a>popUpTo&amp;popUpToInclusive</h3><p>popUpTo：”fragmentId”是对栈的操作管理，意思是不断的弹出栈顶的Fragment直到遇到FragemntId对应的Fragment为止。这个属性很有用，</p><p>例如有个很常见场景，登录页登录成功后进入首页、首页进入设置页、设置页中可以退出登录又回到登录页并清空堆栈中的设置页和首页。那我们就可以通过以下配置轻松进行跳转和堆栈管理：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/fragment_settings"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.android.navigation.SettingsFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layout</span>=<span class="string">"@layout/settings_fragment"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_login"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:popUpTo</span>=<span class="string">"@id/fragment_login"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:popUpToInclusive</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:destination</span>=<span class="string">"@id/fragment_login"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img width="1200px" src="https://p0.meituan.net/spacex/ba1845eefb9f95d81bbb067728c2658f.png" alt=""><br>再看下popUpToInclusive=false的情况：</p><p><img width="1200px" src="https://p0.meituan.net/spacex/f4bf76a6fbce33ce68affa280229f9ad.png" alt=""></p><p>所以popUpToInclusive=true的含义就是将popUpTo标签所指定的Fragment也一并销毁。个人感觉多数情况下我们都会将popUpToInclusive设置为true。<br><!--more--></p><blockquote><p><strong> action标签处理的不一定只有跳转，也可以单纯的对栈进行操作。</strong><br><strong>这也就意味着popUpTo不需要和destination同时使用，且Navigation内部的处理机制会先将popUpTo、popUpToInclusive两个属性执行完毕后再对destination属性进行处理。</strong></p><h2 id="XML标签概览"><a href="#XML标签概览" class="headerlink" title="XML标签概览"></a>XML标签概览</h2><p><img src="https://p0.meituan.net/spacex/4c24402dc98bc08de174e5326daf8fde.png" alt=""></p></blockquote><p>argType的可选类型：</p><table><thead><tr><th>类型</th><th>app:argType语法</th><th>是否支持默认值</th><th>是否支持null值</th></tr></thead><tbody><tr><td>布尔值</td><td>app:argType=”boolean”</td><td>是 -“true”或“false”</td><td>否</td></tr><tr><td>浮点数</td><td>app:argType=”float”</td><td>是</td><td>否</td></tr><tr><td>数组</td><td>integer[]、float[]、com.example.User[]</td><td>否</td><td>是</td></tr><tr><td>长整数</td><td>app:argType=”long”</td><td>是 - 默认值必须始终以“L”后缀结尾（例如“123L”）</td><td>否</td></tr><tr><td>整数</td><td>app:argType=”integer”</td><td>是</td><td>否</td></tr><tr><td>资源引用</td><td>app:argType=”reference”</td><td>是 - 默认值必须为“@resourceType/resourceName”格式（例如，“@style/myCustomStyle”）或“0”</td><td>否</td></tr><tr><td>字符串</td><td>app:argType=”string”</td><td>是</td><td>是</td></tr><tr><td>自定义 Parcelable</td><td>app:argType=”com.example.User”</td><td>支持默认值“@null”。不支持其他默认值。</td><td>是</td></tr><tr><td>自定义 Serializable</td><td>app:argType=”com.example.User”</td><td>支持默认值“@null”。不支持其他默认值。</td><td>是</td></tr></tbody></table><h2 id="Navigation实现原理"><a href="#Navigation实现原理" class="headerlink" title="Navigation实现原理"></a>Navigation实现原理</h2><p>Navigation是如何进行的堆栈管理、如何保存的后退栈都是我们需要关注的问题。<br>我们先来看一下重要的类与接口:</p><p><img src="https://p0.meituan.net/spacex/907dddd3d49cba4928c7d1d2e26e2dd6.png" alt=""></p><p><strong>NavHostFragment.java</strong></p><p>这是宿主类，所有的业务Fragment实际上都是在它的布局中进行的replace操作，本质上就是一个空的FragmentLayout等待被填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    FrameLayout frameLayout = <span class="keyword">new</span> FrameLayout(inflater.getContext());</span><br><span class="line">    frameLayout.setId(getId());</span><br><span class="line">    <span class="keyword">return</span> frameLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NavController.java</strong></p><p>这里存放了Fragment的堆栈，所以想要查看堆栈信息的同学可以从这里切入。同时可以发现Navigation组件已经将LifeCycle考虑了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;NavBackStackEntry&gt; mBackStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> LifecycleOwner mLifecycleOwner;</span><br></pre></td></tr></table></figure><p>Navcontroller更是负责导航操作的关键，所有的导航操作都是由这里发起，具体由其内部的Navigator 进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">navigate</span><span class="params">(@NonNull NavDestination node, @Nullable Bundle args,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras)</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line">        Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(</span><br><span class="line">                node.getNavigatorName());</span><br><span class="line">        NavDestination newDest = navigator.navigate(node, finalArgs,</span><br><span class="line">                navOptions, navigatorExtras);</span><br><span class="line">  ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Navigator是个抽象类，它的继承类有很多：</p><p><img width="800px" src="https://p0.meituan.net/spacex/35076d08689d70d51ac4717ebc5a6e85.png" alt=""><br>通过上图我们也可以发现“导航”不仅仅针对Fragment，也有针对Activity、DialogFragment、Graph的考虑。<br>再看一下FragmentNavigator是如何处理navigate()方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavDestination <span class="title">navigate</span><span class="params">(@NonNull Destination destination, @Nullable Bundle args,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">final</span> FragmentTransaction ft = mFragmentManager.beginTransaction();</span><br><span class="line">    ........</span><br><span class="line">    ft.replace(mContainerId, frag);</span><br><span class="line">    .......</span><br><span class="line">    ft.addToBackStack(generateBackStackName(mBackStack.size(), destId));</span><br><span class="line">    .......</span><br><span class="line">    ft.commit();</span><br><span class="line">    .......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的mContainerId实际上就是NavHostFragment中的空FrameLayout。所以通过阅读源码我们发现Navigation是使用replace方式进行的堆栈处理。<br>replace方式进行的堆栈管理一定要使用addToBackStack操作，这个操作不仅会将上一个Fragment保存在后退栈中，也会影响Fragment的生命周期，使得上一个Fragment只触发onDestoryView()，不会触发onDestory()。</p><p>如果有一个跳转动作跳到了Graph，那具体会是跳到哪里？可以看下NavGraphNavigator是如何处理navigate()方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NavGraphNavigator</span> <span class="keyword">extends</span> <span class="title">Navigator</span>&lt;<span class="title">NavGraph</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavDestination <span class="title">navigate</span><span class="params">(@NonNull NavGraph destination, @Nullable Bundle args,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startId = destination.getStartDestination();</span><br><span class="line">        ...</span><br><span class="line">        NavDestination startDestination = destination.findNode(startId, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (startDestination == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String dest = destination.getStartDestDisplayName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"navigation destination "</span> + dest</span><br><span class="line">                    + <span class="string">" is not a direct child of this NavGraph"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(</span><br><span class="line">                startDestination.getNavigatorName());</span><br><span class="line">        <span class="keyword">return</span> navigator.navigate(startDestination, startDestination.addInDefaultArgs(args),</span><br><span class="line">                navOptions, navigatorExtras);</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读源码，我们发现如果是一个Graph的话，则必须指定一个startDestination用于具体的跳转。那还记得我们在哪里看到过<startdestination>标签么？请看下图：<br><img width="600px" src="https://p0.meituan.net/spacex/8b84a8049eec616cd698d75f6854c2dd.png" alt=""><br>图中的startDestination写在了navigation标签下，所以其实每一个navigation标签就是一个Graph，我们完全可以依靠Graph将业务模块化。（一个navigation.xml文件中可以有多个navigation标签）</startdestination></p><h2 id="AndroidStudio导航图绘制原理"><a href="#AndroidStudio导航图绘制原理" class="headerlink" title="AndroidStudio导航图绘制原理"></a>AndroidStudio导航图绘制原理</h2><p>首先，为什么想讲这个原理？是因为多数情况下我们没有办法在短时间内将现有的项目架构迁移成Navigation形式，但我们确实对他的导航图感到欣喜，出于这一点，可以简单讲一下AS绘制导航图的原理，以便为创建我们自己的导航图提供一些思路。</p><p>我们先将<a href="https://github.com/JetBrains/android" target="_blank" rel="noopener">AndroidStudio源码</a>下载下来。<br>navigation编辑器相关的代码都存在了android/naveditor/src/com/android/tools/idea/naveditor路径下。</p><p>转化一下角色，<strong>想象自己是一名AndroidStudio工具开发者</strong>。然后继续分析naveditor目录结构：<br><img width="300px" src="https://p0.meituan.net/spacex/37e9b0501bb000780aaeb90a5dccd3e5.png" alt=""><br><strong>../actions目录</strong><br>    这里的action是用来处理与navigation编辑器中每个可点击动作的.每一个action都继承自anAction，anAction是Intellij系列ide中编写插件重要的类。<br>    例如ScrollToDestinationAction.kt：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToDestinationAction</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> surface: NavDesignSurface, <span class="keyword">private</span> <span class="keyword">val</span> component: NlComponent): AnAction(<span class="string">"Scroll into view"</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">actionPerformed</span><span class="params">(e: <span class="type">AnActionEvent</span>)</span></span> &#123;</span><br><span class="line">    surface.scrollToCenter(listOf(component))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img width="300px" src="https://p0.meituan.net/spacex/57e4efde6cdf7b0ff51029799d31cf47.png" alt=""><br> <strong>../property目录</strong><br> 所有的属性也需要显示在界面上。例如NavActionsProperty<br><img width="300px" src="https://p0.meituan.net/spacex/15a7118875bfb55db98e3705204ff5e0.png" alt=""><br> <strong>…/scene/decorator</strong><br>这里有很多decorator，每个decorator中都分配了一个scene，以FragmentDecorator为例，编辑器中显示的每个Fragment其实就是一个FragmentDecorator。每个decorator中都会生成各自特有的绘制指令，然后之后交给Draw类进行绘制工作。<br><img width="300px" src="https://p0.meituan.net/spacex/03ff110b711d6f6194d7927a6a729946.png" alt=""><br> <strong>…/scene/draw</strong><br>执行decorator产生的绘制指令，以完成真正的显示工作。<br> <strong>…/surface</strong><br> 这里是navigation编辑器的主视图，所有编辑器上能看到的内容都是以它作为容器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Navigation并不只是一个单Activity+多Fragment的解决方案，它更是一个<strong>闭环的工具链条</strong>。可惜出现的比较晚，没有多少人会真正的把老项目用它进行重构，所以更多的我们还是学习它的思想和核心要领。</p><p>在保证我们项目中<strong>跳转和传参的形式稳定</strong>的情况下：</p><p>1.我们是否可以通过脚本扫描跳转和传参的代码，输出一个xxx_navigation.xml文件？</p><p>2.或者是通过注解的方式在编译期生成xxx_navigation.xml文件？</p><p>3.有了xxx_navigation.xml文件后，是否可以模仿SafeArg编写个gradle插件自动生成代码？</p><p>4.是否还可以利用xxx_navigation.xml文件，再编写个AS插件生成导航图？</p><p>5.再或者我们可不可以直接将生成的xxx_navigation.xml的格式与Navigation组件中xml的格式保持一致？这样就能直接利用他的导航图了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Navigation是Jetpack全家桶中负责处理界面导航的组件，该组件推崇使用单Activity+多Fragment的方式来进行APP的架构。类似于AndroidManifest.xml文件中对Activity的配置，该组件需配置res/navigation/navigation.xml文件以对所有的Fragment进行集中管控。&lt;br&gt;
    
    </summary>
    
      <category term="jiangweidong02" scheme="http://xgfe.github.io/categories/jiangweidong02/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="jetpack" scheme="http://xgfe.github.io/tags/jetpack/"/>
    
      <category term="navigation" scheme="http://xgfe.github.io/tags/navigation/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存机制</title>
    <link href="http://xgfe.github.io/2020/05/18/caomengqi/HTTP_cache/"/>
    <id>http://xgfe.github.io/2020/05/18/caomengqi/HTTP_cache/</id>
    <published>2020-05-18T02:00:00.000Z</published>
    <updated>2020-08-26T12:42:25.074Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对HTTP的缓存机制进行了介绍。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>web缓存一直是前端备受关注的一个话题，主要包括数据库缓存、服务器缓存（代理服务器缓存、CDN缓存）、浏览器缓存。其中浏览器缓存是把已经访问的过的页面（如 html js css 图片等）拷贝一份副本保存在浏览器中，当下一次访问该网站，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。本文对浏览器缓存中的HTTP缓存进行了介绍。</p><h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><p>为什么使用缓存？原因是缓存能够提高 Web 项目的性能和用户体验，具体体现在以下几点：</p><ul><li>加快浏览器加载网页的速度</li><li>减少冗余的数据传输，节省网络流量和带宽</li><li>减少服务器的负担，大大提高了网站的性能</li></ul><p>当然缓存无法保存世界上每份文档的副本 ，对于到达缓存的请求存在两种情况：缓存命中和缓存未命中。</p><p>缓存命中(cache hit)：可以用已有的副本为某些到达缓存的请求提供服务。</p><p>缓存未命中(cache miss) ：到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。</p><h1 id="缓存处理步骤"><a href="#缓存处理步骤" class="headerlink" title="缓存处理步骤"></a>缓存处理步骤</h1><p>缓存处理步骤可以用一张图来表示：</p><p><img src="https://p0.meituan.net/spacex/689248b0db9ead4609e591284a38b67b.png" alt="1589872657427"></p><p>分析上图，可以了解到缓存处理主要分为6个步骤：</p><ol><li><p><strong>接收：</strong>缓存从网络中读取抵达的请求报文</p><p>缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事务进行处理。 </p></li><li><p><strong>解析：</strong>缓存对报文进行解析，提取出 URL 和各种首部</p><p>缓存将请求报文解析为片断，将首部的各个部分放入易于操作的数据结构中。这样，缓存软件就更容易处理首部字段并修改它们了 。解析程序还要负责首部各部分的标准化，将大小写或可替换数据格式之类不太重要的区别都看作等效的。而且，某些请求报文中包含有完整的绝对 URL，而其他一些请求中包含的则是相对 URL 和 Host 首部，所以解析程序通常都要将这些细节隐藏起来 。</p></li><li><p><strong>查询：</strong>缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地) </p><p>在第三步中，缓存获取了 URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。 </p><p>已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象中还包含了一些元数据(metadata)，用来记录对象在缓存中停留了多长时间，以及它被用过多少次等 。 </p></li><li><p><strong>新鲜度检测：</strong>缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新 </p><p>HTTP 通过缓存将服务器文档的副本保留一段时间。在这段时间里，都认为文档是 “新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太长，超过了文档的新鲜度限值(freshness limit)，就认为对象“过期”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。</p></li><li><p><strong>创建响应：</strong>缓存会用新的首部和已缓存的主体来构建一条响应报文</p><p>为了使缓存的响应看起来就像来自原始服务器的一样，缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。</p><p>缓存负责对这些首部进行改造，以便与客户端的要求相匹配。比如，服务器返回的可能是一条 HTTP/1.0 响应，而客户端期待的是一条 HTTP/1.1 响应，在这种情况下，缓存必须对首部进行相应的转换。缓存还会向其中插入新鲜度信息(Cache-Control、 Expires 首部等)，而且通常会包含一个 Via 首部来说明请求是由一个代理缓存提供的。 </p></li><li><p><strong>发送：</strong>缓存通过网络将响应发回给客户端 </p><p>一旦响应首部准备好了，缓存就将响应回送给客户端。和所有代理服务器一样，代理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可以避免在本地缓存和网络 I/O 缓冲区之间进行文档内容的复制。  </p></li></ol><h1 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h1><p>为了方便理解，可以假设浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，缓存数据库没有对应的缓存数据，则需要请求服务器，服务器将返回缓存规则和数据，浏览器将缓存规则和数据存储进缓存数据库。</p><p><img src="https://p0.meituan.net/spacex/f128a87935661c41f78fca0d311f87a9.png" alt="1589873289242"></p><p>注意：在浏览器地址栏输入地址后，与页面相关的所有资源都会遵循缓存策略，而是否被缓存则依赖于缓存策略的设置。</p><p>HTTP 缓存有多种规则，根据是否需要向服务器发送请求主要分为两大类，强缓存和协商缓存。</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><h3 id="强缓存流程"><a href="#强缓存流程" class="headerlink" title="强缓存流程"></a>强缓存流程</h3><p>强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据，强制缓存的流程如下。</p><p><img src="https://p0.meituan.net/spacex/bb11a5a591085b6d09accf91d7cf5daf.png" alt="1589873518965"></p><h3 id="强缓存到期时间"><a href="#强缓存到期时间" class="headerlink" title="强缓存到期时间"></a>强缓存到期时间</h3><p>通过特殊的 HTTP Cache-Control 首部(HTTP/1.0+)和 Expires 首部(HTTP/1.1 )，HTTP 让原始服务器向每个文档附加了一个“过期日期”。这些首部说明了在多长时间内可以将这些内容视为新鲜的。 </p><p><img src="https://p0.meituan.net/spacex/6611fde19d148f9031c38c776113ddcf.png" alt="1589873870042"></p><p>在 HTTP 1.0 版本中，Expires 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差。在 HTTP 1.1 版本中，因为 Cache-Control 的值 max-age=xxx 中的 xxx 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点。</p><p>为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，HTTP 1.1 版本的实现优先级高于 HTTP 1.0。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ul><li>Cache-Control：no-store</li></ul><p>禁止一切缓存。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。 </p><ul><li>Cache-Control：no-cache</li></ul><p>强制客户端直接向服务器发送请求，也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 </p><ul><li>Cache-Control：must-revalidate</li></ul><p>在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 Gateway Timeout 错误。</p><ul><li>Cache-Control：max-age</li></ul><p>首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。</p><ul><li>Cache-Control：s-maxage</li></ul><p>和max-age是一样的，不过它只针对代理服务器缓存而言。</p><ul><li>Cache-Control：private</li></ul><p>只能针对个人用户，而不能被代理服务器缓存。</p><ul><li>Cache-Control：public</li></ul><p>可以被任何对象缓存，包括发送请求的客户端，代理服务器。</p><ul><li>Cache-Control：max-stale</li></ul><p>缓存可以随意提供过期的文件。如果指定了参数 <s>，在这段时间内，文档就不能过期。这条指令放松了缓存的规则。</s></p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用express构建本地服务器进行强缓存验证，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">var</span> options = &#123; </span><br><span class="line">  etag: <span class="literal">false</span>, <span class="comment">// 禁用协商缓存</span></span><br><span class="line">  lastModified: <span class="literal">false</span>, <span class="comment">// 禁用协商缓存</span></span><br><span class="line">  setHeaders: <span class="function">(<span class="params">res, path, stat</span>) =&gt;</span> &#123;</span><br><span class="line">    res.set(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=10'</span>); <span class="comment">// 强缓存超时时间为10秒</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">app.use(express.static((__dirname + <span class="string">'/public'</span>), options));</span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure><p>第一次请求，状态码200 OK，Response Header中增加Cache-Control，过期时间为10秒：</p><p><img src="https://p0.meituan.net/spacex/aa3728e363c3187709e4f65266e814ef.png" alt="1589887718530"></p><p>十秒内第二次请求，状态码200 OK (from disk cache)，并在在Response Headers中，Date未更新：</p><p><img src="https://p0.meituan.net/spacex/a8a2611be26837e89249df0a693ac716.png" alt="1589887736499"></p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="协商缓存流程"><a href="#协商缓存流程" class="headerlink" title="协商缓存流程"></a>协商缓存流程</h3><p>协商缓存又叫对比缓存，设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，响应浏览器通知数据未更改，浏览器会去缓存中获取数据，如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中，协商缓存的流程如下。</p><p><img src="https://p0.meituan.net/spacex/200106127c37bd2eb59e04c4cd847b1f.png" alt="1589874616041"></p><p>协商缓存和强制缓存不同的是，协商缓存每次请求都需要跟服务器通信，而且命中缓存服务器返回状态码不再是200，而是304。</p><h3 id="协商缓存判断"><a href="#协商缓存判断" class="headerlink" title="协商缓存判断"></a>协商缓存判断</h3><p>强制缓存是通过过期时间来控制是否访问服务器，而协商缓存每次都要与服务器交互对比缓存标识，同样的，对于协商缓存的实现在 HTTP 1.0 版本和 HTTP 1.1 版本也有所不同。在HTTP1.0版本中，使用Last-Modified/If-Modified-Since来标识，在HTTP1.1版本中使用ETag/If-None-Match来标识。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><p>Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，如果在指定日期之后文档被修改过了，就执行请求。</p><ul><li>如果自指定日期后，文档被修改了，If-Modified-Since 条件为真，通常 GET 就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li><li>如果自指定日期后，文档没被修改过，If-Modified-Since条件为假，会向客户端返回一个304 Not Modified响应报文。</li><li>If-Modified-Since 首部可以与 Last-Modified 服务器响应首部配合工作。第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。如果不相等， 则返回带有新主体的 200 响应。</li></ul><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>服务器通过 ETag 响应头来设置缓存标识，ETag一般为资源实体的哈希值，也服务器生成的一个标记，用来标识返回值是否有变化。且Etag的优先级高于Last-Modified。</p><ul><li>浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 If-None-Match 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，If-None-Match 首部就会执行所请求的方法返回新标识和数据；相同，则返回状态码 304 通知浏览器命中缓存。</li></ul><p>注意：ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用express构建本地服务器进行协商缓存验证，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">var</span> options = &#123; </span><br><span class="line">  etag: <span class="literal">true</span>, <span class="comment">// 开启协商缓存</span></span><br><span class="line">  lastModified: <span class="literal">true</span>, <span class="comment">// 开启协商缓存</span></span><br><span class="line">  setHeaders: <span class="function">(<span class="params">res, path, stat</span>) =&gt;</span> &#123;</span><br><span class="line">    res.set(&#123;</span><br><span class="line">      <span class="string">'Cache-Control'</span>: <span class="string">'max-age=00'</span>, <span class="comment">// 浏览器不走强缓存</span></span><br><span class="line">      <span class="string">'Pragma'</span>: <span class="string">'no-cache'</span>, <span class="comment">// 浏览器不走强缓存</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">app.use(express.static((__dirname + <span class="string">'/public'</span>), options));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>第一次请求，状态码为200 OK，响应头中带有资源的hash信息和最后一次修改时间：</p><p><img src="https://p0.meituan.net/spacex/4629ed3bec0e6af2c9619354076021c5.png" alt="1589885754975"></p><p>第二次请求，服务端根据请求头中的 If-Modified-Since 和 If-None-Match 验证文件是否修改，未修改返回状态码304 Not Modified：</p><p><img src="https://p0.meituan.net/spacex/0b7f944872390c95114f5a49af558463.png" alt="1589885770173"></p><h2 id="强缓存vs协商缓存"><a href="#强缓存vs协商缓存" class="headerlink" title="强缓存vs协商缓存"></a>强缓存vs协商缓存</h2><ul><li>两者的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</li><li>两者的区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为了使缓存策略更加健壮、灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求头 If-None-Match 和 If-Modified-Since 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 304 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。</p><p>相关参考链接：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP缓存介绍</a></li><li><a href="https://juejin.im/post/5eb7f811f265da7bbc7cc5bd" target="_blank" rel="noopener">图解HTTP缓存</a></li><li><a href="https://juejin.im/post/5a1d4e546fb9a0450f21af23" target="_blank" rel="noopener">HTTP缓存机制</a></li><li><a href="https://juejin.im/post/5c136bd16fb9a049d37efc47" target="_blank" rel="noopener">前端缓存最佳实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对HTTP的缓存机制进行了介绍。&lt;br&gt;
    
    </summary>
    
      <category term="caomengqi" scheme="http://xgfe.github.io/categories/caomengqi/"/>
    
    
      <category term="缓存" scheme="http://xgfe.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>高阶函数学习总结</title>
    <link href="http://xgfe.github.io/2020/05/16/zhengchangjun/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://xgfe.github.io/2020/05/16/zhengchangjun/高阶函数学习总结/</id>
    <published>2020-05-16T03:53:00.000Z</published>
    <updated>2020-08-26T12:42:25.086Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是总结《JavaScript设计模式与开发实践》中高阶函数的一些使用方法。</p><a id="more"></a><h2 id="什么是高阶函数"><a href="#什么是高阶函数" class="headerlink" title="什么是高阶函数"></a>什么是高阶函数</h2><p>在JavaScript中，函数是一种特殊类型的对象，那么什么是高阶函数呢？在《JavaScript设计模式与开发实践》这本书中给出的定义是：<br>至少满足下列条件之一的函：<br>1、函数可以作为参数被传递。<br>2、函数可以作为返回值返回。</p><h2 id="高阶函数的应用"><a href="#高阶函数的应用" class="headerlink" title="高阶函数的应用"></a>高阶函数的应用</h2><p>事实上，我们也经常用到高阶函数，例如数组本身提供的map、sort、filter等函数。<br>1、举个🌰，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，对数组进行去重，在不使用高阶函数，通过for循环去重的方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];</span><br><span class="line">const arr2 = [];</span><br><span class="line">for (let i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">  if (arr1.indexOf( arr1[i] ) === i) &#123;</span><br><span class="line">    arr2.push( arr1[i] );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( arr2 );</span><br><span class="line">// [1, 2, 3, 5, 4]</span><br></pre></td></tr></table></figure></p><p>下面是使用高阶函数的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];</span><br><span class="line">const arr2 = arr1.filter( (element, index, self) =&gt; &#123;</span><br><span class="line">    return self.indexOf( element ) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log( arr2 );</span><br><span class="line">// [1, 2, 3, 5, 4]</span><br></pre></td></tr></table></figure></p><p>Array.prototype.filter 接受一个函数当作参数。从Array.prototype.filter 的使用可以看到，我们的目的是对数组进行过滤，这是不变的部分；而使<br>用什么规则筛选，则是可变的部分。把可变的部分封装在函数参数里，动态传入方法中，使Array.prototype.filter 方法成为了一个非常灵活的方法。</p><p>2、高阶函数实现AOP<br>AOP既面向切面编程，主要作用是把一些和业务逻辑模块无关的功能抽离出来，例如日志统计、安全控制、异常处理等，好处是可以保持业务逻辑模块的纯净和高内聚，其次是可以方便的复用通用功能。<br>比如下面代码是在方法执行前后都加入钩子，可以在方法执行前后做一些日志输出等功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn) &#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        beforefn.apply(this, arguments);</span><br><span class="line">        return __self.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.after = function(afterfn) &#123;</span><br><span class="line">    var __self = this;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var ret = __self.apply(this, arguments);</span><br><span class="line">        afterfn.apply(this, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = function() &#123;</span><br><span class="line">    console.log(&apos;func content&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = func.before(function() &#123;</span><br><span class="line">    console.log(&apos;before todo...&apos;);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">    console.log(&apos;after todo...&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line">//before todo...</span><br><span class="line">//func content</span><br><span class="line">//after todo...</span><br></pre></td></tr></table></figure></p><p>3、柯里化<br>currying又称部分求值，一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数不会立即求值，而是返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，等函数被真正需要求值的时候，之前传入的所有参数都会被一次用于求值。<br>举例：实现 add(1)(2, 3)(4)() = 10 的效果<br>解析：从代码调用来看，当有参数传入时add方法会返回一个方法，当没有参数传入和会返回之前所有参数的和，非常符合柯里化的描述，代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn)&#123;</span><br><span class="line">    var allArgs = [];</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        var args = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">        if(args.length &gt; 0)&#123;</span><br><span class="line">            allArgs = allArgs.concat(args);</span><br><span class="line">            return next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(null, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var add = currying(function()&#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        sum += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>4、反柯里化<br>反柯里化通俗的理解就是把别人的东西拿来给自己用。<br>可以看下下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line"> name: &apos;sven&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line"> name: &apos;six&apos;,</span><br><span class="line"> getName: function()&#123;</span><br><span class="line">   return this.name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log( obj2.getName.call( obj1 ) );</span><br></pre></td></tr></table></figure></p><p>在这段代码中obj1本身没有getName方法，但是通过call的方式调用了obj2上的方法getName，从而实现获取name的值。</p><p>5、函数节流<br>函数节流是平时用到的比较多场景，例如我们有一个下拉用户组件。该组件可以在用户输入的时候在输入框下方列出相关用户；<br>我们在用户输入的每一个字都会触发查询方法，这样频率太高了，会消耗服务端性能，而且在网络比较差的情况下用户体验也比较不好。这种情况下我们一般就会选择使用函数节流方法提升用户体验，降低性能影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let content = document.getElementById(&apos;content&apos;);</span><br><span class="line">let num = 1;</span><br><span class="line">function count() &#123;</span><br><span class="line">    content.innerHTML = num++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let now = Date.now();</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content.onmousemove = throttle(count,1000);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了以上应用，高阶函数还有很多应用场景，例如分时函数、惰性加载函数等等。<br>而且可以看到很多高阶函数的应用都用到了闭包，所以要学好高阶函数就要先把闭包的概念理解好。<br>高阶是一种设计模式，在react中也有类似的应用场景例如高阶组件。而且高阶函数在日常开发中会经常使用到，它可以把复杂的业务逻辑解耦，增强代码的可读性和可维护性，所以我们也有必要学会它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是总结《JavaScript设计模式与开发实践》中高阶函数的一些使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="zhengchangjun" scheme="http://xgfe.github.io/categories/zhengchangjun/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="高阶函数" scheme="http://xgfe.github.io/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreference导致的ANR优化实践</title>
    <link href="http://xgfe.github.io/2020/02/09/shenyanghong/anr-and-gradle-plugin/"/>
    <id>http://xgfe.github.io/2020/02/09/shenyanghong/anr-and-gradle-plugin/</id>
    <published>2020-02-09T07:07:40.000Z</published>
    <updated>2020-08-26T12:42:25.083Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了ANR相关原理，以及如何通过插件方式解决SharedPreference导致的ANR。</p><a id="more"></a><h2 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h2><p>ANR是“Application Not Responding”的简称，当Android应用程序的UI线程被阻止时间太长时，将触发应用程序无响应（ANR）的错误，如下图。如果应用程序位于前台，则系统会向用户显示一个对话框，使得用户可以强制退出该应用。开发者模式下可以设置后台程序也展示ANR对话框。<br><img src="/uploads/shenyanghong/anr/pic1.png" alt="" width="200"></p><h3 id="通常哪些情况会触发ANR"><a href="#通常哪些情况会触发ANR" class="headerlink" title="通常哪些情况会触发ANR"></a>通常哪些情况会触发ANR</h3><p>1.在主线程做耗时的IO操作<br>2.在主线程中做耗时计算<br>3.主线程中做跨进程操作<br>4.主线程中使用同步锁，或者sleep等，导致线程长时间等待</p><h3 id="线下如何检测和排查ANR"><a href="#线下如何检测和排查ANR" class="headerlink" title="线下如何检测和排查ANR"></a>线下如何检测和排查ANR</h3><p>1.在开发者模式下，开启“显示所有应用程序无响应”选项，后台应用程序也会显示ANR对话框<br>2.开启StrictMode( 严苛模式)，帮助检测主线程中的磁盘操作和网络请求<br>3.从设备中提取/data/anr/anr_* 文件分析，需要root权限，无权限时可以执行adb bugreport &gt; trace.txt 命令，将ANR信息导入trace.txt文件</p><h2 id="线上ANR如何监控"><a href="#线上ANR如何监控" class="headerlink" title="线上ANR如何监控"></a>线上ANR如何监控</h2><p>要想监控ANR，首先需要了解系统是何时抛出ANR对话框的。然后可以模拟系统做相同的监控，或者在系统监控到ANR的，通过手段获取到该通知。</p><h3 id="系统定义的ANR场景有哪些"><a href="#系统定义的ANR场景有哪些" class="headerlink" title="系统定义的ANR场景有哪些"></a>系统定义的ANR场景有哪些</h3><p>ANR都会走到AMS的mAppErrors.appNotResponding方法，通过查看该方法调用，主要有以下场景：<br>1.前台服务在20s内未执行完成 或者 android 8.0调用startForegroundService() 后，5秒内没有调用startForeground()也会触发ANR<br>2.前台广播在10s内未执行完成，默认的后台广播超时时间是60s<br>3.ContentProviderClient 也可能会调用ams.appNotRespondingViaProvider。ContentProviderClient中所有操作都会先调用beforeRemote()，最后调用afterRemote()，在beforeRemote时就会开始ANR计时。ContentProviderClient主要是用来缓存ContentResolver的，使用较少，一般都是使用getContentResolver()。<br>4.输入事件分发超时5s，包括按键和触摸事件，当native层监控到超时后，会调用InputManagerService.notifyANR，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Native callback.</span><br><span class="line">private long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">        InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">    return mWindowManagerCallbacks.notifyANR(</span><br><span class="line">            inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mWindowManagerCallbacks的实现是InputMonitor，InputMonitor的notifyANR，最终会调用AMS的inputDispatchingTimeOut方法，notifyANR中关键代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // Notify the activity manager about the timeout and let it decide whether</span><br><span class="line">    // to abort dispatching or keep waiting.</span><br><span class="line">    long timeout = ActivityManager.getService().inputDispatchingTimedOut(</span><br><span class="line">            windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">    if (timeout &gt;= 0) &#123;</span><br><span class="line">        // The activity manager declined to abort dispatching.</span><br><span class="line">        // Wait a bit longer and timeout again later.</span><br><span class="line">        return timeout * 1000000L; // nanoseconds</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (RemoteException ex) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AMS.inputDispatchingTimeOut方法，最终会调用AppErrors.appNotResponding方法，该方法主要做了以下几件事：<br>1.前台应用ANR时存储各个线程调用栈信息到/data/anr/目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// For background ANRs, don&apos;t pass the ProcessCpuTracker to</span><br><span class="line">// avoid spending 1/2 second collecting stats to rank lastPids.</span><br><span class="line">File tracesFile = mService.dumpStackTraces(true, firstPids,</span><br><span class="line">                                           (isSilentANR) ? null : processCpuTracker,</span><br><span class="line">                                           (isSilentANR) ? null : lastPids,</span><br><span class="line">                                           nativePids);</span><br></pre></td></tr></table></figure></p><p>2.存储未响应状态到进程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void makeAppNotRespondingLocked(ProcessRecord app,</span><br><span class="line">            String activity, String shortMsg, String longMsg) &#123;</span><br><span class="line">    app.notResponding = true;</span><br><span class="line">    app.notRespondingReport = generateProcessError(app,</span><br><span class="line">            ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING,</span><br><span class="line">            activity, shortMsg, longMsg, null);</span><br><span class="line">    startAppProblemLocked(app);</span><br><span class="line">    app.stopFreezingAllLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.显示ANR对话框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Bring up the infamous App Not Responding dialog</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">msg.obj = map;</span><br><span class="line">msg.arg1 = aboveSystem ? 1 : 0;</span><br><span class="line">map.put(&quot;app&quot;, app);</span><br><span class="line">if (activity != null) &#123;</span><br><span class="line">    map.put(&quot;activity&quot;, activity);</span><br><span class="line">&#125;</span><br><span class="line">mService.mUiHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure></p><p>4.发送ANR广播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;android.intent.action.ANR&quot;);</span><br><span class="line">if (!mService.mProcessesReady) &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">            | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">&#125;</span><br><span class="line">mService.broadcastIntentLocked(null, null, intent,</span><br><span class="line">        null, null, 0, null, null, null, AppOpsManager.OP_NONE,</span><br><span class="line">        null, false, false, MY_PID, Process.SYSTEM_UID, 0);</span><br></pre></td></tr></table></figure></p><p>通过上述分析，ANR发生在发送，启动服务，按键或者触摸事件时；而Activity生命周期耗时，并不会导致ANR，但是如果此时有service启动，用户操作等，则可能会出现ANR</p><h3 id="线上监控方案"><a href="#线上监控方案" class="headerlink" title="线上监控方案"></a>线上监控方案</h3><h4 id="判断ANR时机"><a href="#判断ANR时机" class="headerlink" title="判断ANR时机"></a>判断ANR时机</h4><p>通过上述分析，判断ANR时机，较好的办法是通过FileObserver监听/data/anr/目录或者 “android.intent.action.ANR”广播。<br>而由于没有root权限，/data/anr/目录或文件的监听会无效，ANR广播在部分手机上不ok，因此大部分线上监控方案还会结合5秒轮询的方式。轮询时判断AMS.getProcessesInErrorState()中是否有ANR异常信息。或者监听主线程Looper.loop时，每条Message的执行时间。而ANR问题基本上同一个APP不同用户的现象相差不大，因此会设置一个采样率，不用所有人都监控采样。</p><h4 id="输出anr堆栈信息"><a href="#输出anr堆栈信息" class="headerlink" title="输出anr堆栈信息"></a>输出anr堆栈信息</h4><p>堆栈信息可以通过提取/data/anr/目录中文件或者调用AMS.getProcessesInErrorState()，该方法返回进程所有错误信息，在发生ANR之后过滤出包含ANR的ProcessErrorStateInfo即可。</p><h2 id="SharedPreference导致的ANR"><a href="#SharedPreference导致的ANR" class="headerlink" title="SharedPreference导致的ANR"></a>SharedPreference导致的ANR</h2><p>我们遇到过一个占比较高的ANR和SharedPreference有关，堆栈信息如下：<br><img src="/uploads/shenyanghong/anr/pic2.png" alt="" width="600"></p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="调用QueueWork-waitToFinish时机有哪些？"><a href="#调用QueueWork-waitToFinish时机有哪些？" class="headerlink" title="调用QueueWork.waitToFinish时机有哪些？"></a>调用QueueWork.waitToFinish时机有哪些？</h4><p>我们查看到调用路径为QueueWork.waitToFinish， 那么哪些情况下会调用该方法，查看ActivityThread源码发现有以下情况：<br>1.Service onStartCommand被调用时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data.args != null) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            int res;</span><br><span class="line">            if (!data.taskRemoved) &#123;</span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Service onStop时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopService(IBinder token) &#123;</span><br><span class="line">    Service s = mServices.remove(token);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Destroying service &quot; + s);</span><br><span class="line">            s.onDestroy();</span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            Context context = s.getBaseContext();</span><br><span class="line">            if (context instanceof ContextImpl) &#123;</span><br><span class="line">                final String who = s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, &quot;Service&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.i(TAG, &quot;handleStopService: token=&quot; + token + &quot; not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.Activity不可见时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">    StopInfo info = new StopInfo();</span><br><span class="line">    performStopActivityInner(r, info, show, true, &quot;handleStopActivity&quot;);</span><br><span class="line">    updateVisibility(r, show);</span><br><span class="line">    // Make sure any pending writes are now committed.</span><br><span class="line">    if (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？"><a href="#为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？" class="headerlink" title="为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？"></a>为什么线程会阻塞在SharedPreferencesImpl中，它和QueuedWork有什么关系？</h4><p>SharedPreferencesImpl 是 SharedPreference的实现类，其中apply() 和 commit() 都调用了QueuedWork，apply()方法中写文件是调用QueuedWork中的Handler来延时执行的。<br>commit()方法是立即执行 或者调用QueuedWork中的Handler 批量立即执行的。其中加入QueuedWork.sFinishers列表的只有apply()<br>apply方法代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();//立即修改内存</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await(); //等待该apply数据写完文件</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);//加入QueuedWork的Finisher队列，检查时机见下文</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123; //写入文件完毕的回调，从QueuedWork移除等待</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);//加入QueuedWork队列，并延时执行</span><br><span class="line"></span><br><span class="line">    notifyListeners(mcr);//回调通过registerOnSharedPreferenceChangeListener注册的listener，⚠️回调时不等文件写完成。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>commit方法代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean commit() &#123;</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();//写入内存</span><br><span class="line"></span><br><span class="line">    //如果所有的apply commit 文件都写入完成，则在当前线程执行写入，否则丢到QueuedWork队列，且立即在子线程中执行队列中的runnable</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();//等待本次写完</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apply中关键的异步写方法enqueueDiskWrite代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                              final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line"></span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    //写入完成，减少计数器</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // commit操作</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            //mDiskWritesInFlight==1表示只有本次写入未完成</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            //如果所有的apply commit 文件都写入完成，则在当前线程执行写入</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //丢到QueuedWork队列，由子线程执行writeToDiskRunnable，commit操作会理解执行，apply会延时100ms执行</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正写数据到文件的方法writeToFile代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    boolean fileExists = mFile.exists();</span><br><span class="line">    // Rename the current file so it may be used as a backup during the next read</span><br><span class="line">    // 如果文件存在，则先备份，写入时会写到mFile中</span><br><span class="line">    if (fileExists) &#123;</span><br><span class="line">        boolean needsWrite = false;</span><br><span class="line">        // 当磁盘缓存的版本低于需要写入的版本时，才写入</span><br><span class="line">        if (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line">            if (isFromSyncCommit) &#123;</span><br><span class="line">                needsWrite = true;// 当commit时，由于外面在等待写入结果，因此每次都写入</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    // 当内存的版本等于要写入的版本时，才写入，也就是多个apply操作，只写入最后一个apply时的内存</span><br><span class="line">                    if (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">                        needsWrite = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!needsWrite) &#123;</span><br><span class="line">            //如果不需要写入时，实际是否写入文件为false，是否操作成功为true</span><br><span class="line">            mcr.setDiskWriteResult(false, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean backupFileExists = mBackupFile.exists();</span><br><span class="line">        if (!backupFileExists) &#123;</span><br><span class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                //备份失败则算没有写入，且写入失败</span><br><span class="line">                mcr.setDiskWriteResult(false, false);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mFile.delete();//backup文件存在，则丢弃mFile，因为backupFile永远是完整的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //真正开始写入mFile，出现任何异常，删除写入异常的mFile</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(false, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line">        ...略</span><br><span class="line"></span><br><span class="line">        // 写入成功，mBackupFile就无用了，删除</span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">        mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line">        //更新写入成功回调</span><br><span class="line">        mcr.setDiskWriteResult(true, true);</span><br><span class="line"></span><br><span class="line">        long fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">        mSyncTimes.add(Long.valueOf(fsyncDuration).intValue());</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 出现异常，删除写入异常的mFile</span><br><span class="line">    if (mFile.exists()) &#123;</span><br><span class="line">        mFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    mcr.setDiskWriteResult(false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ANR原因"><a href="#ANR原因" class="headerlink" title="ANR原因"></a>ANR原因</h3><p>通过上面汇总的waitToFinish调用时机，我们了解到，它都是在主线程执行的。而apply方法执行时，往sFinishes添加了一个等待写入完成的Runnable，因此在触发waitToFinish时，由于主线程等待子线程写入执行完成，从而可能造成ANR，因此主要原因在于QueuedWork.addFinisher代码。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>初步解决思路是，apply时，不将等待写入完成runnable加入sFinishes 队列。设计原因在代码中未说明，可能是为了防止丢失数据，让写入线程有更多时机写入。经过分析和讨论这个不是必须的，因为该方案无法保证进程被杀时的数据丢失问题，修改前后，通过杀进程测试，发现被杀前apply的数据都无法保留下来。而通过和其他端解决方案对比，发现也有将sFinishers 队列清空的方案，这种方案改动更大且未暴露出其他问题，因此我们决定采用apply()时，不将等待写入完成的runnable加入sFinishes 队列。经过多个版本灰度，未见异常，最终全量后没有SharedPreference相关的ANR。</p><h3 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h3><p>重写了SharedPreferencesImpl的包装类，该包装类中改变了Editor的apply方法的实现。<br>apply()重新实现时，将不包含QueuedWork.addFinisher(awaitCommit)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    if (!SafeSp.sEnable) &#123;</span><br><span class="line">        //如果未开启优化，则调用原apply方法</span><br><span class="line">        this.mEditor.apply();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过反射，调用commitToMemory</span><br><span class="line">            final Object mcr = this.commitToMemoryWrapper();</span><br><span class="line">            Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //通过反射，调用真正写文件方法writtenToDiskLatch</span><br><span class="line">                        SafeApplyEditor.this.startDiskLatchAwait(mcr);</span><br><span class="line">                    &#125; catch (Exception var2) &#123;</span><br><span class="line">                        SafeSp.setEnable(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            //通过反射，调用enqueueDiskWrite</span><br><span class="line">            this.enqueueDiskWriteWrapper(mcr, postWriteRunnable);</span><br><span class="line">            //通过反射，调用notifyListeners</span><br><span class="line">            this.notifyListenersWrapper(mcr);</span><br><span class="line">        &#125; catch (Exception var3) &#123;</span><br><span class="line">            //API有变更时，关闭优化</span><br><span class="line">            this.mEditor.apply();</span><br><span class="line">            SafeSp.setEnable(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用时通过SafeSp.getSP(sharedPreferences) 可以返回一个修复了ANR的sharedPreferences，由于SDK中可能也使用了sharedPreferences，因此可以通过gradle插件修改字节码的方式，将app中所有使用SharedPreference的地方都进行替换，替换后是否开启优化可以由上层控制。</p><h2 id="插件化方案"><a href="#插件化方案" class="headerlink" title="插件化方案"></a>插件化方案</h2><h3 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h3><p>插件方案为通过自定义Transform，实现在编译成class后，打包成dex前扫描所有class，找到所有Context.getSharedPreferences(“name”,mode) 和 PreferenceManager.getDefaultSharedPreferences(context) 代码，替换为SafeSp.getSP(原代码).</p><p>为了减少class扫描，因此增加一个外部配置，可以用正则表达式，配置不需要检查的class，默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SPManagerPlugin &#123;</span><br><span class="line">    skipClass = [&apos;R\\..*&apos;, &apos;R\\$.*&apos;, &apos;.*BuildConfig.*&apos;,&apos;.*SafeSharedPreferenceUtil.*&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建Plugin工程"><a href="#新建Plugin工程" class="headerlink" title="新建Plugin工程"></a>新建Plugin工程</h3><p>自定义Plugin可以在build.gradle文件中直接定义，为了方便复用，我们这里新建一个独立的Plugin工程来实现，由于AndroidStudio下没有提供直接创建Plugin工程的快捷方式，但可以用AndroidStudio新建一个Java-Library，将build.gradle文件中apply plugin: ‘java’ 改成 apply plugin: ‘groovy’，且在dependencies中添加依赖：compile gradleApi() 和 compile ‘com.android.tools.build:gradle:2.3.3’ ，这样才可以导入gradle.api 以及gradle相关的类。同时为了兼容java7，需要制定jdk编译版本：</p><p>sourceCompatibility = “7”<br>targetCompatibility = “7”</p><p>将src/main下的java目录改名为groovy，在groovy同级目录下新建resources/META-INF/gradle-plugins目录，并在该目录下新建一个文件按以下规则命名：插件名称.properties，插件名称将决定了如何使用该Plugin，用法如apply plugin: ‘插件名称’，文件内容为implementation-class=Plugin接口的实现类完整名称。如：implementation-class=com.sjst.xgfe.android.plugin.SPManagerPlugin</p><p>最后的目录结构如下:<br>├── build.gradle<br>├── gradle.properties<br>└── src<br>    └── main<br>        ├── groovy<br>        └── resources<br>            └── META-INF<br>                └── gradle-plugins<br>                    └── SPManagerPlugin.properties</p><h3 id="实现Plugin"><a href="#实现Plugin" class="headerlink" title="实现Plugin"></a>实现Plugin</h3><p>在groovy目录下新建plugin入口类：SPManagerPlugin.java ，也可以使用.groovy后缀，使用groovy语言开发。SPManagerPlugin需要实现Plugin接口的apply方法，该方法在apply插件的时候会被调用。在该方法中我们可以操作Project。通过Project，可以对已有的Task进行修改或者新增Task，同时也可以注册Transform来实现我们所需要的扫描class 以及新增class功能，注册Transform其本质也是添加一个TransformTask，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SPManagerPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void apply(Project project) &#123;</span><br><span class="line">        if (project == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.sLogger = project.getLogger();//初始化log</span><br><span class="line">        PluginConfig pluginConfig = project.getExtensions().create(&quot;SPManagerPlugin&quot;, PluginConfig.class);//加载插件配置</span><br><span class="line"></span><br><span class="line">        AppExtension appExtension = project.getExtensions().findByType(AppExtension.class);</span><br><span class="line">        //注册Transform来处理字节，TransformProcessor为具体替换处理类</span><br><span class="line">        appExtension.registerTransform(new ReplaceSPTransform(pluginConfig, new TransformProcessor(project,</span><br><span class="line">                pluginConfig)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReplaceSPTransform继承自Transform，它是Android官方提供的在项目构建class到生成dex期间修改class或资源的一套API。主要有以下方法需要实现:<br>1.getInputTypes:该方法用于指定需要处理的源，这里不需要处理资源，则只需要返回CONTENT_CLASS，如果需要处理资源和class，则返回CONTENT_JARS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">    //这里只需要处理class</span><br><span class="line">    return TransformManager.CONTENT_CLASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.getScopes:用于指明Transform的作用域，需要返回各种Scope集合，这里需要支持所有工程，因此返回SCOPE_FULL_PROJECT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">    //所有module都检查</span><br><span class="line">    return TransformManager.SCOPE_FULL_PROJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.isIncremental:是否支持增量编译，如果支持增量编译，则需要判断输入源的状态，根据状态处理。如jarInput 通过jarInput.getStatus()判断，directoryInput通过directoryInput.getChangedFiles()判断，来分别处理。当前该插件是不支持增量编译。</p><p>Transform执行的入口方法是transform(TransformInvocation invocation)，其中invocation参数包含了输入、输出相关信息，在该方法中我们需要将输入源拷贝到输出目录，输入源中就包含了class文件或jar包，因此可以扫描所有类。同时如果需要修改或新增class，可以在拷贝的过程中处理。invocation输入源分为 JarInput 和 DirectoryInput，JarInput包含的是jar文件地址，DirectoryInput包含的是类或资源文件位置，因此需要分别处理，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void transform(TransformInvocation invocation) throws TransformException, InterruptedException,</span><br><span class="line">        IOException &#123;</span><br><span class="line">    Collection&lt;TransformInput&gt; inputs = invocation.getInputs();</span><br><span class="line">    TransformOutputProvider outputProvider = invocation.getOutputProvider();</span><br><span class="line"></span><br><span class="line">    for (TransformInput input : inputs) &#123;</span><br><span class="line">        //处理jar文件，处理完后，需要将jar文件写入targetFile</span><br><span class="line">        for (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line"></span><br><span class="line">            File targetFile = outputProvider.getContentLocation(</span><br><span class="line">                    jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(),</span><br><span class="line">                    Format.JAR);</span><br><span class="line">            processor.processJarFile(jarInput.getFile(), targetFile);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理目录，处理完每个文件后，需要将文件拷贝到targetDir目录</span><br><span class="line">        for (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">            File targetDir = outputProvider.getContentLocation(</span><br><span class="line">                    directoryInput.getName(), directoryInput.getContentTypes(),</span><br><span class="line">                    directoryInput.getScopes(), Format.DIRECTORY);</span><br><span class="line">            processor.processDir(directoryInput.getFile(), targetDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扫描Class"><a href="#扫描Class" class="headerlink" title="扫描Class"></a>扫描Class</h3><p>JarInput数据源处理方式实际上是解压jar文件，并解析jar中的class，DirectoryInput数据源处理实际是直接解析dir中class文件，或者jar文件，总之最终都会走到解析class文件流。</p><h3 id="替换Class中内容"><a href="#替换Class中内容" class="headerlink" title="替换Class中内容"></a>替换Class中内容</h3><p>替换class中内容原理为通过asm API解析字节码，然后再通过visitor去遍历变量，方法或者注解，在遍历的时候可以修改内容，最后再取出修改后的字节码。<br>解析类内容的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private byte[] processClassStream(InputStream inputStream) throws Exception &#123;</span><br><span class="line">    ClassReader classReader = new ClassReader(inputStream);</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    MyClassVisitor cv = new MyClassVisitor(cw);</span><br><span class="line">    classReader.accept(cv, EXPAND_FRAMES);</span><br><span class="line"></span><br><span class="line">    return cw.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历方法并替换内容的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassVisitor extends ClassVisitor &#123;</span><br><span class="line">    public MyClassVisitor(ClassVisitor cv) &#123;</span><br><span class="line">        super(Opcodes.ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">        super.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        //遍历方法时，还需要进一步遍历方法中的内容</span><br><span class="line">        return new MyMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    public class MyMethodVisitor extends MethodVisitor &#123;</span><br><span class="line">        public MyMethodVisitor(MethodVisitor mv) &#123;</span><br><span class="line">            super(Opcodes.ASM5, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">            if (!needReplace(opcode, owner, name, desc, itf)) &#123;</span><br><span class="line">                super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //替换实现</span><br><span class="line">        private boolean needReplace(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">            boolean result = false;</span><br><span class="line">            boolean isGetSharedPreferences =</span><br><span class="line">                    &quot;android/content/Context&quot;.equals(owner) &amp;&amp; &quot;getSharedPreferences&quot;.equals(name);</span><br><span class="line">            boolean isGetDefaultSharedPreferences = &quot;android/preference/PreferenceManager&quot;.equals(owner) &amp;&amp;</span><br><span class="line">            &quot;getDefaultSharedPreferences&quot;.equals(name);</span><br><span class="line">            if (isGetSharedPreferences || isGetDefaultSharedPreferences) &#123;</span><br><span class="line">                super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">                //如何替换，可以通过前后代码的asm字节码进行比较</span><br><span class="line">                super.visitMethodInsn(INVOKESTATIC, &quot;com/sjst/xgfe/android/safesp/SafeSp&quot;,</span><br><span class="line">                        &quot;getSP&quot;, &quot;(Landroid&quot; +</span><br><span class="line">                                &quot;/content/SharedPreferences;)Landroid/content/SharedPreferences;&quot;, false);</span><br><span class="line"></span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于ASM api比较复杂也容易出错，这里我们借助AndroidStudio  asm-bytecode-outline 插件，可以直接查看这个java文件的class类需要用什么asm api来生成。然后通过前后asm字节码文件进行比较即可。</p><h3 id="本地发布aar"><a href="#本地发布aar" class="headerlink" title="本地发布aar"></a>本地发布aar</h3><p>远程发布无法快速测试，因此开发期间可以先采用本地发布aar。主要实现为在plugin工程的build.gradle中添加maven配置，然后在命令行调用  ./gradlew install，就会生成aar到本地mavenLocal目录：~/.m2/repository。maven配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">//arr打包配置</span><br><span class="line">group = &apos;com.sjst.xgfe.android.plugin&apos;</span><br><span class="line">version = &apos;1.0.3&apos;</span><br><span class="line">project.archivesBaseName = &apos;SPManagerPlugin&apos;</span><br></pre></td></tr></table></figure></p><p>因此调试的时候，在测试工程的repositories 中加入mavenLocal() 即可加载到本地插件aar。</p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>Android运行时代码调试只需要打上断点，选择调试进程即可。而编译期的代码调试则需要做如下处理：<br>1.添加远程debug运行模式，操作步骤如图1，图2，添加后如图3，名称可以自选，选需要调试的工程<br><img src="/uploads/shenyanghong/anr/debug1.png" alt="" width="200"> <img src="/uploads/shenyanghong/anr/debug2.png" alt="" width="400"><br>2.执行编译命令，在正常的编译命令后加–no-daemon -Dorg.gradle.debug=true 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean assembleDebug -p plugintest --no-daemon -Dorg.gradle.debug=true</span><br></pre></td></tr></table></figure><p>3.打上断点，选中刚创建的远程调试模式，也可以在执行命令前选中，点击Debug即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先介绍了ANR相关概念，以及ANR是如何由系统底层产生的。了解底层原理后，我们又分析了如何在线上监控ANR。同时通过剖析SharedPreference实现原理，找到了产生ANR的原因，以及解决办法。为了彻底解决App中此类问题，我们用到了Gradle插件。最后，本文介绍了Gradle插件的开发、调试以及发布技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了ANR相关原理，以及如何通过插件方式解决SharedPreference导致的ANR。&lt;/p&gt;
    
    </summary>
    
      <category term="shenyanghong" scheme="http://xgfe.github.io/categories/shenyanghong/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="anr" scheme="http://xgfe.github.io/tags/anr/"/>
    
      <category term="plugin" scheme="http://xgfe.github.io/tags/plugin/"/>
    
      <category term="gradle" scheme="http://xgfe.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>使用Node构建命令行</title>
    <link href="http://xgfe.github.io/2019/12/20/patrickLh/%E4%BD%BF%E7%94%A8Node%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://xgfe.github.io/2019/12/20/patrickLh/使用Node构建命令行/</id>
    <published>2019-12-20T01:00:00.000Z</published>
    <updated>2020-08-26T12:42:25.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是讲解如何使用Node构建自己的命令行，并对其实现原理做了一定的解析。</p><a id="more"></a><h2 id="构建命令行"><a href="#构建命令行" class="headerlink" title="构建命令行"></a>构建命令行</h2><h3 id="扩展Node参数解析"><a href="#扩展Node参数解析" class="headerlink" title="扩展Node参数解析"></a>扩展Node参数解析</h3><p>我们执行一个node命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure></p><p>使用<code>process.argv</code>，可以拿到相关<code>node</code>命令执行的所有参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">console.log(process.argv);</span><br><span class="line">// 运行以下指令</span><br><span class="line">node index x y; // [&apos;/usr/local/bin/node&apos;, &apos;.../index&apos;, &apos;x&apos;, &apos;y&apos;]</span><br></pre></td></tr></table></figure></p><p>可以根据业务逻辑来自行解析处理这些参数，也可以引入<code>commander</code>库来帮助扩展命令行参数解析，<code>commaneder</code>将所有的参数结构化，在使用的时候更加方便。</p><h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>使用<code>commander.option()</code>的方法，可以扩展当前指令能够支持的参数，并使用<code>commander.parse(process.argv)</code>将命令行参数告知<code>commander</code>进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">let program = require(&apos;commander&apos;);</span><br><span class="line">// 增加命令支持的参数</span><br><span class="line">program.option(&apos;-x, --extend&apos;, &apos;get all&apos;);</span><br><span class="line">program.option(&apos;-y, --yield &lt;type&gt;&apos;, &apos;set block type&apos;, &apos;defaultValue&apos;);</span><br><span class="line">//  program.option(&apos;-y, --yield &lt;type&gt;&apos;, &apos;set block type&apos;, (newValue, previous) =&gt; &#123;</span><br><span class="line">//    return newValue</span><br><span class="line">//  &#125;)</span><br><span class="line">// 将node参数转为program对象中使用</span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line">if (program.extend) &#123;</span><br><span class="line">    console.log(program.opts());</span><br><span class="line">&#125;</span><br><span class="line">if (program.yield) &#123;</span><br><span class="line">    console.log(program.yield);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行命令后，可以看到相关输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js -x value1 -y value2 // &#123; extend: true, yield: &apos;value2&apos; &#125;, value2</span><br></pre></td></tr></table></figure></p><p>PS：</p><ol><li><code>option</code>第三个参数可以设置默认值，也可以使用函数，对解析后的参数值进行处理。</li><li><code>-x</code>中的<code>x</code>将作为简称在命令行执行时候使用，<code>--extend</code>中的<code>extend</code>将作为最后对象的属性使用。</li></ol><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>使用<code>commander.version()</code>函数可以指定当前命令行工具的版本，通常版本信息从<code>package.json</code>中读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let program = require(&apos;commander&apos;);</span><br><span class="line">let pkg = require(&apos;./package.json&apos;);</span><br><span class="line">program.version(pkg.version, &apos;-v, --vers&apos;, &apos;description&apos;);</span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure></p><p>之后执行以下命令获取到版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js -v</span><br></pre></td></tr></table></figure></p><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>如果需要扩展子命令（例如：<code>vue create</code>），可以使用<code>commander.command()</code>方法，并利用<code>comander.action()</code>函数，可以获得子命令中定义的参数<code>&lt;arg1&gt;</code>(必填) ,<code>[arg2]</code>（可选）和<code>option()</code>设置的命令行参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let program = require(&apos;commander&apos;);</span><br><span class="line">program.command(&apos;create &lt;arg1&gt; [arg2]&apos;)</span><br><span class="line">.description(&apos;description&apos;)</span><br><span class="line">.option(&apos;-x, --extend &lt;type&gt;&apos;, &apos;extend a message&apos;)</span><br><span class="line">.option(&apos;-y, --yield &lt;type&gt;&apos;, &apos;yield a message&apos;)</span><br><span class="line">.action((arg1, arg2, cmdObj) =&gt; &#123;</span><br><span class="line">    // todo</span><br><span class="line">    console.log(arg1, arg2, cmdObj);</span><br><span class="line">&#125;)</span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure></p><p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index create infile outfile -x 1 -y 2; // infile, outfile, &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>PS：每次运行<code>command()</code>方法，内部都会实例化一个新的对象，之后的<code>option</code>和<code>action</code>都是会绑定在新<code>command</code>的对象上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let program = require(&apos;commander&apos;);</span><br><span class="line">program.command(&apos;create &lt;arg1&gt; [arg2]&apos;)</span><br><span class="line">.description(&apos;description&apos;)</span><br><span class="line">.option(&apos;-x, --extend&apos;, &apos;create option&apos;) // 这里-x是create命令的参数</span><br><span class="line">.command(&apos;drop &lt;arg1&gt;&apos;)</span><br><span class="line">.options(&apos;-y, --yield&apos;, &apos;drop option&apos;) // 这里-y是drop命令的参数</span><br></pre></td></tr></table></figure></p><h3 id="控制台交互"><a href="#控制台交互" class="headerlink" title="控制台交互"></a>控制台交互</h3><p>在使用命令行工具的时候，我们通常会使用到很多交互操作，以@<code>vue/cli</code>为例，命令行在创建项目的过程中，会提出问题，需要用户进行输入，选择某些特性。要实现这样的交互，我们可以使用<code>inquirer</code>库来进行辅助。</p><p><code>inquirer</code>的使用十分简单，以<code>prompt</code>函数作为入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let inquirer = require(&apos;inquirer&apos;);</span><br><span class="line">inquirer.prompt([&#123;</span><br><span class="line">    type&lt;string&gt;: &apos;&apos;, // 输入类型包括：input, confirm, list, rawlist(有序列表)，expand, checkbox, password(隐藏输入模式)，editor（进入vi编辑模式）</span><br><span class="line">    name&lt;string&gt;: &apos;&apos;, // 必须，answers中获取时对应的属性名</span><br><span class="line">    message&lt;string|Function&gt;: &apos;&apos;, // 提示信息</span><br><span class="line">    default&lt;string|number|Array|Function&gt;: &apos;&apos;, // 默认值设置</span><br><span class="line">    choices&lt;Array|Function&gt;: &apos;&apos;, // 选项，用于list，rowlist，expand，checkbox</span><br><span class="line">    validate&lt;Function&gt;: &apos;&apos;, // 验证输入值是否符合要求</span><br><span class="line">    filter&lt;Function&gt;: &apos;&apos;, // 对当前requestion的结果做处理</span><br><span class="line">    when&lt;Function|boolean&gt;: &apos;&apos;, // 后续的question可以获取谦虚前序的所有answers</span><br><span class="line">    pageSize&lt;number&gt;: &apos;&apos;, // 选项的分页数量</span><br><span class="line">    prefix&lt;String&gt;: &apos;&apos;, // 提示问题显示的前缀</span><br><span class="line">    suffix&lt;String&gt;: &apos;&apos;, // 提示问题显示的后缀</span><br><span class="line">&#125;]).then(answers =&gt; &#123;</span><br><span class="line">    // 多结果数组</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>prompt</code>接受一个<code>question</code>数组，每个<code>question</code>设置<code>type</code>和<code>name</code>，在用户交互以后，通过<code>then</code>回调拿到对应的数据，所有的结果数据通过<code>anwsers[name]</code>的方式获取，这里的<code>name</code>就是在每一个<code>question</code>中配置的<code>name</code>，所以<code>name</code>必须要唯一。</p><h3 id="安装命令行"><a href="#安装命令行" class="headerlink" title="安装命令行"></a>安装命令行</h3><p>在使用相关命令构建好命令行代码片段以后，我们想直接使用例如：<code>kibo create</code>的方式来执行命令行而不是<code>node kibo.js create</code>，可以将本地的包推到<code>npm</code>上，再利用<code>npm</code>的<code>install -g</code>特性进行安装，安装以后则可以全局使用，于是可以通过以下方式将包上传到<code>npm</code></p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>在编写好<code>js</code>脚本以后，首先需要创建<code>package.json</code>文件，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><h4 id="配置相关依赖"><a href="#配置相关依赖" class="headerlink" title="配置相关依赖"></a>配置相关依赖</h4><p>之后配置可以安装我们脚本中所需要使用到的依赖包，可以直接修改<code>package.json</code>文件，也可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save commender inquirer</span><br></pre></td></tr></table></figure></p><p>PS：由于我们需要将包上传到npm并使用，所以如果手动配置，这里的依赖是需要放到<code>package.json</code>中的<code>dependences</code>中</p><h4 id="配置bin属性"><a href="#配置bin属性" class="headerlink" title="配置bin属性"></a>配置bin属性</h4><p>我们需要增加/修改<code>pacakge.json</code>的<code>bin</code>属性，并将我们希望使用的命令行指令指向入口文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    bin: &#123;</span><br><span class="line">        &apos;kibo&apos;: &apos;./index.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="登陆npm发布"><a href="#登陆npm发布" class="headerlink" title="登陆npm发布"></a>登陆npm发布</h4><p>最后，配置完成以后，检查<code>pacakge.json</code>的名称，版本号，描述，就可以登陆<code>npm</code>进行发布，发布成功以后就可以通过<code>npm install</code>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// npm登陆</span><br><span class="line">npm login</span><br><span class="line">// 执行推送，注意package.json中的name不能有所重复</span><br><span class="line">npm publish</span><br><span class="line">// 如果要取消发布，可以使用以下命令</span><br><span class="line">npm unpublish --force</span><br></pre></td></tr></table></figure></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>控制台输出内容的颜色和背景色默认都是系统颜色，对于警告，错误我们通常会使用更醒目的颜色来显示，所以我们可以使用<code>chalk</code>库，通过其提供的方法<code>chalk.&lt;style&gt;(text)</code>来对我们输出内容的文本颜色进行设置，例如设置一个文本输出为红色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let chalk = require(&apos;chalk&apos;);</span><br><span class="line">console.log(chalk.red(&apos;this is a danger message&apos;));</span><br></pre></td></tr></table></figure></p><h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><p>根据上面的描述，写一个简单的在当前目录下创建一个特定文件，且文件中包含输入的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">let program = require(&apos;commander&apos;);</span><br><span class="line">let inquirer = require(&apos;inquirer&apos;);</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">program.command(&apos;create &lt;filename&gt;&apos;)</span><br><span class="line">.description(&apos;创建一个新的文件&apos;)</span><br><span class="line">.option(&apos;-d, --dest &lt;path&gt;&apos;, &apos;文件路径&apos;, &apos;.&apos;)</span><br><span class="line">.action((filename, cmdObj) =&gt; &#123;</span><br><span class="line">  // 判断文件路径是否存在，如果不存在需要创建文件结构</span><br><span class="line">  mkdir(cmdObj.dest);</span><br><span class="line">  inquirer.prompt([&#123;</span><br><span class="line">    name: &apos;extend&apos;,</span><br><span class="line">    type: &apos;list&apos;,</span><br><span class="line">    message: &apos;选择需要创建的文件类型&apos;,</span><br><span class="line">    choices: [&#123;name: &apos;html文件&apos;, value: &apos;html&apos;&#125;,</span><br><span class="line">              &#123;name: &apos;css文件&apos;, value: &apos;css&apos;&#125;,</span><br><span class="line">              &#123;name: &apos;javascript文件&apos;, value: &apos;js&apos;&#125;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &apos;content&apos;,</span><br><span class="line">    type: &apos;editor&apos;,</span><br><span class="line">    message: &apos;输入文件内容&apos;</span><br><span class="line">  &#125;]).then(answers =&gt; &#123;</span><br><span class="line">    fs.writeFileSync(`$&#123;cmdObj.dest&#125;/$&#123;filename&#125;.$&#123;answers.extend&#125;`, answers.content);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function mkdir(path) &#123;</span><br><span class="line">  let p = path.split(&apos;/&apos;);</span><br><span class="line">  let dir = p.reduce((accumulate, item) =&gt; &#123;</span><br><span class="line">    if (!fs.existsSync(accumulate)) &#123;</span><br><span class="line">      fs.mkdirSync(accumulate);</span><br><span class="line">    &#125;</span><br><span class="line">    return accumulate + &apos;/&apos; + item;</span><br><span class="line">  &#125;, &apos;.&apos;);</span><br><span class="line">  // 创建最后的目录</span><br><span class="line">  if (!fs.existsSync(dir)) &#123;</span><br><span class="line">    fs.mkdirSync(dir);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br><span class="line">// 如果参数少于2个弹出帮助提示</span><br><span class="line">if (!process.argv.slice(2).length) &#123;</span><br><span class="line">  program.outputHelp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="核心源码解析"><a href="#核心源码解析" class="headerlink" title="核心源码解析"></a>核心源码解析</h2><h3 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h3><p>之前已经提及了<code>commander</code>如何使用，我们认为其目的是主要对<code>process.argv</code>进行了解析，那么如何解析？可以通过查看源码来学习</p><p>入口文件中，引入对是一个<code>Command</code>对象实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">function Command(name) &#123;</span><br><span class="line">  this.commands = [];</span><br><span class="line">  this.options = [];</span><br><span class="line">  this._execs = new Set();</span><br><span class="line">  this._allowUnknownOption = false;</span><br><span class="line">  this._args = [];</span><br><span class="line">  this._name = name || &apos;&apos;;</span><br><span class="line"></span><br><span class="line">  this._helpFlags = &apos;-h, --help&apos;;</span><br><span class="line">  this._helpDescription = &apos;output usage information&apos;;</span><br><span class="line">  this._helpShortFlag = &apos;-h&apos;;</span><br><span class="line">  this._helpLongFlag = &apos;--help&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后我们通过调用<code>option()</code>方法来扩展命令，<code>option</code>方法主要会将所有设置的内容存放到<code>Command</code>对象的<code>options</code>属性中，并绑定特定事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command.prototype._optionEx = function(config, flags, description, fn, defaultValue) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 第419行</span><br><span class="line">    this.options.push(option);</span><br><span class="line">    // 绑定事件</span><br><span class="line">    this.on(&apos;option:&apos; + oname, function(val) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要说明一下，这里的事件绑定是使用<code>node</code>的<code>events</code>来扩展到<code>Command</code>对象上实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 第6行</span><br><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line">// 第16行</span><br><span class="line">require(&apos;util&apos;).inherits(Command, EventEmitter);</span><br></pre></td></tr></table></figure></p><p>而我们在调用<code>command()</code>方法的时候，则会在<code>commands</code>属性中增加内容，并将返回当前对象，也就是说，在调用<code>command()</code>之后，之后配置都会挂载到新设置到<code>Command</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Command.prototype.command = function(nameAndArgs, actionOptsOrExecDesc, execOpts) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 172行</span><br><span class="line">    var cmd = new Command(args.shift());</span><br><span class="line">    ...</span><br><span class="line">    // 188行</span><br><span class="line">    this.commands.push(cmd);</span><br><span class="line">    cmd.parseExpectedArgs(args);</span><br><span class="line">    cmd.parent = this;</span><br><span class="line">    if (desc) return this;</span><br><span class="line">    return cmd;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>action()</code>方法调用的时候，会调用当前<code>command</code>的事件绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Command.prototype.action = function(fn) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 362行</span><br><span class="line">    var parent = this.parent || this;</span><br><span class="line">    var name = parent === this ? &apos;*&apos; : this._name;</span><br><span class="line">    parent.on(&apos;command:&apos; + name, listener);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后调用<code>parse()</code>方法，完成对输入<code>node</code>参数的解析（通过触发设置的事件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 542行</span><br><span class="line">Command.prototype.parse = function(argv) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="inquirer"><a href="#inquirer" class="headerlink" title="inquirer"></a>inquirer</h3><p>从表现上来看，<code>inquirer</code>要完成交互，需要处理两个问题：第一个是如何处理键盘的操作（输入，方向键），另一个是如何在输入操作以后对输入结果进行渲染。</p><p>以<code>prompt()</code>方法来作为入口，在调用的时候，会创建以下的实例，并运行<code>run</code>方法（根据<code>type</code>不同，这里的<code>ui</code>对象也不同，简单的工厂模式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// inquirer.js</span><br><span class="line">// 25行</span><br><span class="line">inquirer.createPromptModule = function(opt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var ui = new inquirer.ui.Prompt(promptModule.prompts, opt);</span><br><span class="line">    var promise = ui.run(questions);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以<code>type: list</code>为例，可以看到主要进行了键位监听，处理光标，渲染操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// prompts/list.js</span><br><span class="line">// 49行</span><br><span class="line">  _run(cb) &#123;</span><br><span class="line">    this.done = cb;</span><br><span class="line">    var self = this;</span><br><span class="line">    // 事件监听</span><br><span class="line">    var events = observe(this.rl);</span><br><span class="line">    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));</span><br><span class="line">    events.normalizedDownKey</span><br><span class="line">      .pipe(takeUntil(events.line))</span><br><span class="line">      .forEach(this.onDownKey.bind(this));</span><br><span class="line">    events.numberKey.pipe(takeUntil(events.line)).forEach(this.onNumberKey.bind(this));</span><br><span class="line">    events.line</span><br><span class="line">      .pipe(</span><br><span class="line">        take(1),</span><br><span class="line">        map(this.getCurrentValue.bind(this)),</span><br><span class="line">        flatMap(value =&gt; runAsync(self.opt.filter)(value).catch(err =&gt; err))</span><br><span class="line">      )</span><br><span class="line">      .forEach(this.onSubmit.bind(this));</span><br><span class="line"></span><br><span class="line">    // Init the prompt</span><br><span class="line">    cliCursor.hide();</span><br><span class="line">    // 输出渲染</span><br><span class="line">    this.render();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="键盘监听"><a href="#键盘监听" class="headerlink" title="键盘监听"></a>键盘监听</h4><p>源码中使用了<code>rxjs</code>，但是核心代码是监听键盘输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// utils/events</span><br><span class="line">// 10行</span><br><span class="line">// 这里的fromEvent，takeUntil，pipe，filter都是rxjs相关的api</span><br><span class="line">// rl是node自带的readline库的实例</span><br><span class="line">var keypress = fromEvent(rl.input, &apos;keypress&apos;, normalizeKeypressEvents)</span><br><span class="line">    .pipe(takeUntil(fromEvent(rl, &apos;close&apos;)))</span><br><span class="line">    // Ignore `enter` key. On the readline, we only care about the `line` event.</span><br><span class="line">    .pipe(filter((&#123; key &#125;) =&gt; key.name !== &apos;enter&apos; &amp;&amp; key.name !== &apos;return&apos;));</span><br></pre></td></tr></table></figure></p><p>可以看到，在<code>rl.input</code>监听了<code>keypress</code>事件，将以上代码转换为非<code>rxjs</code>的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const readline = require(&apos;readline&apos;);</span><br><span class="line">// 如果增加mute-stream</span><br><span class="line">// var MuteStream = require(&apos;mute-stream&apos;);</span><br><span class="line">// var ms = new MuteStream();</span><br><span class="line">// ms.pipe(process.stdout);</span><br><span class="line">// 设置输入输出流</span><br><span class="line">let rl = readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout,</span><br><span class="line">  // output: ms,</span><br><span class="line">&#125;);</span><br><span class="line">// 监听每行输入，当输入回车的时候会触发改读入行操作</span><br><span class="line">rl.on(&apos;line&apos;, (input) =&gt; &#123;</span><br><span class="line">  console.log(`Received: $&#123;input&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line">// 增加输入键盘监听</span><br><span class="line">rl.input.on(&apos;keypress&apos;, (value, key) =&gt; &#123;</span><br><span class="line">    console.log(`key.name: $&#123;key.name&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>本质核心是<code>process.stdin</code>的键盘监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(&apos;keypress&apos;, (value, key) =&gt; &#123;</span><br><span class="line">    console.log(`key.name: $&#123;key.name&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="渲染处理"><a href="#渲染处理" class="headerlink" title="渲染处理"></a>渲染处理</h4><p>渲染处理引用了<code>mute-stream</code>的库来进行辅助，可以在调用相关方法（<code>mute</code>,<code>unmute</code>）的时候，存储内容一次性输出内容，渲染的核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.screen.render(message);</span><br><span class="line">// utils/screen-manager</span><br><span class="line">// 25行</span><br><span class="line">render(content, bottomContent) &#123;</span><br><span class="line">    this.rl.output.unmute();</span><br><span class="line">    this.clean(this.extraLinesUnderPrompt);</span><br><span class="line">    ...</span><br><span class="line">    this.rl.output.write(fullContent);</span><br><span class="line">    ...</span><br><span class="line">    this.rl.output.mute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 94行</span><br><span class="line">clean(extraLines) &#123;</span><br><span class="line">    if (extraLines &gt; 0) &#123;</span><br><span class="line">      util.down(this.rl, extraLines);</span><br><span class="line">    &#125;</span><br><span class="line">    util.clearLine(this.rl, this.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>渲染中最需要解决的问题在于，如何将控制台输出的内容清空后重新渲染，使用扩展库<code>ansi-escapes</code>可以实现这一效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ansiEscapes = require(&apos;ansi-escapes&apos;);</span><br><span class="line">rl.output.write(ansiEscapes.eraseLines(1));</span><br></pre></td></tr></table></figure></p><p>但是扩展库的本质是通过什么操作使得清空能得以实现？进一步阅读扩展库方法，可以看到扩展库在我们输出的字符串中增加了相关的内容，从而实现了清空控制台已输出内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 6行</span><br><span class="line">const ESC = &apos;\u001B[&apos;;</span><br><span class="line">// 41行</span><br><span class="line">ansiEscapes.cursorUp = (count = 1) =&gt; ESC + count + &apos;A&apos;;</span><br><span class="line">// 51行</span><br><span class="line">ansiEscapes.cursorLeft = ESC + &apos;G&apos;;</span><br><span class="line">// 60行</span><br><span class="line">ansiEscapes.eraseLines = count =&gt; &#123;</span><br><span class="line">  let clear = &apos;&apos;;</span><br><span class="line">  for (let i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    clear += ansiEscapes.eraseLine + (i &lt; count - 1 ? ansiEscapes.cursorUp() : &apos;&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (count) &#123;</span><br><span class="line">    clear += ansiEscapes.cursorLeft;</span><br><span class="line">  &#125;</span><br><span class="line">  return clear;</span><br><span class="line">&#125;;</span><br><span class="line">// 76行</span><br><span class="line">ansiEscapes.eraseLine = ESC + &apos;2K&apos;;</span><br></pre></td></tr></table></figure></p><p>对方法进行调用，实际上输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果调用改方法，则返回</span><br><span class="line">ansiEscapes.eraseLines(1); // &apos;\u001B[2K\u001B[1A\u001B[G&apos;;</span><br></pre></td></tr></table></figure></p><p>也就是说，如果我们在<code>node</code>脚本中使用以下内容，可以发现第二个输出并不会出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用标准输出流试一下</span><br><span class="line">console.log(1);</span><br><span class="line">console.log(2);</span><br><span class="line">process.stdout.write(&apos;\u001B[2K\u001B[1A\u001B[G&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a>chalk</h3><p><code>chalk</code>可以使得文本输出颜色发生改变，那么具体是如何改变的呢？调查源码，发现引用了外部库<code>ansi-styles</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// source/index.js 第2行</span><br><span class="line">const ansiStyles = require(&apos;ansi-styles&apos;);</span><br></pre></td></tr></table></figure></p><p>外部库的核心操作，是在输出内容的前后增加了一段文本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.js  第125行</span><br><span class="line">styles[styleName] = &#123;</span><br><span class="line">    open: `\u001B[$&#123;style[0]&#125;m`,</span><br><span class="line">    close: `\u001B[$&#123;style[1]&#125;m`</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中，这里的<code>style</code>对象，以红色为例的开闭值为：[31, 39]，所以，如果想在控制台输出红色文本，在浏览器/<code>node</code>中可以使用以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(`\u001B[31m 测试 \u001B[39m`)</span><br></pre></td></tr></table></figure></p><p>最后为什么增加文本能输出红色呢？初步认为<code>node</code>和浏览器中的<code>console.log</code>参照了ANSI的颜色解析规则，在使用相关的<a href="https://tintin.sourceforge.io/info/ansicolor" target="_blank" rel="noopener"><code>ANSI colors</code></a>的解析规则，从而使得输出文本可以显示颜色，然而具体底层细节实现是怎么做到的就不清楚了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要构建一个完整的命令行，其本质上从需要解决什么问题出发，然后推及到每一步操作如何实现（解析参数，输入交互，变为可执行命令行），同时再拆分到每一步的实现过程中的具体技术，最后将所有的组合起来。</p><p>对于第三方库的使用，能很快的解决问题，但是如果有时间，了解代码本质的实现逻辑，可以扩展自己对编程的认知，便于以后解决问题的思路扩展。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander</a></p><p><a href="https://github.com/SBoudrias/Inquirer.js#readme" target="_blank" rel="noopener">inquirer</a></p><p><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a></p><p><a href="https://tintin.sourceforge.io/info/ansicolor" target="_blank" rel="noopener">ANSI Colors</a></p><p><a href="https://nodejs.org/docs/latest/api/readline.html" target="_blank" rel="noopener">Node readline</a></p><p><a href="https://nodejs.org/docs/latest/api/process.html" target="_blank" rel="noopener">Node process</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是讲解如何使用Node构建自己的命令行，并对其实现原理做了一定的解析。&lt;/p&gt;
    
    </summary>
    
      <category term="patrickLh" scheme="http://xgfe.github.io/categories/patrickLh/"/>
    
    
      <category term="前端" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>文件上传那些事</title>
    <link href="http://xgfe.github.io/2019/12/19/zuopengfei/upload/"/>
    <id>http://xgfe.github.io/2019/12/19/zuopengfei/upload/</id>
    <published>2019-12-19T11:18:00.000Z</published>
    <updated>2020-08-26T12:42:25.087Z</updated>
    
    <content type="html"><![CDATA[<p>本文是写给新手前端的各种文件上传攻略，本文涉及到的知识点包括：文件上传的基本原理；最原始的基于form表单的文件上传；基于xhr2的文件上传、文件上传进度、终止上传；拖拽上传、剪贴板上传、大文件分片上传、大文件断点续传。</p><a id="more"></a><h2 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h2><p>文件上传其实就是根据http协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件。</p><p>如果要上传一个文件，http请求的method必须为post方法；content-type类型必须是multipart/form-data；如果使用form表单上传文件时，必须让form的enctyped等于multipart/form-data。</p><h3 id="什么是multipart-form-data？"><a href="#什么是multipart-form-data？" class="headerlink" title="什么是multipart/form-data？"></a>什么是multipart/form-data？</h3><p>multipart表示混合资源，也就是由多种元素组成的资源。</p><h3 id="multipart-form-data的结构"><a href="#multipart-form-data的结构" class="headerlink" title="multipart/form-data的结构"></a>multipart/form-data的结构</h3><p><img src="https://p0.meituan.net/spacex/c3c978ff56b657f370a38ace0be3d5b9.png" alt="multipart/form-data的结构"></p><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><p>Content-Type: multipart/form-data; boundary=—-WebKitFormBoundaryDCntfiXcSkPhS4PN 表示本次请求要上传文件；其中boundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由—-WebKitFormBoundaryXXX开始，以—-WebKitFormBoundaryXXX–结尾。</p><h4 id="请求消息体Form-Data-部分"><a href="#请求消息体Form-Data-部分" class="headerlink" title="请求消息体Form Data 部分:"></a>请求消息体Form Data 部分:</h4><p>每一个表单项又由Content-Type和Content-Disposition组成。</p><p>Content-Disposition：form-data 为固定值，表示一个表单元素；name 表示表单元素的名称；回车换行后面就是name的值；</p><p>如果是上传文件是文件是二进制内容，则会多一个filename字段，表示上传文件的文件名称；还有多一个Content-Type：表示当前的内容的MIME类型，是图片、还是文本、还是二进制数据。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪是普通表单哪些是附件。</p><h2 id="基于form表单的最原始文件上传"><a href="#基于form表单的最原始文件上传" class="headerlink" title="基于form表单的最原始文件上传"></a>基于form表单的最原始文件上传</h2><h3 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h3><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/297e0daeab680d302d60d1a2bdb38b26" alt="基于form表单的文件上传"></p><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"http://localhost:8100"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">      选择文件: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span>/&gt;</span>input 必须设置 name 属性，否则数据无法发送<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"btn-0"</span>&gt;</span>上 传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="上传接口"><a href="#上传接口" class="headerlink" title="上传接口"></a>上传接口</h3><p>基于现有的库koa-body结合koa2实现服务端文件的解析和保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> koaStatic = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);<span class="comment">//文件保存库</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">'koa2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">var</span> port = process.env.PORT || <span class="string">'8100'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uploadHost= <span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>/uploads/`</span>;</span><br><span class="line"></span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">    formidable: &#123;</span><br><span class="line">        <span class="comment">//设置文件的默认保存目录，不设置则保存在系统临时目录下  os</span></span><br><span class="line">        uploadDir: path.resolve(__dirname, <span class="string">'../static/uploads'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    multipart: <span class="literal">true</span> <span class="comment">// 开启文件上传，默认是关闭</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态文件访问</span></span><br><span class="line">app.use(koaStatic(</span><br><span class="line">    path.resolve(__dirname, <span class="string">'../static'</span>) </span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件二次处理，修改名称</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file = ctx.request.files.f1;<span class="comment">//得道文件对象</span></span><br><span class="line">    <span class="keyword">var</span> path = file.path;</span><br><span class="line">    <span class="keyword">var</span> fname = file.name;<span class="comment">//原文件名称</span></span><br><span class="line">    <span class="keyword">var</span> nextPath = path+fname;</span><br><span class="line">    <span class="keyword">if</span>(file.size&gt;<span class="number">0</span> &amp;&amp; path)&#123;</span><br><span class="line">        <span class="comment">//得到扩展名</span></span><br><span class="line">        <span class="keyword">var</span> extArr = fname.split(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">var</span> ext = extArr[extArr.length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">var</span> nextPath = path+<span class="string">'.'</span>+ext;</span><br><span class="line">        <span class="comment">//重命名文件</span></span><br><span class="line">        fs.renameSync(path, nextPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以 json 形式输出上传文件地址</span></span><br><span class="line">    ctx.body = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">        "fileUrl":"<span class="subst">$&#123;uploadHost&#125;</span><span class="subst">$&#123;nextPath.slice(nextPath.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>)&#125;</span>"</span></span><br><span class="line"><span class="string">    &#125;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * http server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app.callback());</span><br><span class="line">server.listen(port);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'demo1 server start ......   '</span>);</span><br></pre></td></tr></table></figure><p>koa-body会自动保存文件到系统临时目录下，也可以指定保存的文件路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">✘  ~/work/gitstash/other/fe-learn-code-master  node</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> os.tmpdir()</span></span><br><span class="line">'/var/folders/mc/lfl3v3n954v2ynmd8zbmk0xw0000gp/T'</span><br></pre></td></tr></table></figure><p>然后在后续中间件内得到已保存的文件的信息；ctx.request.files.f1 可以得到上传的文件对象</p><table><thead><tr><th style="text-align:center">key</th><th style="text-align:center">名称</th><th style="text-align:center">demo</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">文件名</td><td style="text-align:center">包括扩展名，扩展名需要自己截取 var extArr = fname.split(‘.’); var ext = extArr[extArr.length-1];</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">文件路径</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">lastModifiedDate</td><td style="text-align:center">文件修改时间</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">文件大小</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">文件类型</td><td style="text-align:center"></td></tr></tbody></table><p>拿到文件后就可以做二次处理了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建可读流 <span class="keyword">const</span> reader = fs.createReadStream(file.path)</span><br><span class="line">创建可写流 <span class="keyword">const</span> writer = fs.createWriteStream(<span class="string">'upload/newpath.txt'</span>)</span><br><span class="line">可读流通过管道写入可写流 reader.pipe(writer)</span><br></pre></td></tr></table></figure><h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置 multiple属性</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span> <span class="attr">multiple</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>服务端也需要进行简单的调整，由单文件对象变为多文件数组，然后进行遍历处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> files = ctx.request.files.f1;<span class="comment">// 多文件， 得到上传文件的数组</span></span><br><span class="line"><span class="keyword">var</span> result=[];</span><br><span class="line"><span class="comment">//遍历处理</span></span><br><span class="line">files &amp;&amp; files.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><h2 id="局部刷新-iframe"><a href="#局部刷新-iframe" class="headerlink" title="局部刷新 - iframe"></a>局部刷新 - iframe</h2><h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/e6f1c57f474671bddd9268dde7d0f57b" alt="局部刷新 - iframe"></p><h3 id="前端代码-1"><a href="#前端代码-1" class="headerlink" title="前端代码"></a>前端代码</h3><p>页面内放一个隐藏的 iframe，或者使用 js 动态创建，指定 form 表单的 target 属性值为iframe标签 的 name 属性值，这样 form 表单的 shubmit 行为的跳转就会在 iframe 内完成，整体页面不会刷新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"temp-iframe"</span> <span class="attr">name</span>=<span class="string">"temp-iframe"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">target</span>=<span class="string">"temp-iframe"</span> <span class="attr">action</span>=<span class="string">"http://localhost:8100"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  选择文件(可多选): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span> <span class="attr">id</span>=<span class="string">"f1"</span> <span class="attr">multiple</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span> input 必须设置 name 属性，否则数据无法发送<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"btn-0"</span>&gt;</span>上 传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="如何拿到接口数据"><a href="#如何拿到接口数据" class="headerlink" title="如何拿到接口数据"></a>如何拿到接口数据</h3><p>为 iframe 添加load事件，得到 iframe 的页面内容，将结果转换为 JSON 对象，这样就拿到了接口的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'temp-iframe'</span>);</span><br><span class="line">iframe.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = iframe.contentWindow.document.body.innerText;</span><br><span class="line">      <span class="comment">//接口数据转换为 JSON 对象</span></span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">      <span class="keyword">if</span>(obj &amp;&amp; obj.fileUrl.length)&#123;</span><br><span class="line">          alert(<span class="string">'上传成功'</span>);</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="基于xhr2的文件上传"><a href="#基于xhr2的文件上传" class="headerlink" title="基于xhr2的文件上传"></a>基于xhr2的文件上传</h2><table><thead><tr><th style="text-align:center">XMLHttpRequest</th><th style="text-align:center">XMLHttpRequest2 </th></tr></thead><tbody><tr><td style="text-align:center">在 ie 时代就存在；只支持文本数据的传输；无法用来读取和上传二进制数据</td><td style="text-align:center">可以读取和上传二进制数据；可以使用·FormData·对象管理表单数据。</td></tr></tbody></table><h3 id="多文件上传-xhr-formdata"><a href="#多文件上传-xhr-formdata" class="headerlink" title="多文件上传-xhr formdata"></a>多文件上传-xhr formdata</h3><p>不用 form 表单元素包裹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">选择文件(可多选):</span><br><span class="line">  &lt;input type=<span class="string">"file"</span> id=<span class="string">"f1"</span> multiple/&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">  &lt;button type=<span class="string">"button"</span> id=<span class="string">"btn-submit"</span>&gt;上 传&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">submitUpload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获得文件列表，注意这里不是数组，而是FileList对象，每个</span></span><br><span class="line">    <span class="keyword">var</span> fileList = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>).files;</span><br><span class="line">    <span class="keyword">if</span>(!fileList.length)&#123;</span><br><span class="line">       alert(<span class="string">'请选择文件'</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造FormData对象</span></span><br><span class="line">    <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="comment">//多文件上传需要遍历添加到 fromdata 对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt;fileList.length; i++)&#123;</span><br><span class="line">        <span class="comment">//支持多文件上传</span></span><br><span class="line">        fd.append(<span class="string">'f1'</span>, fileList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();   <span class="comment">//创建对象</span></span><br><span class="line">    xhr.open(<span class="string">'POST'</span>, <span class="string">'http://localhost:8100/'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    xhr.send(fd);<span class="comment">//发送时  Content-Type默认就是: multipart/form-data; </span></span><br><span class="line">    ....                             </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多文件，单进度"><a href="#多文件，单进度" class="headerlink" title="多文件，单进度"></a>多文件，单进度</h3><h4 id="效果演示-1"><a href="#效果演示-1" class="headerlink" title="效果演示"></a>效果演示</h4><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/c61713f2f6f59ce31aa1693766317ecc" alt="多文件，单进度"></p><h4 id="获取进度条的原理"><a href="#获取进度条的原理" class="headerlink" title="获取进度条的原理"></a>获取进度条的原理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进度处理的监听函数</span></span><br><span class="line">xhr.upload.onprogress = updateProgress;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// event.lengthComputable这是一个状态，表示发送的长度有了变化，可计算</span></span><br><span class="line"><span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line"><span class="comment">// event.loaded表示发送了多少字节</span></span><br><span class="line">     <span class="comment">// event.total表示文件总大小</span></span><br><span class="line">     <span class="comment">// 根据event.loaded和event.total计算进度</span></span><br><span class="line"><span class="keyword">var</span> completedPercent = (event.loaded / event.total * <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">progressSpan.style.width= completedPercent+<span class="string">'%'</span>;</span><br><span class="line">progressSpan.innerHTML=completedPercent+<span class="string">'%'</span>;</span><br><span class="line"><span class="keyword">if</span>(completedPercent&gt;<span class="number">90</span>)&#123;<span class="comment">//进度条变色</span></span><br><span class="line">progressSpan.classList.add(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'已上传'</span>,completedPercent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意 send 一定要写在最下面，否则 onprogress 只会执行最后一次 也就是100%的时候</span></span><br><span class="line">xhr.send(fd);<span class="comment">//发送时  Content-Type默认就是: multipart/form-data;</span></span><br></pre></td></tr></table></figure><h3 id="多文件上传之预览、多进度条、终止上传"><a href="#多文件上传之预览、多进度条、终止上传" class="headerlink" title="多文件上传之预览、多进度条、终止上传"></a>多文件上传之预览、多进度条、终止上传</h3><p>上一个栗子的多文件上传只有一个进度条，有些需求可能会不大一样，需要观察到每个文件的上传进度，并且可以终止上传。</p><h4 id="效果演示-2"><a href="#效果演示-2" class="headerlink" title="效果演示"></a>效果演示</h4><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/bafc069ad266dd863776cbcda27572e6" alt="多文件，多进度"></p><h4 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h4><p>getObjectURL方法是一个用于获取本地图片的地址，使用该url可以显示图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.src = getObjectURL(file);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在图片加载成功后需要清除使用的内存</span></span><br><span class="line"><span class="built_in">window</span>.URL.revokeObjectURL(<span class="keyword">this</span>.src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多进度条"><a href="#多进度条" class="headerlink" title="多进度条"></a>多进度条</h4><p>每个file对象都创建一个与之对应的独立XMLHttpRequest对象，并行或者串行发送，每个file对象独立监听进度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//遍历文件信息进行上传</span></span><br><span class="line"> willFiles.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  xhrSend(&#123;</span><br><span class="line">  file:item.file,</span><br><span class="line">  progress:item.progress</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="终止上传"><a href="#终止上传" class="headerlink" title="终止上传"></a>终止上传</h4><p>取消请求的方法xhr.abort()调用后，xhr.readyState会立即变为4, 而不是0；但是MDN上说是0；所以这里需要做容错处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'state change'</span>, xhr.readyState);</span><br><span class="line"><span class="comment">//调用abort后，state立即变成了4,并不会变成0</span></span><br><span class="line"><span class="comment">//增加自定义属性 xhr.uploaded</span></span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp;  xhr.uploaded) &#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(xhr.responseText);   <span class="comment">//返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">if</span>(obj.fileUrl.length)&#123;</span><br><span class="line"><span class="comment">//alert('上传成功');</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖拽上传"><a href="#拖拽上传" class="headerlink" title="拖拽上传"></a>拖拽上传</h2><h3 id="效果演示-3"><a href="#效果演示-3" class="headerlink" title="效果演示"></a>效果演示</h3><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/3dc77833bca65bcc35c2c379291e118d" alt="拖拽上传"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为拖拽区域绑定事件；鼠标在拖拽区域上 dragover, 鼠标离开拖拽区域dragleave, 在拖拽区域上释放文件drop</p><table><thead><tr><th style="text-align:center">针对对象</th><th style="text-align:center">事件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">说明</td><td style="text-align:center">dragenter</td><td style="text-align:center">当被拖动元素进入目的地元素所占据的屏幕空间时触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">dragover</td><td style="text-align:center">当被拖动元素在目的地元素内时触发</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">dragleave</td><td style="text-align:center">当被拖动元素没有放下就离开目的地元素时触发</td></tr></tbody></table><p>drop事件内获得拖动操作中的文件列表 e.dataTransfer.files<br>取消drop 事件的默认行为e.preventDefault()；不然浏览器会直接打开文件</p><h2 id="剪贴板上传"><a href="#剪贴板上传" class="headerlink" title="剪贴板上传"></a>剪贴板上传</h2><h3 id="效果演示-4"><a href="#效果演示-4" class="headerlink" title="效果演示"></a>效果演示</h3><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/c70ba1f24daa2f0d8647e18f8c728fb2" alt="剪贴板上传"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面内增加一个可编辑的编辑区域div.editor-box,开启contenteditable</span></span><br><span class="line"><span class="comment">// 为div.editor-box绑定paste事件</span></span><br><span class="line">box.addEventListener(<span class="string">'paste'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 处理paste 事件，从event.clipboardData || window.clipboardData获得数据</span></span><br><span class="line">        <span class="keyword">var</span> data = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">        <span class="built_in">console</span>.dir(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> items = data.items;</span><br><span class="line">        <span class="keyword">var</span> fileList = [];<span class="comment">//存储文件数据</span></span><br><span class="line">        <span class="keyword">if</span> (items &amp;&amp; items.length) &#123;</span><br><span class="line">            <span class="comment">// 检索剪切板items</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(items[i].getAsFile());</span><br><span class="line">                <span class="comment">// 将数据转换为文件items[i].getAsFile()</span></span><br><span class="line">                fileList.push(items[i].getAsFile());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data.items.length'</span>, data.items.length);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data.files.length'</span>, data.files.length);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.willUploadFileList = fileList;</span><br><span class="line">        event.preventDefault();</span><br><span class="line"></span><br><span class="line">        submitUpload();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="大文件分片上传"><a href="#大文件分片上传" class="headerlink" title="大文件分片上传"></a>大文件分片上传</h2><p>如果太大的文件，比如一个视频1g 2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分 比如2M。</p><h3 id="演示效果-1"><a href="#演示效果-1" class="headerlink" title="演示效果"></a>演示效果</h3><p><img src="https://s3plus.meituan.net/v1/mss_877fd457c4cf425388a58130e2279ae8/file/1c9bbe108cb91d7e97c9231df6243095" alt="大文件分片上传"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>相信大家都对Blob 对象有所了解，它表示原始数据,也就是二进制数据，同时提供了对数据截取的方法slice, 而 File 继承了Blob的功能，所以可以直接使用此方法对数据进行分段截取。</p><h4 id="前端逻辑："><a href="#前端逻辑：" class="headerlink" title="前端逻辑："></a>前端逻辑：</h4><p>把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件。</p><p>浏览器端所有分片上传完成，发送给服务端一个合并文件的请求 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">submitUpload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> chunkSize=<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//分片大小 2M</span></span><br><span class="line">        <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>).files[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> chunks=[], <span class="comment">//保存分片数据</span></span><br><span class="line">        token = (+ <span class="keyword">new</span> <span class="built_in">Date</span>()),<span class="comment">//时间戳</span></span><br><span class="line">        name =file.name,</span><br><span class="line">        chunkCount=<span class="number">0</span>,</span><br><span class="line">        sendChunkCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分片逻辑  像操作字符串一样    </span></span><br><span class="line">        <span class="keyword">if</span>(file.size &gt; chunkSize)&#123;</span><br><span class="line">            <span class="comment">//拆分文件</span></span><br><span class="line">            <span class="keyword">var</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                end += chunkSize;</span><br><span class="line">                <span class="keyword">var</span> blob = file.slice(start,end);</span><br><span class="line">                start += chunkSize;</span><br><span class="line">                <span class="keyword">if</span>(!blob.size)&#123;<span class="comment">//截取的数据为空 则结束</span></span><br><span class="line">                    <span class="comment">//拆分结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chunks.push(blob);<span class="comment">//保存分段数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chunks.push(file.slice(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chunkCount=chunks.length;<span class="comment">//分片的个数 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没有做并发限制，较大文件导致并发过多，tcp 链接被占光 ，需要做下并发控制，比如只有4个在请求在发送</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; chunkCount;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();   <span class="comment">//构造FormData对象</span></span><br><span class="line">            fd.append(<span class="string">'token'</span>, token);</span><br><span class="line">            fd.append(<span class="string">'f1'</span>, chunks[i]);</span><br><span class="line">            fd.append(<span class="string">'index'</span>, i);</span><br><span class="line">            xhrSend(fd, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                sendChunkCount+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(sendChunkCount===chunkCount)&#123;<span class="comment">//上传完成，发送合并请求</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'上传完成，发送合并请求'</span>);</span><br><span class="line">                    <span class="keyword">var</span> formD = <span class="keyword">new</span> FormData();</span><br><span class="line">                    formD.append(<span class="string">'type'</span>,<span class="string">'merge'</span>);</span><br><span class="line">                    formD.append(<span class="string">'token'</span>,token);</span><br><span class="line">                    formD.append(<span class="string">'chunkCount'</span>,chunkCount);</span><br><span class="line">                    formD.append(<span class="string">'filename'</span>,name);</span><br><span class="line">                    xhrSend(formD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">xhrSend</span>(<span class="params">fd,cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, <span class="string">'http://localhost:8100/'</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'state change'</span>, xhr.readyState);</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">                cb &amp;&amp; cb();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(fd);<span class="comment">//发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定提交事件</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'btn-submit'</span>).addEventListener(<span class="string">'click'</span>,submitUpload);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ul><li>服务端保存各段文件</li><li>浏览器端所有分片上传完成，发送给服务端一个合并文件的请求 </li><li>服务端根据文件标识、类型、各分片顺序进行文件合并</li><li>删除分片文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二次处理文件，修改名称</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body = ctx.request.body;</span><br><span class="line">    <span class="keyword">var</span> files = ctx.request.files ? ctx.request.files.f1:[];<span class="comment">//得到上传文件的数组</span></span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    <span class="keyword">var</span> fileToken = ctx.request.body.token;<span class="comment">// 文件标识</span></span><br><span class="line">    <span class="keyword">var</span> fileIndex=ctx.request.body.index;<span class="comment">//文件顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(files &amp;&amp;  !<span class="built_in">Array</span>.isArray(files))&#123;<span class="comment">//单文件上传容错</span></span><br><span class="line">        files=[files];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files &amp;&amp; files.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> path = item.path;</span><br><span class="line">        <span class="keyword">var</span> fname = item.name;<span class="comment">//原文件名称</span></span><br><span class="line">        <span class="keyword">var</span> nextPath = path.slice(<span class="number">0</span>, path.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>) + fileIndex + <span class="string">'-'</span> + fileToken;</span><br><span class="line">        <span class="keyword">if</span> (item.size &gt; <span class="number">0</span> &amp;&amp; path) &#123;</span><br><span class="line">            <span class="comment">//得到扩展名</span></span><br><span class="line">            <span class="keyword">var</span> extArr = fname.split(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">var</span> ext = extArr[extArr.length - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//var nextPath = path + '.' + ext;</span></span><br><span class="line">            <span class="comment">//重命名文件</span></span><br><span class="line">            fs.renameSync(path, nextPath);</span><br><span class="line">            result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(body.type===<span class="string">'merge'</span>)&#123;<span class="comment">//合并分片文件</span></span><br><span class="line">        <span class="keyword">var</span> filename = body.filename,</span><br><span class="line">        chunkCount = body.chunkCount,</span><br><span class="line">        folder = path.resolve(__dirname, <span class="string">'../static/uploads'</span>)+<span class="string">'/'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">`<span class="subst">$&#123;folder&#125;</span><span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cindex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//合并文件</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fnMergeFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fname = <span class="string">`<span class="subst">$&#123;folder&#125;</span><span class="subst">$&#123;cindex&#125;</span>-<span class="subst">$&#123;fileToken&#125;</span>`</span>;</span><br><span class="line">            <span class="keyword">var</span> readStream = fs.createReadStream(fname);</span><br><span class="line">            readStream.pipe(writeStream, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">            readStream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fs.unlink(fname, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> (cindex+<span class="number">1</span> &lt; chunkCount)&#123;</span><br><span class="line">                    cindex += <span class="number">1</span>;</span><br><span class="line">                    fnMergeFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        fnMergeFile();</span><br><span class="line">        ctx.body=<span class="string">'merge ok 200'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="大文件断点续传"><a href="#大文件断点续传" class="headerlink" title="大文件断点续传"></a>大文件断点续传</h2><p>上面我们实现了大文件的分片上传，解决了大文件上传超时和服务器的限制。</p><p>但是仍然不够完美，大文件上传并不是短时间内就上传完成，如果期间断网，页面刷新了仍然需要重头上传,这种时间的浪费怎么能忍？</p><p>所以我们实现断点续传，已上传的部分跳过，只传未上传的部分。</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在上面我们实现了文件分片上传和最终的合并，现在要做的就是如何检测这些分片，不再重新上传即可。 这里我们可以在本地进行保存已上传成功的分片，重新上传的时候使用spark-md5来生成文件 hash，区分此文件是否已上传。</p><ul><li>为每个分段生成 hash 值，使用 spark-md5 库</li><li>将上传成功的分段信息保存到本地</li><li>重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传</li></ul><p>模拟分段保存，本地保存到localStorage</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/获得本地缓存的数据</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUploadedFromStorage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse( localStorage.getItem(saveChunkKey) || <span class="string">"&#123;&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setUploadedToStorage</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj =  getUploadedFromStorage();</span><br><span class="line">        obj[index]=<span class="literal">true</span>;      </span><br><span class="line">        localStorage.setItem(saveChunkKey, <span class="built_in">JSON</span>.stringify(obj) );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分段对比</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> uploadedInfo = getUploadedFromStorage();<span class="comment">//获得已上传的分段信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; chunkCount;i++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'index'</span>,i, uploadedInfo[i]?<span class="string">'已上传过'</span>:<span class="string">'未上传'</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(uploadedInfo[i])&#123;<span class="comment">//对比分段</span></span><br><span class="line">                sendChunkCount=i+<span class="number">1</span>;<span class="comment">//记录已上传的索引</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//如果已上传则跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> fd = <span class="keyword">new</span> FormData();   <span class="comment">//构造FormData对象</span></span><br><span class="line">            fd.append(<span class="string">'token'</span>, token);</span><br><span class="line">            fd.append(<span class="string">'f1'</span>, chunks[i]);</span><br><span class="line">            fd.append(<span class="string">'index'</span>, i);</span><br><span class="line">           </span><br><span class="line">           (<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">                    xhrSend(fd, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    sendChunkCount += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//将成功信息保存到本地</span></span><br><span class="line">                    setUploadedToStorage(index);</span><br><span class="line">                    <span class="keyword">if</span> (sendChunkCount === chunkCount) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'上传完成，发送合并请求'</span>);</span><br><span class="line">                        <span class="keyword">var</span> formD = <span class="keyword">new</span> FormData();</span><br><span class="line">                        formD.append(<span class="string">'type'</span>, <span class="string">'merge'</span>);</span><br><span class="line">                        formD.append(<span class="string">'token'</span>, token);</span><br><span class="line">                        formD.append(<span class="string">'chunkCount'</span>, chunkCount);</span><br><span class="line">                        formD.append(<span class="string">'filename'</span>, name);</span><br><span class="line">                        xhrSend(formD);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基于上面一个栗子进行改进，服务端已保存了部分片段，客户端上传前需要从服务端获取已上传的分片信息（上面是保存在了本地浏览器），本地对比每个分片的 hash 值，跳过已上传的部分，只传未上传的分片</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前社区已经存在一些成熟的文件上传解决方案，如七牛SDK，腾讯云SDK等，也许并不需要我们手动去实现一个简陋的文件上传库，但是了解其原理还是十分有必要的。</p><p>本文首先整理了前端文件上传的几种方式，然后讨论了大文件上传的几种场景，以及大文件上传需要实现的几个功能</p><ul><li>通过Blob对象的slice方法将文件拆分成切片</li><li>整理了服务端还原文件所需条件和参数，演示了node将切片还原成文件</li><li>通过保存已上传切片的记录来实现断点续传</li></ul><p>还留下了一些问题，如：合并文件时避免内存溢出、切片失效策略，并没有去深入或一一实现，继续学习吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是写给新手前端的各种文件上传攻略，本文涉及到的知识点包括：文件上传的基本原理；最原始的基于form表单的文件上传；基于xhr2的文件上传、文件上传进度、终止上传；拖拽上传、剪贴板上传、大文件分片上传、大文件断点续传。&lt;/p&gt;
    
    </summary>
    
      <category term="zuopengfei" scheme="http://xgfe.github.io/categories/zuopengfei/"/>
    
    
      <category term="koa" scheme="http://xgfe.github.io/tags/koa/"/>
    
      <category term="http" scheme="http://xgfe.github.io/tags/http/"/>
    
      <category term="koa-body" scheme="http://xgfe.github.io/tags/koa-body/"/>
    
      <category term="文件上传" scheme="http://xgfe.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>代理工具whistle的基本使用</title>
    <link href="http://xgfe.github.io/2019/09/17/qiuwei/whistle/"/>
    <id>http://xgfe.github.io/2019/09/17/qiuwei/whistle/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-12-13T08:59:38.689Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍代理工具whistle的基本功能以及实际应用。<br><a id="more"></a></p><h1 id="whistle是干嘛用的"><a href="#whistle是干嘛用的" class="headerlink" title="whistle是干嘛用的"></a>whistle是干嘛用的</h1><p>whistle(读音[ˈwɪsəl]，拼音[wēisǒu])基于Node实现的跨平台web调试代理工具，类似的工具有Fiddler、Charles，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用。</p><h1 id="有了charles为什么还用whistle"><a href="#有了charles为什么还用whistle" class="headerlink" title="有了charles为什么还用whistle"></a>有了charles为什么还用whistle</h1><ul><li>whistle是开源的，安装也更简单。（安装：npm i -g whistle   启动：w2 start   操作：浏览器访问127.0.0.0:8899）</li><li>官方文档清晰、全面。 （<a href="http://wproxy.org/whistle/" target="_blank" rel="noopener">文档链接</a>）</li><li>代码式操作。(请求转发、编辑等都是以代码行的形式进行，相比较于charles这种图形化操作，效率更高，更灵活)</li><li>默认集成vconsole、weinre等调试功能。（例如vconsole这种客户端控制台日志打印功能都默认集成，而且是在PC的控制台显示客户端日志）</li></ul><h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><p><a href="http://wproxy.org/whistle/install.html" target="_blank" rel="noopener">安装启动、代理配置移步官方文档</a></p><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="hosts配置"><a href="#hosts配置" class="headerlink" title="hosts配置"></a>hosts配置</h2><p>  提供类似switchhosts的修改域名解析的功能，并且可以做到单独对浏览器生效或本机全局生效，无需刷新dns缓存。<br>  更强大的是他支持同一个域名下的不同链接解析到不同的ip、支持正则匹配、支持端口转发等等。</p><pre><code>以下规则在whistle rules窗口下添加：127.0.0.1 a.meituan.com             # a.meituan.com下的请求代理到本机192.168.191.1 b.meituan.com/list/   # b.meituan.com下list路径的请求代理到192.168.191.1192.168.191.2 b.meituan.com         # b.meituan.com下的其余请求代理到192.168.191.2d.metuan.com e.meituan.com          # d.metuan.com的请求转发到e.meituan.com127.0.0.1:8080 f.meituan.comn       # f.meituan.comn的请求转发到本地8080端口192.168.191.3 /./                   # 除以上规则匹配到的请求以外，其他请求均代理到192.168.191.3</code></pre><p>  注：更高级别的规则放在前面 否则不会执行 如b.meituan.com/list/需放在b.meituan.com前面。</p><h2 id="https转http"><a href="#https转http" class="headerlink" title="https转http"></a>https转http</h2><p>  很多客户端强制要求页面是https，这样连带着所有请求也都是https了，本地调试不方便，可以把https转为http。</p><ol><li>解析https请求 请看<a href="http://wproxy.org/whistle/webui/https.html" target="_blank" rel="noopener">官方文档</a>。</li><li>按照以上操作执行后，whistle可以解析https了，然后只需在rules窗口下添加以下规则，则请求便由https转为http了。</li></ol><h2 id="客户端日志-错误打印"><a href="#客户端日志-错误打印" class="headerlink" title="客户端日志/错误打印"></a>客户端日志/错误打印</h2><p>  我们一般本地调试时，想看H5页面运行在客户端的日志或者报错，只能用charles代理，然后alert或者程序中加vconsole在手机上看。<br>  有了whistle这两步就可以合在一起，并且在电脑上看日志了。</p><p>  (1）在whistle rules窗口下添加以下规则:</p><pre><code>127.0.0.1 a.meituan.com             # a.meituan.com下的请求代理到本机a.meituan.com log://test            # a.meituan.com下的consolelog打印  ://后面的名字随便起 这只是一个标识</code></pre><p>  (2）在network窗口右侧的tools下的Console窗口可查看客户端的console.log打印以及异常报错。<br><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic1.png"></p><p>  注：whistle也整合了weinre远程调试的功能，可以直接看<a href="http://wproxy.org/whistle/webui/weinre.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="延迟、限速"><a href="#延迟、限速" class="headerlink" title="延迟、限速"></a>延迟、限速</h2><p>  这两个功能做功能测试以及性能优化时经常用。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/js/ resSpeed://1000     # 限速 kb/s/./ resDelay://3000                   # 延迟 3秒</code></pre><h2 id="修改响应内容"><a href="#修改响应内容" class="headerlink" title="修改响应内容"></a>修改响应内容</h2><p>  在mock数据或者本地调试时，我们经常要将线上文件替换为本地文件，或者对接口的响应内容做修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/home/ file:///Users/xxx/Desktop/test.html             #替换页面a.meituan.com/unify.min.js file:///Users/xxx/Desktop/test.js        #替换jsa.meituan.com/api/list resBody://{myRes}                            #替换响应内容 myRes为自定义变量 可以紧跟规则在下面用```定义 也可在Values窗口内定义`` ` myRes    {&quot;code&quot;:200,&quot;data&quot;:{&quot;list&quot;:[]},&quot;message&quot;:&quot;请求成功&quot;,&quot;status&quot;:1}`` `</code></pre><p>  注：因为不能转义 所以把```中间加了个空格 实际操作时应该是连续的。</p><h2 id="修改响应头"><a href="#修改响应头" class="headerlink" title="修改响应头"></a>修改响应头</h2><p>  有时我们需要修改响应头，比如cors跨域头。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list resHeaders://{myRes1}`` ` myRes1    Access-Control-Allow-Origin: https://a.meituan.com`` `</code></pre><p>  注：因为不能转义 所以把```中间加了个空格 实际操作时应该是连续的。</p><h2 id="修改请求参数"><a href="#修改请求参数" class="headerlink" title="修改请求参数"></a>修改请求参数</h2><p>  测试环境有时我们没法通过代码修改入参，我们可以通过代理修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list reqMerge://(name=test&amp;brand=nokia)</code></pre><h2 id="修改请求头"><a href="#修改请求头" class="headerlink" title="修改请求头"></a>修改请求头</h2><p>  referer、origin、ua这些请求头我们都可以修改。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list reqHeaders://{myReq}`` ` myReq    referer: b.meituan.com    origin: http://b.meituan.com`` `</code></pre><p>  注：因为不能转义 所以把```中间加了个空格 实际操作时应该是连续的。    </p><h2 id="通过js代码动态获取请求-响应内容-编辑请求-响应"><a href="#通过js代码动态获取请求-响应内容-编辑请求-响应" class="headerlink" title="通过js代码动态获取请求/响应内容 编辑请求/响应"></a>通过js代码动态获取请求/响应内容 编辑请求/响应</h2><p>  有很多情况我们的响应不是固定的，而是根据请求参数动态变化的，whistle同样可以帮我们做到。<br>  whistle内置了一些全局变量，我们可以获取链接参数，动态生成一条rule，然后push到whislte规则中。<br>  这是最灵活，最全面的，理论上我们掌握这一种就可以实现上述所有功能。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com/api/list resScript://{myScript}`` ` myScript    const queryMap = parseQuery(parseUrl(url).query);    const res = {        &quot;code&quot;: queryMap.isLogin ? 200 : 400,        &quot;data&quot;: {}    };    console.log(res);    values.myScript_res = res;    rules.push(`${url} resBody://{myScript_res}}`);`` `</code></pre><p>  注：因为不能转义 所以把```中间加了个空格 实际操作时应该是连续的。<br>  注：上述js的控制台打印可在（network - tools - Server）看到，这也就让我们拥有了调试能力。<br><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic2.png" width="800px"></p><h2 id="页面注入js-css"><a href="#页面注入js-css" class="headerlink" title="页面注入js/css"></a>页面注入js/css</h2><p>  直接往线上注入我们本地的js/css。</p><pre><code>在whistle rules窗口下添加以下规则：a.meituan.com js:///Users/xxx/Desktop/test.js         #追加jsa.meituan.com css:///Users/xxx/Desktop/test.css       #追加css</code></pre><h1 id="其他小点"><a href="#其他小点" class="headerlink" title="其他小点"></a>其他小点</h1><h2 id="本地ip查看"><a href="#本地ip查看" class="headerlink" title="本地ip查看"></a>本地ip查看</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic3.png"></p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic4.png"></p><h2 id="Rules窗口、Values窗口"><a href="#Rules窗口、Values窗口" class="headerlink" title="Rules窗口、Values窗口"></a>Rules窗口、Values窗口</h2><p><img src="https://raw.githubusercontent.com/workforqw/imgs/master/pic5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍代理工具whistle的基本功能以及实际应用。&lt;br&gt;
    
    </summary>
    
      <category term="qiuwei" scheme="http://xgfe.github.io/categories/qiuwei/"/>
    
    
      <category term="代理" scheme="http://xgfe.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="charles" scheme="http://xgfe.github.io/tags/charles/"/>
    
  </entry>
  
  <entry>
    <title>JS异步语法</title>
    <link href="http://xgfe.github.io/2019/08/07/linxiaowen/Javascript-asynchronous/"/>
    <id>http://xgfe.github.io/2019/08/07/linxiaowen/Javascript-asynchronous/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-12-13T08:59:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对Javascript中异步编程的几种语法以及使用方式进行了介绍。</p><a id="more"></a><h2 id="前言-同步与异步"><a href="#前言-同步与异步" class="headerlink" title="前言 同步与异步"></a>前言 同步与异步</h2><p>在JS中，通常代码按顺序从上到下同步执行，但某些特殊场景/操作下需要以异步的方式执行，即将代码划分为至少两部分，先执行一部分代码，在进行耗时操作时将主线程的执行权交出，执行其他代码，待耗时任务完成后以一定规则触发使得另一部分代码被继续执行。</p><p>JS中常见的异步执行场景：网络请求（Ajax等）、定时器（SetTimeout等）、IO操作（readFile等）…</p><p>对于JS的这些异步场景，有两个重点：</p><p>1.得知异步任务何时结束，以便进行后续操作；<br>2.处理多个异步任务按顺序执行/并发执行的场景；</p><p>在处理JS异步场景方法的衍化过程当中，逐步出现了几种方式：</p><ul><li>回调函数</li><li>事件监听</li><li>发布订阅</li><li>Promise</li><li>Generator/yield</li><li>Async/await</li></ul><hr><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>JS中最常见的处理异步问题的方法，将任务结束时要做的事（或者说必须拿到异步任务的结果才能进行的操作）包装成函数作为参数传递给异步操作，待异步操作结束后执行函数，称之为“回调”函数。如SetTimeout函数就接受一个函数参数作为回调函数，在指定延迟时间后执行该回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步操作setTimeout示例</span><br><span class="line">setTimeout(function()&#123;//延迟100ms后执行“代码块”；延迟即视为异步操作，代码块则是异步操作结束后的“回调函数”；</span><br><span class="line">  //代码块</span><br><span class="line">&#125;，100);</span><br></pre></td></tr></table></figure><p>回调函数的异步方法简单易理解，但不利于代码维护，尤其在多个异步任务继发执行使得回调函数嵌套的情况下，代码耦合度高不利于代码的阅读和维护，且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。</p><p>虽然回调函数这种方式问题很多，但是不可否认的是在ES6之前，他就是处理异步问题普遍较好的方式，而且后面很多方式仍然基于回调函数。</p><hr><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>JS中关于DOM操作的一系列监听事件也属于异步方法，如监听各种元素的onclick、onload等方法。只有当监听元素对应的事件被发生时对应的代码才会被执行。</p><p>回调函数与事件监听的区别：</p><ul><li>回调函数多是一对一的关系，事件监听可以是多对一。</li><li>运行异步函数，在一个不确定的时间段之后运行回调函数；不确定何时触发事件，但是触发事件同步响应事件的回调。</li><li>事件监听相对于回调函数，可配置的监听（可增可减）关系减少了耦合性。</li></ul><p>不过事件监听也存在问题：</p><ul><li>多对多的监听组成了一个复杂的事件网络，单个节点通常监听了多个事件，维护成本很大。</li><li>多个异步事件仍然还是回调的形式。</li></ul><hr><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>和事件监听非常类似的是发布/订阅者模式，在事件监听的基础上，假定存在一个 “ 消息中心 “，某个任务执行完成，就向消息中心 “ 发布 “（publish）一个消息，其他任务可以向消息中心 “ 订阅 “（subscribe）这个消息，从而知道什么时候自己可以开始执行。（直观产品就是微信的公众号模式）</p><p>发布订阅模式在事件监听的基础上增加消息中心的概念，使得多个监听事件的运转流程和消息传递更加有序。但与事件监听相同的是发布订阅者模式也是“事件驱动”型，无法预知到事件何时发生/发布。</p><hr><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise的三种状态：pending（进行中），fulfilled（已成功），rejected（已失败），其状态只能从进行中到成功或者是失败，不可逆。而当Promise成功/失败/发生错误时可以调用不同的回调函数来处理不同的情况。当状态定型后称为resolved(已定型)，为了方便表述，后续所有resolved统一只指fulfilled状态，不包含rejected状态。基本使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve, reject) =&gt; &#123;//传入resolve和reject两个函数(自带，名字也随意)来改变Promise的状态</span><br><span class="line">  //一顿操作</span><br><span class="line">  if(/*异步操作成功*/)&#123;</span><br><span class="line">  resolve(&apos;success&apos;); //调用resolve函数使Promise状态从pengding=&gt;fulfilled,reject则相反；</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   reject(&apos;reject&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  //还可以操作，promise状态变化后仍会继续执行代码，但原则上不应该，因此可以用return resolve();的方式避免该情况；</span><br><span class="line">&#125;);</span><br><span class="line">promise1.then(//then方法是在Promise结束(成功/失败)后进行调用，可以传入两个回调函数作为参数分别对应成功/失败的状态；</span><br><span class="line">  value =&gt; &#123;//回调函数的参数(此为value)则是Promise状态转换时传递出的信息，resolve(&quot;success&quot;)中的“success”；</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  reason =&gt; &#123;//then方法的第二个回调函数为可选；</span><br><span class="line">    console.log(reason);//reject</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="当resolve-a-传递的参数a也是一个Promise时"><a href="#当resolve-a-传递的参数a也是一个Promise时" class="headerlink" title="当resolve(a)传递的参数a也是一个Promise时"></a>当resolve(a)传递的参数a也是一个Promise时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail，3秒后</span><br></pre></td></tr></table></figure><p>由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p><h3 id="Promise的链式调用-then"><a href="#Promise的链式调用-then" class="headerlink" title="Promise的链式调用(then)"></a>Promise的链式调用(then)</h3><p>then函数定义在原型对象Promise.prototype.then()上，then函数可以链式调用，因为每次调用返回的都是一个新的 Promise 实例；promise1.then().then().then()…</p><ul><li>在 then 中使用了 return，那么 return 的值会被 Promise.resolve() 包装，传递给下一次 then 中的成功回调 ；</li><li>then 中可以不传递参数，如果不传递（then().then(…)？）会透到下一个 then 中 ；</li><li>如果 then 中出现异常, 会走下一个 then 的失败回调/被最近的catch捕获；</li></ul><h3 id="Promise的异常捕获（catch）"><a href="#Promise的异常捕获（catch）" class="headerlink" title="Promise的异常捕获（catch）"></a>Promise的异常捕获（catch）</h3><p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。当异步操作抛出错误时状态会变为rejected，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=new Promise(function(res,rej)&#123;//当Promise内抛出错误，且then函数有rejected的回调函数以及存在catch函数</span><br><span class="line">throw new Error(&quot;cuowu&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,function(val)&#123;</span><br><span class="line">console.log(&quot;rej&quot;+val);</span><br><span class="line">  throw new Error(&quot;reject error&quot;);//在rejected回调函数中抛出错误会被catch捕获</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(e)&#123;</span><br><span class="line">console.log(&quot;err&quot;+e);</span><br><span class="line">&#125;);</span><br><span class="line">//rejError: cuowu//即会直接被rejected回调函数捕获而不被catch捕获</span><br><span class="line">//errError: reject error</span><br></pre></td></tr></table></figure><ol><li><p>Promise 在resolve语句后面，再抛出错误不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p></li><li><p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法(还可以捕获then中的错误)。</p></li><li><p>catch方法返回的还是一个 Promise 对象，状态变为resolve，因此后面还可以接着调用then方法。</p></li><li><p>catch不会捕获其之后的错误（catch().then().then(),后面两个then函数中错误与catch无关）。</p></li><li><p>catch中报错与then一样向下传递，若有catch则能被捕获。</p></li></ol><p>若没有用catch方法捕获错误，Promise 对象抛出的错误不会传递到外层代码，即运行出错仍然会报错，但不会退出进程终止运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    resolve(x + 2);// 下面一行会报错，因为x没有声明</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  console.log(&apos;everything is great&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">// Uncaught (in promise) ReferenceError: x is not defined</span><br><span class="line">// 123    //即使报错但2秒后仍然输出123；</span><br></pre></td></tr></table></figure></p><p>Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=new Promise(function(res,rej)&#123;</span><br><span class="line">rej(&quot;rej&quot;);</span><br><span class="line">  //res(&quot;ok&quot;);</span><br><span class="line">  setTimeout(()=&gt;&#123;throw new Error(&quot;cuowu&quot;)&#125;,0);</span><br><span class="line">&#125;)</span><br><span class="line">.then(val=&gt;console.log(&quot;res:&quot;+val),function(val)&#123;</span><br><span class="line">console.log(&quot;rej&quot;+val);&#125;)</span><br><span class="line">.catch(function(e)&#123;console.log(&quot;err&quot;+e);&#125;);</span><br><span class="line">//rejrej</span><br><span class="line">//Uncaught Error: cuowu//无论用rej还是res,Promise里设置延时报错都不会被catch捕获（Promise已经结束了）</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all/Promise.race"></a>Promise.all/Promise.race</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。（and的判定方式）</p><p>Promise.all一般使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br><span class="line">//p的状态由p1/p2/p3决定，p1&amp;&amp;p2&amp;&amp;p3的关系，均resolve才resolve,任意一个rejected就rejected.</span><br><span class="line">//传值：p状态resolve时，p1/p2/p3的返回值组成数组传给p的回调函数，</span><br><span class="line">//p状态rejected时，第一个被rejected的实例返回值传给p的回调函数。</span><br></pre></td></tr></table></figure></p><ul><li>接受一个数组参数（非数组也可，必须有Iterator接口），且返回的每个成员都是Promise实例。</li><li>若参数成员不是Promise实例会调用Promise.resolve方法将其转为Promise实例，再进一步处理。</li><li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法，会被自己的catch方法捕获，而后返回的实例状态变成resolve，使得Promise.all()的整体状态可能变成resolve。</li></ul><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。（or的判定方式）</p><ul><li>只要参数中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</li><li>若参数成员不是Promise实例会调用Promise.resolve方法将其转为Promise实例（与all相同）。</li></ul><h3 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve/Promise.reject"></a>Promise.resolve/Promise.reject</h3><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>Promise.resolve方法可以将现有对象转为Promise对象。根据resolve()方法参数的不同有4种情况：</p><ol><li>参数是Promise对象，则不做任何修改、原封不动返回实例。</li><li>参数是一个thenable对象（即对象具有then方法）<ul><li>thenable被转为Promise实例后会直接调用then方法。</li><li>thenable的then函数中，使用rej和res可以改变实例状态,return不会被当成res对待，error会被当成rej对待。</li><li>thenable的then函数中，不使用res和rej则状态为pending，p1将不会执行then和catch。</li></ul></li><li>参数不是具有then方法的对象，或根本就不是对象<ul><li>返回一个新的Promise对象，状态为resolved，同时可以传值给回调函数(Promise.resolve(“abc”))。</li></ul></li><li>不带任何参数(Promise.resolve())<ul><li>直接返回Promise对象，状态为resolved。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let thenable = &#123;//thenable被转为Promise实例后会直接调用then方法。</span><br><span class="line">  then: function(res, rej) &#123;</span><br><span class="line">    rej(42);//res(3);//使用rej和res可以改变实例状态,return不会被当成res对待，error会被当成rej对待。</span><br><span class="line">    //console.log(1);//不使用res和rej则状态为pending，p1将不会执行then和catch。</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let p1 = Promise.resolve(thenable);</span><br><span class="line">p1.then(function(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;).catch(val=&gt;console.log(val));//thenable中then函数rejected/error会被捕获</span><br></pre></td></tr></table></figure><p>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时（宏任务与微任务）。</p><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>Promise.reject方法与Promise.resolve类似，返回一个新的Promise实例，只是状态为rejected。</p><p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p><p>Promise.reject(thenable)参数的thenable函数reject后，其信息不会被后续catch捕获，而是thenable对象被捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(&apos;出错了&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.reject(thenable)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">  console.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line">//true  //catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li>finally用于指定不管Promise对象最后状态如何都会执行的操作，ES2018引入。</li><li>finally不接受任何参数，因此也无法得知Promise的状态是fulfilled还是rejected，这表明finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li><li>finally的回调函数中写不写return都不影响finally函数将前面Promise的状态和值（PromiseStatus和PromiseValue）往后传递。</li><li>finally函数执行后返回的还是一个Promise。</li></ul><p>finally特性（不接受参数+传递状态和值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(2).finally((val) =&gt; &#123;console.log(val)&#125;);</span><br><span class="line">//undefined   //finally中参数val无效</span><br><span class="line">//[[PromiseStatus]]: &quot;resolved&quot;  [[PromiseValue]]: 2    //可以传递Promise的状态和值</span><br><span class="line">Promise.resolve(2).finally((val=3) =&gt; &#123;console.log(val+1)&#125;) //4   //默认参数有效但与Promise无关</span><br></pre></td></tr></table></figure></p><h3 id="Promise-try"><a href="#Promise-try" class="headerlink" title="*Promise.try()"></a>*Promise.try()</h3><p>用于处理不区分/确认是同步or异步操作的情况，可以做到若try(a)的a是同步函数则同步执行，是异步函数则异步执行。浏览器还未原生支持，romise 库Bluebird、Q和when提供了该方法。自己实现该功能则是使用立即执行函数+async/promise：</p><p>async函数实现-同步操作同步执行，异步操作异步执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(async () =&gt; f())()//f若是同步则会立即得到同步结果（后续有then函数则进入then函数），</span><br><span class="line">.then(...)          //若异步则可以用then和catch进行下一步操作。</span><br><span class="line">.catch(...);      //async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure></p><p>new Promise实现-同步操作同步执行，异步操作异步执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(() =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f());  //使用resolve时用”f()“立即执行f函数。</span><br><span class="line">))();</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure></p><p>Promise.try可以更好地管理异常，不论是同步操作or异步操作时抛出的错误。</p><ol><li>在构造 Promise 的时候，构造函数内部的代码是立即执行的；</li><li>Promise一旦运行，不能终止。</li><li>利用Promise处理一个异步的后续处理十分简便，但是处理多个请求按顺序执行仍然很不方便。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><hr><h2 id="Generator-yield"><a href="#Generator-yield" class="headerlink" title="Generator/yield"></a>Generator/yield</h2><p>ES6中提供的一种异步编程解决方案，中文称为生成器，生成器可以在执行的时候暂停，交出函数执行权给其他函数，然后其他函数可以在需要的时候让该函数再次运行。</p><ol><li>function和函数名之间加星号*，函数内部用yield划分不同操作or状态来暂停函数，函数外部用next方法重新启动。</li><li>yield 表达式本身没有返回值，返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</li></ol><p>generator函数使用基本方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;  //加星号（无规范，在function与函数名之间即可，空格在哪边或者没有空格均可）</span><br><span class="line">  console.log(&quot;begin&quot;);</span><br><span class="line">  let y = 2 * (yield (x + 1));  //yield表达式作为暂停标记</span><br><span class="line">  let z = yield (y / 3);</span><br><span class="line">  return (x + y + z); //若此处return换成yield，则next执行至此返回的done=false，需再执行一次next，done=true；</span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5);  //首次执行函数不会执行函数内部（begin不会被打印），只传递参数，返回的是一个指向内部状态的指针对象（遍历器）。</span><br><span class="line">console.log(it.next());   //next执行后函数内部继续执行，停在下一个yield处，返回的对象包含value和done两个属性；</span><br><span class="line">// =&gt; &#123;value: 6, done: false&#125; //value为yield后面的表达式的值，done表示遍历是否结束；</span><br><span class="line">console.log(it.next(12))  //next(12)函数可以传入参数，会传到继续执行的yield处代替上一次的yield表达式；</span><br><span class="line">// =&gt; &#123;value: 8, done: false&#125; //12代替(x+1)因此y=24,本次next停在y/3处所以next.value=8</span><br><span class="line">console.log(it.next(13))  //13传入即z=13</span><br><span class="line">// =&gt; &#123;value: 42, done: true&#125;   //next.value=5+24+13=42,因为本次next执行至return所以done=true；</span><br></pre></td></tr></table></figure></p><p>当一个对象的属性是 Generator 函数，可以简写成 ：* 属性名(){}的形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  * myGeneratorMethod() &#123; ···&#125;&#125;; //属性前加*,表明属性是个generator函数。</span><br><span class="line">let obj = &#123; myGeneratorMethod : function* () &#123;...&#125;&#125;;  //两种写法等价</span><br></pre></td></tr></table></figure></p><h3 id="yield与yield"><a href="#yield与yield" class="headerlink" title="yield与yield*"></a>yield与yield*</h3><h4 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h4><ul><li>yield关键词作为每次函数执行next方法的分界点，其后面跟着的表达式会等到调用了next方法并执行到此处时才会进行计算。</li><li>当generator函数里没有使用yield表达式时，此时函数变成一个单纯的暂缓执行函数。（f.()不会执行内部语句，f.().next();才会执行）</li><li>yield关键词若不在generator函数里会报错（即函数是否加*)。</li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>用来在一个generator函数里执行另一个generator函数。当yield后面跟着的对象是另一个generator函数时，使用yield*可以进入其内部继续遍历状态。</p><p>yield*使用对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* inner() &#123;</span><br><span class="line">  yield &apos;hello!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function* outer() &#123;</span><br><span class="line">  yield &apos;open&apos;;</span><br><span class="line">  yield inner();</span><br><span class="line">  yield* inner();</span><br><span class="line">  yield &apos;close&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var gen = outer();</span><br><span class="line">gen.next().value // &quot;open&quot;</span><br><span class="line">gen.next().value // 返回一个遍历器对象。（不会进入内部）</span><br><span class="line">gen.next().value // &quot;hello!&quot;    //该yield带*表明后续表达式也是generator函数，会进入内部遍历状态。</span><br><span class="line">gen.next().value // &quot;close&quot;</span><br></pre></td></tr></table></figure></p><ul><li>yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for…of循环。</li><li>有return语句时，则需要用let value = yield* iterator的形式获取return语句的值（done=true时会直接略过value跳出函数继续寻找yield，但整个函数返回值为return后的值）。</li><li>任何数据结构只要有 Iterator 接口，就可以被yield*遍历（数组，字符串等等）。</li></ul><p>yield*后跟着一个带有return语句的generator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* genFuncWithReturn() &#123;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">  return &apos;The result&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function* logReturned(genObj) &#123;</span><br><span class="line">  let result = yield* genObj;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">[...logReturned(genFuncWithReturn())]</span><br><span class="line">// The result</span><br><span class="line">// 值为 [ &apos;a&apos;, &apos;b&apos; ]</span><br></pre></td></tr></table></figure></p><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><ul><li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li><li>由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。</li></ul><p>如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><p>包装generator函数，首次next()在内部执行，外部从第二次开始（对于外部而言为第一次）即可传入参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function wrapper(generatorFunction) &#123;</span><br><span class="line">  return function (...args) &#123; //return第一个函数：包涵generator函数并执行一次的next.</span><br><span class="line">    let generatorObject = generatorFunction(...args);</span><br><span class="line">    console.log(args[0]);</span><br><span class="line">    generatorObject.next();</span><br><span class="line">    return generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const wrapped = wrapper(function* () &#123;</span><br><span class="line">  console.log(`First input: $&#123;yield&#125;`);</span><br><span class="line">  return &apos;DONE&apos;;</span><br><span class="line">&#125;);</span><br><span class="line">wrapped(1).next(&apos;hello!&apos;);  //1   // First input: hello!</span><br></pre></td></tr></table></figure></p><h3 id="generator函数遍历–针对同步操作"><a href="#generator函数遍历–针对同步操作" class="headerlink" title="generator函数遍历–针对同步操作"></a>generator函数遍历–针对同步操作</h3><p>（iterator接口：for…of、…扩展运算符、Array.from）</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p><p>generator函数执行后，返回的遍历器对象，其本身也具有Symbol.iterator属性，执行后返回自身。</p><p>gen() === gen()[Symbol.iterator]()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line">let g = gen();</span><br><span class="line">g[Symbol.iterator]() === g   //// true</span><br></pre></td></tr></table></figure></p><p>generator函数赋值给对象的Symbol.iterator后，对象就可以被”…“扩展运算符遍历。</p><p>generator函数赋值给Symbol.iterator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p><p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以下面代码的return语句返回的7，不包括在for…of循环之中。</p><p>generator函数用for循环自动执行(方便地取出嵌套数组的内容)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line">let flat = function* (a) &#123;</span><br><span class="line">  let length = a.length;</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    let item = a[i];</span><br><span class="line">    if (typeof item !== &apos;number&apos;) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 7； //for...of循环不会返回7，因为此时done=true。</span><br><span class="line">&#125;;</span><br><span class="line">for (let f of flat(arr)) &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure></p><p>原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 generator 函数为它加上这个接口，就可以用了。可以把对象作为参数传递给generator函数，然后使用for…of  gen(object)方式来遍历对象属性。也可以直接把写好的generator函数赋值给对象的Symbol.iterator属性，然后再遍历（后者更直观）。</p><p>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><p>扩展运算符，Array.from，解构赋值，for…of循环分别遍历generator函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  return 3;</span><br><span class="line">&#125;</span><br><span class="line">[...numbers()]        // 扩展运算符  // [1, 2]</span><br><span class="line">Array.from(numbers());    // Array.from 方法  // [1, 2]</span><br><span class="line">let [x, y] = numbers();   // 解构赋值   //x=&gt; 1,y =&gt; 2</span><br><span class="line">for (let n of numbers()) &#123;    // for...of 循环</span><br><span class="line">  console.log(n);         // 1  // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="generator函数throw、return方法"><a href="#generator函数throw、return方法" class="headerlink" title="generator函数throw、return方法"></a>generator函数throw、return方法</h3><h4 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h4><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误(gen.throw())，然后在 Generator 函数体内捕获(try…catch)。</p><p>gen.throw()示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var g = function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    yield 2.5;    //2.5会成为throw的返回值，若没有执行throw方法此yield会被略过。</span><br><span class="line">    yield 2.7;    //2.7因为throw只会被捕获一次，因此会被throw紧接着的next取得，若throw紧接着还是throw则略过。</span><br><span class="line">    console.log(&apos;内部捕获&apos;, e);</span><br><span class="line">  &#125;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">var i = g();</span><br><span class="line">i.next();   //value:1</span><br><span class="line">try &#123;</span><br><span class="line">  i.throw(&apos;a&apos;);   //value=2.5; throw除了抛出错误的语义外同时兼顾执行一次yield（catch内部的或是后续的，try里的略过）。</span><br><span class="line">  i.throw(&apos;b&apos;);   //第二次执行throw函数由于内部已经执行过catch了，不会再捕获一次。</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&apos;外部捕获&apos;, e);       // 内部捕获 a   // 外部捕获 b</span><br><span class="line">&#125;</span><br><span class="line">i.next();   //value:undefined,done:true</span><br><span class="line">i.next();   //由于第二次throw被外部捕获，对内部而言即出错终止了，因此后续都是undefined。</span><br><span class="line">//若没有第二次throw，则后两次next函数的value为2.7和3（2被第一次throw方法跳过了）。</span><br></pre></td></tr></table></figure></p><ul><li>generator函数的throw方法与全局throw方法不同，后者只能被函数外的catch捕获（即在generator函数内部用全局throw抛出错误）。</li><li>如果 generator 函数内部没有部署try…catch代码块，那么generator的throw方法抛出的错误，将被外部try…catch代码块捕获。generator函数则相当于出错终止继续执行外部代码，使用next方法会返回{value:undefined, done=true}。</li><li>如果 generator 函数内部和外部都没有部署try…catch代码，那么执行generator函数的throw方法程序将报错直接中断所有代码执行。</li><li>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法（这样才启动执行了内部代码）。</li><li>throw方法被generator内部try模块捕获进入catch会默认执行一次next，停在catch内部或后续代码中的yield处。</li><li>generator 函数体内抛出的错误，可以被函数体外的catch捕获。</li></ul><h4 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h4><p>generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 generator 函数。</p><p>gen.return()示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;   //当外部使用numbers.return()方法时，会等待finally执行完成后再执行return。</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers();</span><br><span class="line">g.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) // &#123; value: 4, done: false &#125;  //本次return因为内部有finally存在因此返回其内部的4。</span><br><span class="line">g.next() // &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 7, done: true &#125;  //finally模块内执行完成后的下一次next直接是当时return的效果。</span><br></pre></td></tr></table></figure></p><h4 id="next-throw-return-的共同点"><a href="#next-throw-return-的共同点" class="headerlink" title="next(),throw(),return()的共同点"></a>next(),throw(),return()的共同点</h4><p>next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。</p><ul><li>next()是将yield表达式替换成一个值。</li><li>throw()是将yield表达式替换成一个throw语句(需要被内部try模块catch，否则寻求外部try模块)。</li><li>return()是将yield表达式替换成一个return语句(函数终止效果，遇上finally需等待finally内部执行完毕再终止)。</li></ul><h3 id="generator函数的this"><a href="#generator函数的this" class="headerlink" title="generator函数的this"></a>generator函数的this</h3><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。但如果把generator函数当作普通的构造函数，并不会生效，因为其返回的总是遍历器对象，而不是this对象。</p><p>generator函数的this使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function* g() &#123; </span><br><span class="line">  this.a = 1; </span><br><span class="line">  yield this.b = 2;  </span><br><span class="line">  yield this.c = 3; </span><br><span class="line">&#125;</span><br><span class="line">g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;</span><br><span class="line">let obj = g();</span><br><span class="line">obj instanceof g // true    //obj是g的实例，继承了g.prototype</span><br><span class="line">obj.hello() // &apos;hi!&apos;</span><br><span class="line">obj.next();</span><br><span class="line">obj.a     //undefined   //obj拿不到this对象的属性。</span><br><span class="line">new g();  /// TypeError: g is not a constructor   //使用new来创建实例报错，g不是构造函数。</span><br><span class="line">​</span><br><span class="line">//generator函数用call方法绑定对象，指向函数内部的this对象。</span><br><span class="line">let o = &#123;&#125;;</span><br><span class="line">let gen = g.call(o);</span><br><span class="line">gen.next(); gen.next();   // value分别为2和3 与正常generator函数相同。</span><br><span class="line">console.log(&quot;a:&quot;+o.a+&quot; b:&quot;+o.b+&quot; c:&quot;+o.c);  // a:1 b:2 c:3  </span><br><span class="line">//obj对象成为了g函数的实例，但与g函数执行返回遍历器对象gen是分离的。</span><br><span class="line">​</span><br><span class="line">//将generator函数用call方法绑定自身prototype对象。</span><br><span class="line">let gg = g.call(g.prototype);</span><br><span class="line">gg.next();gg.next();  //value分别为2和3 与正常generator函数相同。</span><br><span class="line">console.log(&quot;a:&quot;+gg.a+&quot; b:&quot;+gg.b+&quot; c:&quot;+gg.c); // a:1 b:2 c:3</span><br><span class="line">​</span><br><span class="line">//将g改造成构造函数，就可以执行new命令</span><br><span class="line">function G()&#123;</span><br><span class="line">  return g.call(g.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="generator函数自动执行–针对异步操作（thunk、co）"><a href="#generator函数自动执行–针对异步操作（thunk、co）" class="headerlink" title="generator函数自动执行–针对异步操作（thunk、co）"></a>generator函数自动执行–针对异步操作（thunk、co）</h3><p>generator函数解决了使用Promise时多个异步操作顺序执行代码冗余、语义模糊的问题，在多个异步操作顺序执行的表示上非常清晰。</p><p>generator函数最大的问题是如何在函数外部用next重新启动函数，手动执行在多个异步操作嵌套时异常繁琐，因此有thunk函数、co库可以自动执行generator函数。而简易版实现就是配合Promise实现自动执行。</p><h4 id="thunk函数"><a href="#thunk函数" class="headerlink" title="thunk函数"></a>thunk函数</h4><p>thunk函数在JavaScript中是用于将多参数函数封装成只接受一个回调函数参数的单参数函数。</p><p>现有的thunkify模块就是实现这样的一个封装器。</p><p>thunkify模块使用示例及源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let thunkify = require(&apos;thunkify&apos;); //事先需要安装模块  npm install thunkify 。</span><br><span class="line">let f = thunkify(fn);   //封装方法：将需要封装的带有回调函数参数的方法传入thunkify即可。</span><br><span class="line">f(para1,para2...)(cb);  //使用方法：将回调函数作为第二次执行（第一次执行后返回函数）的参数，其余参数在第一次执行时传入。</span><br><span class="line">​</span><br><span class="line">//源码</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line">function thunkify(fn)&#123;</span><br><span class="line">  assert(&apos;function&apos; == typeof fn, &apos;function required&apos;); //判断fn是否为函数。</span><br><span class="line">​</span><br><span class="line">  return function()&#123;</span><br><span class="line">    var args = new Array(arguments.length); //根据返回的function执行时传入的参数个数创建数组。</span><br><span class="line">    var ctx = this;     //保留上下文环境this。</span><br><span class="line">​</span><br><span class="line">    for(var i = 0; i &lt; args.length; ++i) &#123;  //传入参数赋值给数组args。</span><br><span class="line">      args[i] = arguments[i];         </span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    return function(done)&#123;    //返回函数，参数为回调函数。</span><br><span class="line">      var called;             //标记，是否执行过回调函数。</span><br><span class="line">​</span><br><span class="line">      args.push(function()&#123;   //将回调函数封装推入args参数数组，作为最后一个参数。</span><br><span class="line">        if (called) return;   //封装回调函数主要是判断是否已执行过回调函数，执行过则直接return，推入args的相当于一个空函数。</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);  </span><br><span class="line">      &#125;);</span><br><span class="line">​</span><br><span class="line">      try &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>thunk函数简单来说就是将带有回调函数的方法的执行方式从f(a, b, c, callback)包装成f(a, b, c)(callback)。<br>thunk函数的作用本身并不显著，关键在于和generator函数结合在一起，使generator函数可以自动执行。</p><p>thunk函数与generator函数结合，自动执行（针对异步操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//针对同步操作的generator函数自动执行方法有几种，核心都是借助generator函数执行后返回的是一个遍历器，但这仅仅适合同步操作。</span><br><span class="line">//thunk函数自动执行generator函数的核心点在于用递归的方式在回调函数中使用next重新启动generator函数。</span><br><span class="line">var fs = require(&apos;fs&apos;);var thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">var readFileThunk = thunkify(fs.readFile);//将文件读取函数封装为thunk函数。</span><br><span class="line">​</span><br><span class="line">//generator函数示例，内部包含两次文件读取操作。</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    console.log(&quot;进入generator&quot;);</span><br><span class="line">      //当run函数第二次执行gen.next(data)时，r1=data取到文件读取结果。</span><br><span class="line">      //value= readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;)，执行后返回thunk函数接收回调函数作为参数。</span><br><span class="line">    var r1 = yield readFileThunk(&apos;test.txt&apos;, &apos;utf8&apos;);//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r1);    </span><br><span class="line">    var r2 = yield readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;);//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r2);</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">//配合thunk递归调用自动执行generator函数</span><br><span class="line">function thunkGenerator(f)&#123;</span><br><span class="line">    let fn=f();     //执行一次generator函数，得到遍历器。</span><br><span class="line">    let time=0;     </span><br><span class="line">    function next(err,data)&#123;  //thunk回调函数，因此要求generator函数中yield后跟着的必须是一个thunk函数（接收回调函数参数）。</span><br><span class="line">        if(err)throw err;</span><br><span class="line">        console.log(&quot;第&quot;+(++time)+&quot;次进入自定义next函数&quot;);</span><br><span class="line">        let res=fn.next(data);  //执行next，定位到下一个yield，传入data使gen函数拿到文件读取结果。</span><br><span class="line">        if (res.done) return;  //若done=true表明generator函数执行完毕，直接返回。</span><br><span class="line">        res.value(next);      //result.value是一个接收回调函数作为参数的thunk函数，next作为回调函数传入，当文件读取成功后执行。</span><br><span class="line">                              //此处真正执行读取文件操作，待读取成功后执行回调函数next。</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">thunkGenerator(gen);//用thunkGenerator函数自动执行gen函数。</span><br><span class="line">//第1次进入自定义next函数</span><br><span class="line">//进入generator</span><br><span class="line">//第2次进入自定义next函数</span><br><span class="line">//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//第3次进入自定义next函数</span><br><span class="line">//test2-When you look long into an abyss, the abyss looks into you.</span><br></pre></td></tr></table></figure></p><p>thunk函数跟在yield后面，在thunk的回调函数中执行next重新启动generator函数，递归方式遍历generator。</p><h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p>co模块是结合promise对象来使generator函数自动执行。co(gen)执行后返回一个promise对象，用then方法添加最后的回调函数。</p><p>co模块使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);var co = require(&quot;co&quot;);var readFileThunk = thunkify(fs.readFile);</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    console.log(&quot;进入generator&quot;);</span><br><span class="line">    var r1 = yield readFileThunk(&apos;test.txt&apos;, &apos;utf8&apos;);//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r1);</span><br><span class="line">    var r2 = yield readFileThunk(&apos;test2.txt&apos;, &apos;utf8&apos;);//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">    console.log(r2);</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">//使用co函数库自动执行generator函数</span><br><span class="line">//co(gen);co函数返回的事一个promise对象，可以用then添加回调函数；</span><br><span class="line">co(gen).then(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;generator函数执行完毕。&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">//进入generator</span><br><span class="line">//test1-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//test2-When you look long into an abyss, the abyss looks into you.</span><br><span class="line">//generator函数执行完毕。</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>co模块源码中，自动执行generator函数的next函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function next(ret) &#123;</span><br><span class="line">  if (ret.done) return resolve(ret.value); //判断generator函数是否执行完毕。</span><br><span class="line">  var value = toPromise.call(ctx, ret.value); //将每一步返回的value都转为promise对象。</span><br><span class="line">  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);  //用then方法传入回调函数onFulfilled和onRejected，在两个函数内部继续调用next函数。</span><br><span class="line">  return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</span><br><span class="line">     + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));  //参数不符合要求（函数、promise、generator、array、object以外）的情况下直接rejected，终止执行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对比thunk函数与co模块中自动执行generator的next函数，核心逻辑都是在递归调用next，在回调函数里重启generator。</li><li>在自动执行generator上，相较于使用 thunk函数, 使用co模块能够接受的参数种类更多。</li><li>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。只需把并发的操作都放在数组或对象里面，跟在yield语句后面。</li></ul><hr><h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>async函数在generator函数的基础上进行了改进。</p><ul><li>语义清晰。async表示异步，await表示等待。</li><li>自动执行。async函数执行后，自动逐步执行内部各个语句，在await处等待操作完成后自动继续往下执行。</li><li>返回值为Promise对象。可以执行async函数后使用then函数进行下一步操作。</li></ul><p>async函数使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//函数声明</span><br><span class="line">async function f()&#123;&#125;</span><br><span class="line">//表达式</span><br><span class="line">let fn = async function ()&#123;&#125;;</span><br><span class="line">//对象的方法</span><br><span class="line">let obj = &#123;async f()&#123;&#125;&#125;;  obj.f().then();</span><br><span class="line">//Class的方法</span><br><span class="line">Class Test()&#123;</span><br><span class="line">  async fn()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = new Test();  test.fn().then();</span><br><span class="line">//箭头函数</span><br><span class="line">let func = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>基本使用方法：</p><ul><li>async函数内部用await暂停函数，用法类似yield，但await会在后面跟着的异步操作执行完成后自动继续执行。</li><li>await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回的Promise对象的状态取决于async函数内部，return  aa，则promise对象状态为resolved，aa作为then函数参数；throw 错误则promise对象状态为rejected，错误作为参数传入catch函数or then函数的第二个参数函数。</li><li>async函数绑定的then方法必须等到async内部的所有异步操作执行完才会被调用，即遇到有return or 错误抛出，若都没有的话，执行完最后的语句后async函数仍然返回一个状态为resolved的promise对象，但无任何数据传递。</li></ul><p>await后面跟着的命令：</p><ul><li>通常await后面跟着promise对象，返回该对象的结果，如果不是promise对象，就直接返回对应值，如 await 123，若想向async函数外传值则可以 return await 123，等同于return 123。</li><li>若await后面跟着的promise对象状态返回为rejected，则会中断整个async函数，并且返回rejected传递的参数（前面不需要return，因为等同于报错，会被外面的catch捕获），若rejected的promise对象被try…catch模块包含or promise对象本身带有catch方法，可以捕获到该rejected或者错误，进行一些处理，并继续执行async函数。</li><li>await后面若跟着一个thenable对象（定义了then方法的对象），await也会将其视为promise对象处理，执行其then方法。</li><li>多个异步操作可以同时触发，可以使用Promise.all/race 或用同步语句分别执行异步操作，后续使用await分别等待异步操作的返回结果。</li><li>await命令在async函数外会报错。</li><li>async函数在遇到await时暂停执行（转而执行await后面带的命令），此时会保留上下文环境。</li></ul><p>async函数是目前最集大成的JS异步操作方式，但回调函数、promise、generator同样适合许多应用场景。在实际环境中，根据不同的需求来选取不同的方法才是最合适的。 </p><hr><h2 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h2><p></p><p class="codepen" data-height="465" data-theme-id="0" data-default-tab="js,result" data-user="linxiaowen0127" data-slug-hash="BaBYMvN" style="height: 465px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="BaBYMvN"><br>  <span>See the Pen <a href="https://codepen.io/linxiaowen0127/pen/BaBYMvN/" target="_blank" rel="noopener"><br>  BaBYMvN</a> by linxiaowen0127 (<a href="https://codepen.io/linxiaowen0127" target="_blank" rel="noopener">@linxiaowen0127</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>异步方式</th><th>优点</th><th>缺点</th><th>备注</th></tr></thead><tbody><tr><td>1、回调函数</td><td>简单、逻辑上易理解、易实现</td><td>多个嵌套时：代码耦合高难以维护，程序结构混乱；流程难以追踪；错误捕获困难；</td><td>1-2个异步操作按顺序执行时，使用回调函数显得很便捷很简单，也不会造成难以维护的情况。多个异步操作时谢绝直接使用回调函数进行流程控制。回调函数是其他所有异步操作的基石。</td></tr><tr><td>2、事件监听</td><td>理解也较为容易；有效去耦合；多对多（事件与触发的函数），更灵活；</td><td>事件驱动型，流程不清晰；多对多也会造成事件的监听与触发混乱；</td><td>非常常用，最多的应该是点击事件触发。事件监听同样不建议用来控制大型/较复杂的流程运转。</td></tr><tr><td>3、发布订阅（事件监听升级版）</td><td>消息中心的存在让消息（事件）、订阅者（回调函数）更加清晰且更好掌控；</td><td>实现较为复杂（特别是包含取消订阅等功能时）则占用内存也多；大量使用时跟踪bug较为困难；</td><td>Vue也是基于发布-订阅（可能3+版会更改实现方式）。要实现较为完备的发布订阅相当复杂。少数异步操作不建议使用。感觉是系统级的而不是用来操控几个异步流程。</td></tr><tr><td>4、Promise</td><td>链式调用，流程清晰；</td><td>配套方法较完善；可串行可并行执行多个异步操作；一旦开始，无法取消；pending状态无法确认是刚开始还是即将结束；复杂情况时代码冗余、语义不清；</td><td>也非常常用，并且可以配合async达到自动按顺序执行效果。实际运用中例如HTTP请求会封装在promise里，更好的进行请求返回的下一步操作以及错误捕获处理。</td></tr><tr><td>5、Generator（生成遍历器对象）</td><td>将异步操作表达得像同步操作一样；语法简单，流程清晰，代码实现简洁；外部调用next可携带数据到内部；</td><td>手动迭代较麻烦（有thunk、co库可辅助）；yield语义不清；</td><td>generator返回遍历器对象的特性，让其拥有了进行异步操作流程控制以外的功能，例如可利用generator进行对象的属性遍历并进行一定的操作。甚至可以被视为一种数据结构。</td></tr><tr><td>6、Async（基于Promise，Gnerator升级版）</td><td>可自动执行流程（对于generator的next方法的改进）；语法简单，流程清晰，代码实现简洁；</td><td>多个异步操作若不存在依赖关系时，使用async降低性能；</td><td>await后面直接跟着回调函数不生效（例如await setTimout(500,()=&gt;{…})，并不会等延迟操作结束后再继续往下），需将其封装为Promise。</td></tr></tbody></table><p>本文主要JS的几种异步语法进行介绍，对JS异步语法的发展过程及各API进行了学习举例，其中很多结论及代码例子来源于下列参考文献，总结不到位的地方还请大家批评指正。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>阮一峰ES6入门 <a href="http://es6.ruanyifeng.com/#docs/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/</a><br>详解前端异步编程的六种方案 <a href="https://www.infoq.cn/article/zwowtega7KjC4Ad-trp4" target="_blank" rel="noopener">https://www.infoq.cn/article/zwowtega7KjC4Ad-trp4</a><br>夯实基础-JavaScript异步编程 <a href="https://segmentfault.com/a/1190000014874668" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014874668</a><br>co源码 <a href="https://github.com/tj/co" target="_blank" rel="noopener">https://github.com/tj/co</a><br>thunkify 源码 <a href="https://github.com/tj/node-thunkify" target="_blank" rel="noopener">https://github.com/tj/node-thunkify</a><br>Javascript设计模式之发布-订阅模式 <a href="https://juejin.im/post/5a9108b6f265da4e7527b1a4" target="_blank" rel="noopener">https://juejin.im/post/5a9108b6f265da4e7527b1a4</a><br>JS 异步编程六种方案 <a href="https://juejin.im/post/5c30375851882525ec200027" target="_blank" rel="noopener">https://juejin.im/post/5c30375851882525ec200027</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对Javascript中异步编程的几种语法以及使用方式进行了介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Linxiaowen" scheme="http://xgfe.github.io/categories/Linxiaowen/"/>
    
    
      <category term="JS异步" scheme="http://xgfe.github.io/tags/JS%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 异步</title>
    <link href="http://xgfe.github.io/2019/07/29/hardhpp/javascript%20%E5%BC%82%E6%AD%A5/"/>
    <id>http://xgfe.github.io/2019/07/29/hardhpp/javascript 异步/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-12-13T08:59:38.687Z</updated>
    
    <content type="html"><![CDATA[<p>介绍JavaScript异步的四种实现方式：1&gt;回调函数；2&gt;Promise；3&gt;生成器Gererator；4&gt;Async/Await。</p><a id="more"></a><p><strong>异步编程的核心：处理程序中现在运行的部分和将来运行的部分之间的关系。</strong></p><h2 id="方法一：回调函数"><a href="#方法一：回调函数" class="headerlink" title="方法一：回调函数"></a>方法一：回调函数</h2><p>回调是JavaScript中最基础的异步模式，常见于一个耗时操作后执行某个函数。</p><h3 id="例1-一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数"><a href="#例1-一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数" class="headerlink" title="例1: 一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数"></a>例1: 一个定时器，定时器中的匿名函数就是回调函数，在1000ms后执行该函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( function() &#123;</span><br><span class="line">  console.log(&apos;Time out&apos;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><h3 id="例2-异步读取文件后执行回调函数"><a href="#例2-异步读取文件后执行回调函数" class="headerlink" title="例2: 异步读取文件后执行回调函数"></a>例2: 异步读取文件后执行回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;); </span><br><span class="line">fs.readFile(&apos;./text1.txt&apos;, &apos;utf8&apos;, function(err, data)&#123;</span><br><span class="line">  if (err)&#123;</span><br><span class="line">    throw err;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>下面，我们使用回调函数实现一个简单的需求：某应用希望根据登录人的信息，获取不同的筛选项，再根据筛选项获取到相应的数据。</p><p>整个过程分为3步：</p><ol><li>调用获取登录人岗位接口，获取登录人信息</li><li>根据登录人的信息，获取相应的筛选项</li><li>根据筛选项信息，获取该登录人默认查看的信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let position, filter, source;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &apos;get&apos;,</span><br><span class="line">    url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        position = data;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                position</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                filter = data;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    type: &apos;get&apos;,</span><br><span class="line">                    url: &apos;http://xx/getSource&apos;,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        filter</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        console.log(&apos;查看数据：&apos;, data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: function (err) &#123;</span><br><span class="line">                        console.log(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码存在两个问题：</p><ol><li><p>回调嵌套层数过多，调试困难，如果需求增加或者改变，代码难以维护和更新，即回调地狱</p></li><li><p>控制反转，即把sucess 和 error函数的执行控制交付给了第三方的ajax(..)，无法控制第三方工具的执行且第三方工具可能会出错</p></li></ol><p><strong>控制反转(inversion of control)</strong>：把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具(一组你希望有人维护的东西)之间有一份并没有明确表达的契约。</p><p>以下列出了三方工具可能出错的情况:</p><ul><li>调用回调过早(在追踪之前);</li><li>调用回调过晚(或没有调用);</li><li>调用回调的次数太少或太多(就像你遇到过的问题!);</li><li>没有把所需的环境 / 参数成功传给你的回调函数;</li><li>吞掉可能出现的错误或异常;</li><li>……</li></ul><p><strong>总结：回调函数存在的主要缺陷:缺乏顺序性和可信任性。</strong></p><h2 id="方法二：Promise"><a href="#方法二：Promise" class="headerlink" title="方法二：Promise"></a>方法二：Promise</h2><p>1.Promise解决回调函数中的信任问题，不是将自己的程序交给第三方，而是希望第三方给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么。</p><p>2.链式的写法，能够使得代码表达的有顺序性。</p><h3 id="promise解决信任问题"><a href="#promise解决信任问题" class="headerlink" title="promise解决信任问题"></a>promise解决信任问题</h3><p><strong>1&gt;调用过早</strong></p><p>根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise(类似于 new Promise(function(resolve){ resolve(42); }))也无法被同步观察到。</p><p>也就是说，对一个 Promise 调用 then(..) 的时候，即使这个 Promise 已经决议，提供给then(..) 的回调也总会被异步调用。</p><p><strong>2&gt;调用过晚</strong></p><p>和前面一点类似，Promise 创建对象调用 resolve(..) 或 reject(..) 时，这个 Promise 的then(..) 注册的观察回调就会被自动调度。可以确信，这些被调度的回调在下一个异步事件点上一定会被触发。</p><p><strong>3&gt;回调未调用</strong></p><p>首先，没有任何东西(甚至 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它决议了的话)。如果你对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise在决议时总是会调用其中的一个。</p><p><strong>4&gt;调用次数过少或过多</strong><br>根据定义，回调被调用的正确次数应该是 1。“过少”的情况就是调用 0 次，和前面解释过的“未被”调用是同一种情况。</p><p>“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次。如果出于某种原因，Promise 创建代码试图调用 resolve(..) 或 reject(..) 多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。</p><p>由于 Promise 只能被决议一次，所以任何通过 then(..) 注册的(每个)回调就只会被调用一次。</p><p>当然，如果你把同一个回调注册了不止一次(比如p.then(f); p.then(f);)，那它被调用的次数就会和注册次数相同。响应函数只会被调用一次，但这个保证并不能预防你搬起石头砸自己的脚。</p><p><strong>5&gt;未能传递参数 / 环境值</strong></p><p>Promise 至多只能有一个决议值(完成或拒绝)。如果你没有用任何值显式决议，那么这个值就是 undefined，这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，它都会被传给所有注册的(且适当的完成或拒绝)回调。</p><p>还有一点需要清楚:如果使用多个参数调用 resovle(..) 或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。这看起来似乎违背了我们前面介绍的保证，但实际上并没有，因为这是对 Promise 机制的无效使用。对于这组 API 的其他无效使用(比如多次重复调用 resolve(..))，也是类似的保护处理，所以这里的 Promise 行为是一致的(如果不是有点令人沮丧的话)。</p><p>如果要传递多个值，你就必须要把它们封装在单个值中传递，比如通过一个数组或对象。对环境来说，JavaScript 中的函数总是保持其定义所在的作用域的闭包(参见《你不知道的 JavaScript(上卷)》的“作用域和闭包”部分)，所以它们当然可以继续访问你提供的环境状态。当然，对于只用回调的设计也是这样，因此这并不是 Promise 特有的优点——但不管怎样，这仍是我们可以依靠的一个保证。</p><p><strong>6&gt; 吞掉错误或者异常</strong></p><p>如果在Promise的创建过程或在查看其决议结果过程中的任何时间点上出现了一个JavaScript异常错误，比如一个TypeError或RerenceError，那这个异常就会被捕获，并且会使这个Promise被拒绝。</p><h3 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h3><p>Promise 固有行为特性:</p><ul><li><p>每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来;</p></li><li><p>不管从 then(..) 调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置为被链接 Promise(第一点中的)的完成;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve( 21 );</span><br><span class="line">var p2 = p.then( function(v)&#123;</span><br><span class="line">  console.log( v );</span><br><span class="line">  // 用值42填充p2</span><br><span class="line">  return v * 2;</span><br><span class="line">&#125;);</span><br><span class="line">// 连接p2</span><br><span class="line">p2.then( function(v)&#123;</span><br><span class="line">    console.log( v ); // 42</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>改写上面应用中回调函数实现的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">let getPositionPromise = function () &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">               resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getFilterPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getListPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getSource&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getPositionPromise()</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        return getTokenPromise(&#123;position: data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        return getDataPromise(&#123;filter: data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (data) &#123;</span><br><span class="line">        console.log(&apos;数据：&apos;, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法三：生成器Gererator"><a href="#方法三：生成器Gererator" class="headerlink" title="方法三：生成器Gererator"></a>方法三：生成器Gererator</h2><p><strong>ES6中的生成器（Gererator）是</strong>一种顺序、看似同步的异步流程控制表达风格。</p><h3 id="可迭代协议和迭代器协议"><a href="#可迭代协议和迭代器协议" class="headerlink" title="可迭代协议和迭代器协议"></a>可迭代协议和迭代器协议</h3><p><strong>可迭代协议</strong>运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为：</p><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的Arguments对象</li><li>NodeList对象</li></ol><p><strong>注意，Object不符合可迭代协议</strong>。</p><p>为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>[Symbol.iterator]</td><td>返回一个对象的无参函数，被返回对象符合迭代器协议</td></tr></tbody></table><p>当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。</p><p><strong>迭代器协议</strong>定义了一种标准的方式来产生一个有限或无限序列的值。<br>当一个对象被认为是一个迭代器时，它实现了一个next()的方法并且拥有以下含义：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>next</td><td>返回一个对象的无参函数，被返回对象拥有两个属性：<br> <strong>1. done（boolean）</strong> - 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值  - 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。<br><strong>2. value</strong> - 迭代器返回的任何JavaScript值。done为true时可以忽略。</td></tr></tbody></table><p>使用可迭代协议和迭代器协议的例子：</p><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;; </span><br><span class="line"></span><br><span class="line">// 可迭代协议使用for...of访问</span><br><span class="line">typeof str[Symbol.iterator]; // &apos;function&apos; </span><br><span class="line">for (var s of str) &#123;</span><br><span class="line">  console.log(s); // 分别打印 &apos;h&apos;、&apos;e&apos;、&apos;l&apos;、&apos;l&apos;、&apos;o&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代器协议next方法</span><br><span class="line">var iterator = str[Symbol.iterator]();</span><br><span class="line">iterator.next(); // &#123;value: &quot;h&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;e&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;l&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;l&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: &quot;o&quot;, done: false&#125;</span><br><span class="line">iterator.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p><strong>用Generator实现异步</strong></p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>如果我们用Generator改写上面回调嵌套的例子会是什么样的呢？见代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function getPosition () &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getFilter (params) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">        data: params,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getList (params) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        url: &apos;http://xx/getList&apos;,</span><br><span class="line">        data: params,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            it.next(data);</span><br><span class="line">        &#125;</span><br><span class="line">        error: function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *main () &#123;</span><br><span class="line">    let position = yield getPosition();</span><br><span class="line">    let filter = yield getFilter(&#123;position: position &#125;);</span><br><span class="line">    let List = yield getList(&#123;filter: filter&#125;);</span><br><span class="line">    console.log(&apos;列表数据：&apos;, List);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成迭代器实例</span><br><span class="line">var it = main();</span><br><span class="line"></span><br><span class="line">// 运行第一步</span><br><span class="line">it.next();</span><br><span class="line">console.log(&apos;不影响主线程执行&apos;);</span><br></pre></td></tr></table></figure><p>我们注意*main()生成器内部的代码，不看yield关键字的话，是完全符合大脑思维习惯的同步书写形式，把异步的流程封装到外面，在成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当JavaScript主线程空闲的时候会从任务队列里依次取出回调任务执行。</p><p>如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 运行第一步</span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line">// 持续占用JavaScript主线程</span><br><span class="line">while(1) &#123;&#125;;// 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行</span><br></pre></td></tr></table></figure><p>综上，生成器Generator解决了回调函数处理异步流程的<strong>第一个问题：不符合大脑顺序、线性的思维方式。</strong>。</p><h2 id="方法四：Async-Await"><a href="#方法四：Async-Await" class="headerlink" title="方法四：Async/Await"></a>方法四：Async/Await</h2><p>Promise和Generator这两者结合起来，就是Async/Await。</p><p>Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。</p><p>我们把最开始的例子用Async/Await的方式改写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">let getPositionPromise = function () &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getPosition&apos;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">               resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getFilterPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getFilter&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let getListPromise = function (params) &#123;</span><br><span class="line">    return new Promsie(function (resolve, reject) &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            url: &apos;http://xx/getList&apos;,</span><br><span class="line">            data: params,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">async function main () &#123;</span><br><span class="line">    let position = await getPosition();</span><br><span class="line">    let filter = await getFilter(&#123;position: position &#125;);</span><br><span class="line">    let List = await getList(&#123;filter: filter&#125;);</span><br><span class="line">    console.log(&apos;列表数据：&apos;, List);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br><span class="line">console.log(&apos;不影响主线程执行&apos;);</span><br></pre></td></tr></table></figure><p>可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。</p><p><strong>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过四个阶段来讲述JavaScript异步编程的发展历程：</p><ol><li><strong>第一个阶段 - 回调函数</strong>，但会导致两个问题:<ul><li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li><li>缺乏可信任性： 控制反转导致的一系列信任问题</li></ul></li><li><strong>第二个阶段 - Promise</strong>，Promise是基于PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。</li><li><strong>第三个阶段 - 生成器函数Generator</strong>，使用Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制next(…)，将回调成功返回的数据送回JavaScript主流程中。</li><li><strong>第四个阶段 - Async/Await</strong>，Async/Await结合了Promise和Generator，在await后面跟一个Promise，它会自动等待Promise的决议值，解决了Generator需要手动控制next(…)执行的问题，真正实现了<strong>用同步的方式书写异步代码</strong>。</li></ol><blockquote><p>相关参考<br><a href="https://segmentfault.com/a/1190000015711829" target="_blank" rel="noopener">JavaScript异步编程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍JavaScript异步的四种实现方式：1&amp;gt;回调函数；2&amp;gt;Promise；3&amp;gt;生成器Gererator；4&amp;gt;Async/Await。&lt;/p&gt;
    
    </summary>
    
      <category term="hardhpp" scheme="http://xgfe.github.io/categories/hardhpp/"/>
    
    
      <category term="JavaScript" scheme="http://xgfe.github.io/tags/JavaScript/"/>
    
      <category term="异步" scheme="http://xgfe.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>【浅度解析】new Vue() 源码结构梳理</title>
    <link href="http://xgfe.github.io/2019/07/23/luoyu/vue/"/>
    <id>http://xgfe.github.io/2019/07/23/luoyu/vue/</id>
    <published>2019-07-23T05:47:00.000Z</published>
    <updated>2019-12-13T08:59:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>new Vue() 源码结构浅度解析梳理。<br><a id="more"></a></p><h1 id="为什么是浅度解析？"><a href="#为什么是浅度解析？" class="headerlink" title="为什么是浅度解析？"></a>为什么是浅度解析？</h1><p>因为深度解析网上太多了，需要的话有太多资源，本文主要是为了帮助理解new Vue()时部分源码结构。</p><h1 id="本文适用人群？"><a href="#本文适用人群？" class="headerlink" title="本文适用人群？"></a>本文适用人群？</h1><p><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176153322.png" width="300px" height="300px"></p><p>大概知道Vue生命周期是怎么回事且琢磨过上面这张图的可放心食用。<br>当然了，没琢磨过也没有关系。<br>如果您有一定的vue开发经验以及理解可以直接Command+W。</p><hr><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>首先Git克隆项目源码:</p><pre><code>git clone https://github.com/vuejs/vue.git</code></pre><p>然后进入到路径：src/core/instance，可以看到如下文件：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176575342.jpg" width="500px" height="500px"></p><p>再来看看index.js做了什么，引入各部分初始化Mixin函数，在Vue函数中执行init.js的ths._init()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class="line">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class="line">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class="line">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class="line">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure><p>所以，这几个文件的逻辑：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176154273.png" width="500px" height="500px"></p><h1 id="init逻辑及具体模块"><a href="#init逻辑及具体模块" class="headerlink" title="_init逻辑及具体模块"></a>_init逻辑及具体模块</h1><p>那么 _init 函数做了些什么呢？<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176566739.png" width="300px" height="300px"></p><h2 id="性能检测：开发环境下，标记时间"><a href="#性能检测：开发环境下，标记时间" class="headerlink" title="性能检测：开发环境下，标记时间"></a>性能检测：开发环境下，标记时间</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">mark(startTag)</span><br></pre></td></tr></table></figure><h2 id="合并方案：存在option且有子组件？"><a href="#合并方案：存在option且有子组件？" class="headerlink" title="合并方案：存在option且有子组件？"></a>合并方案：存在option且有子组件？</h2><p>  Y:因为Vue动态合并策略非常慢，并且内部组件的选项都不需要特殊处理。initInternalComponent，内部组件调用此快捷方法，内部组件实例化。<br>  N:策略合并options vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor),options || {},vm)</p><p>  详细解读可转至 <a href="https://github.com/CommanderXL/biu-blog/issues/20" target="_blank" rel="noopener">https://github.com/CommanderXL/biu-blog/issues/20</a></p><h2 id="代理方案："><a href="#代理方案：" class="headerlink" title="代理方案："></a>代理方案：</h2><p>  当前环境是开发环境，则调用initProxy方法。<br>  如果不是开发环境，则vue实例的_renderProxy属性指向vue实例本身。</p><p>  详细解读可看 <a href="https://juejin.im/post/5b11db686fb9a01e5b10eae7" target="_blank" rel="noopener">https://juejin.im/post/5b11db686fb9a01e5b10eae7</a></p><h2 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h2><p>  向上循环找到第一个非抽象父组件对象，然后把当前vm实例push到定位的第一个非抽象parent的$children属性上，什么叫非抽象组件，比如transition和keep-alive。<br>  然后进行属性赋值。</p><p>  详细解读可看 <a href="https://juejin.im/post/5b1b4acf6fb9a01e573c3fcf" target="_blank" rel="noopener">https://juejin.im/post/5b1b4acf6fb9a01e573c3fcf</a><br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176547198.png" width="1000px" height="500px"></p><h2 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h2><p>  初始化父组件事件，updateListeners：遍历父组件事件组，迭代到当前组件上：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/176592945.png" width="1000px" height="500px"></p><h2 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h2><p>  定义了各类渲染选项，并且对 （$attrs–继承所有的父组件属性）、（$listeners–子组件继承父组件的事件）进行，同时定义两个createElement方法：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/178851414.png" width="1000px" height="500px"></p><h2 id="callHook-vm-‘beforeCreate’"><a href="#callHook-vm-‘beforeCreate’" class="headerlink" title="callHook(vm, ‘beforeCreate’)"></a>callHook(vm, ‘beforeCreate’)</h2><p>  很好理解，触发beforeCreate钩子函数。</p><h2 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h2><p>  将祖先元素：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/178660101.png" width="1000px" height="500px"></p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><p>  创建数据，初始化。<br>  <strong>initProps</strong>：简单地说，遍历 props，给 props 设置响应式，给 props 设置代理，详细可见</p><p>  <strong>initMethods</strong>：这里主要是一串检测，然后绑定函数</p><p>  <strong>initData</strong>：挂载data</p><p>  <strong>initComputed</strong>：挂载Computed</p><p>  <strong>initWatch</strong>：挂载watch<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179281435.png" width="1000px" height="500px"></p><h2 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h2><p>  这里很简单,数据挂载后初始化Provide,如果时函数则call再挂在至_provided：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179310332.png" width="1000px" height="500px"></p><h2 id="callHook-vm-‘created’"><a href="#callHook-vm-‘created’" class="headerlink" title="callHook(vm, ‘created’)"></a>callHook(vm, ‘created’)</h2><p>  触发created钩子函数。</p><h2 id="mark-endTag"><a href="#mark-endTag" class="headerlink" title="mark(endTag)"></a>mark(endTag)</h2><p>  注意，created之后，计时结束。</p><h2 id="vm-mount-vm-options-el"><a href="#vm-mount-vm-options-el" class="headerlink" title="vm.$mount(vm.$options.el)"></a>vm.$mount(vm.$options.el)</h2><p>  如果存在元素,则触发mounted钩子函数：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179284931.png" width="1000px" height="500px"></p><h1 id="Minxin-funs"><a href="#Minxin-funs" class="headerlink" title="Minxin funs"></a>Minxin funs</h1><h2 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h2><p>  混入init函数，执行各部分初始化操作。</p><h2 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h2><p>  设置data和props的setter，getter，并且在原型上定义其，同时定义$watch函数。</p><h2 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin"></a>eventsMixin</h2><p>  主要是在原型上定义事件的几种启动关闭方法。</p><h2 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin"></a>lifecycleMixin</h2><p>  主要是定义原型的_update，$forceUpdate，$destroy方法，其中beforeDestroy和destroyed周期函数在此触发。</p><h2 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h2><p>  首先通过installRenderHelpers安装一系列渲染函数，然后定义$nextTick和_render：<br><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179524442.png" width="1000px" height="500px"></p><h1 id="整体关系图"><a href="#整体关系图" class="headerlink" title="整体关系图"></a>整体关系图</h1><p><img src="https://raw.githubusercontent.com/Ly2zzZ/miaomiaowu/master/photo/179544311.png" width="1500px" height="500px"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;new Vue() 源码结构浅度解析梳理。&lt;br&gt;
    
    </summary>
    
      <category term="luoyu" scheme="http://xgfe.github.io/categories/luoyu/"/>
    
    
      <category term="vue" scheme="http://xgfe.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>RxJS 初探</title>
    <link href="http://xgfe.github.io/2019/07/13/JuntingLiu/rxjs/"/>
    <id>http://xgfe.github.io/2019/07/13/JuntingLiu/rxjs/</id>
    <published>2019-07-13T08:28:30.000Z</published>
    <updated>2019-12-13T08:59:38.686Z</updated>
    
    <content type="html"><![CDATA[<p>RxJS 最近经常被提起，但其实在工作中，我并没有怎么用到过 RxJS，只在公司内部封装的桥接库中使用过。所以 RxJS 是没多少使用场景么？到底为什么要学习 RxJS 呢？</p><a id="more"></a><h1 id="一、什么是-RxJS"><a href="#一、什么是-RxJS" class="headerlink" title="一、什么是 RxJS"></a>一、什么是 RxJS</h1><p>&emsp;&emsp;RxJS 是 Reactive Extension 这种模式的 JS 实现。它使用了一种不同于传统的编程模式—函数响应式编程。也有人称它为操作数据流的 「lodash」，旨在更方便的处理数据流。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>用函数来解决问题的一种编程范式，主要特点有：声明式、纯函数、数据不可变性。</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>响应式编程是一个编程范式，但是与其他编程范式不同的是它是基于数据流和变化传播的。比如 A = B + C, 如果我们运用一种机制，当 B 或 C 变化时，A 也同时变化，这样就实现了响应式。我们熟悉的 React、Redux 就利用了响应式。</p><h2 id="Reactive-Extension"><a href="#Reactive-Extension" class="headerlink" title="Reactive Extension"></a>Reactive Extension</h2><p>Reactive Extension，也叫ReactiveX，或者简称Rx，指的是实践响应式编程的一套工具，是一套通过可监听流来做异步编程的API。Rx的概念最初由微软公司实现并开源，也就是Rx.NET，因为Rx带来的编程方式大大改进了异步编程模型，在.NET之后，众多开发者在其他平台和语言上也实现了Rx的类库，如 RxJava、RxJS 、Rx.NET。</p><hr><h1 id="二、RxJS-中的基本概念与原理"><a href="#二、RxJS-中的基本概念与原理" class="headerlink" title="二、RxJS 中的基本概念与原理"></a>二、RxJS 中的基本概念与原理</h1><p>&emsp;&emsp;任何数据都可以被表达为数据流的形式，我们需要对数据流进行创建、订阅、过滤、转换、合并等各种操作，RxJS 便可以很好的解决这些问题。</p><p><img src="https://user-images.githubusercontent.com/14134344/62932664-28c1c180-bdf3-11e9-9f0f-64a648101070.png" width="600" height="400"></p><h2 id="在-RxJS-中用来解决异步事件管理的的基本概念是"><a href="#在-RxJS-中用来解决异步事件管理的的基本概念是" class="headerlink" title="在 RxJS 中用来解决异步事件管理的的基本概念是"></a>在 RxJS 中用来解决异步事件管理的的基本概念是</h2><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或requestAnimationFrame 或其他。</li></ul><p>以上概念大部分依据发布订阅模式去思考都是比较容易理解的。对我来说比较不太理解的是 Subject 的存在。为什么只有通过 Subject 才能实现多播，而多次对一个普通的 observable 进行 subscribe 不能实现多播？下面通过一段代码来解释这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers$ = interval(1000).pipe(take(3));</span><br><span class="line">numbers$.subscribe(value =&gt; &#123;</span><br><span class="line">  console.log(&quot;observer1: &quot; + value);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  numbers$.subscribe(value =&gt; &#123;</span><br><span class="line">    console.log(&quot;observer2: &quot; + value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></p><p>你觉得这段代码的输出结果是？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observer1: 0</span><br><span class="line">observer1: 1</span><br><span class="line">observer2: 1</span><br><span class="line">observer1: 2</span><br><span class="line">observer2: 2</span><br></pre></td></tr></table></figure></p><p>实际结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">observer1: 0</span><br><span class="line">observer1: 1</span><br><span class="line">observer2: 0</span><br><span class="line">observer1: 2</span><br><span class="line">observer2: 1</span><br><span class="line">observer2: 2</span><br></pre></td></tr></table></figure></p><p>虽然我们对 Observable 做了多次 subscribe，但是对于每个 Observer ，其实都有一个独立的数据流。而真正的多播应该是同一个数据源的。其实这种区别涉及了一个概念叫做 Cold Observable 和 hot Observable， interval 实际上产生的是一个 Cold Observable，而 Cold Observable 是无法实现真正的多播的。</p><h2 id="RxJS-的设计模式"><a href="#RxJS-的设计模式" class="headerlink" title="RxJS 的设计模式"></a>RxJS 的设计模式</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p><img src="https://user-images.githubusercontent.com/14134344/62932669-2bbcb200-bdf3-11e9-92bc-cf6c117505c9.png" width="500" height="200"></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器模式是指提供一种方法，顺序访问一个聚合对象中的各元素，而又不需要暴露该对象的内部表示。迭代器模式的实现主要处理以下三种情况：</p><ul><li>获取下一个值</li><li>无更多值</li><li>错误处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const observable$ = Observable.create(observer =&gt; &#123;</span><br><span class="line">  observer.next(1);</span><br><span class="line">  observer.next(2);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const observer = &#123;</span><br><span class="line">  next: x =&gt; console.log(&quot;Observer got a next value: &quot; + x),</span><br><span class="line">  error: err =&gt; console.error(&quot;Observer got an error: &quot; + err),</span><br><span class="line">  complete: () =&gt; console.log(&quot;Observer got a complete notification&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observable$.subscribe(observer);</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// Observer got a next value: 1</span><br><span class="line">// Observer got a next value: 2</span><br><span class="line">// Observer got a complete notification</span><br></pre></td></tr></table></figure><hr><h1 id="三、RxJS-的使用示例"><a href="#三、RxJS-的使用示例" class="headerlink" title="三、RxJS 的使用示例"></a>三、RxJS 的使用示例</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class RxSearch extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      search: &quot;&quot;,</span><br><span class="line">      debounced: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.onSearch$ = new Subject();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.subscription = this.onSearch$</span><br><span class="line">      .pipe(debounceTime(300))</span><br><span class="line">      .subscribe(debounced =&gt; this.setState(&#123; debounced &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    this.subscription &amp;&amp; this.subscription.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onSearch = e =&gt; &#123;</span><br><span class="line">    const search = e.target.value;</span><br><span class="line">    this.setState(&#123; search &#125;);</span><br><span class="line">    this.onSearch$.next(search);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; search, debounced &#125; = this.state;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&#123;search&#125; onChange=&#123;this.onSearch&#125; /&gt;</span><br><span class="line">        &lt;div&gt;debounced value: &#123;debounced&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，防抖节流类有很多工具库，比如 lodash、Ramda 。但对于函数式编程的实践 lodash 是不够的，而且这些库更多的目的是工具库，而不是处理数据流，如果有更多的要求，这些库处理起来是不够优雅的。比如结果再延迟 1000 毫秒显示，结果做过滤、转换、取消失效结果、自动重试等等。</p><h2 id="快速切换筛选条件，结果竟态"><a href="#快速切换筛选条件，结果竟态" class="headerlink" title="快速切换筛选条件，结果竟态"></a>快速切换筛选条件，结果竟态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.onClickFilter$</span><br><span class="line">  .pipe(</span><br><span class="line">    debounceTime(300), // 加入 debounce 特性，停止输入 500ms 之后再发送请求</span><br><span class="line">    distinctUntilChanged(), //内容不变时不再继续流水线</span><br><span class="line">    // switchMap 后前面的请求会被自动 cancel 掉，天然避免竞态问题</span><br><span class="line">    switchMap(filter =&gt;</span><br><span class="line">      from(fetch(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  .subscribe(data =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="批量请求异步数据流的集中管理与重试"><a href="#批量请求异步数据流的集中管理与重试" class="headerlink" title="批量请求异步数据流的集中管理与重试"></a>批量请求异步数据流的集中管理与重试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const source$ = range(1, 5);</span><br><span class="line">source$</span><br><span class="line">  .pipe(</span><br><span class="line">    mergeMap(x =&gt; &#123;</span><br><span class="line">      return fetch(`https://api.github.com/repos/ReactiveX/rxjs`).then(res =&gt; &#123;</span><br><span class="line">        if (res.status !== &quot;200&quot;) &#123;</span><br><span class="line">          throw new Error(&quot;Error!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return of(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    retry(2),</span><br><span class="line">    catchError(err =&gt; of(err))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(x =&gt; console.log(&quot;source1$:&quot;, x));</span><br></pre></td></tr></table></figure><h2 id="RxJS-结合-Redux-驱动-React"><a href="#RxJS-结合-Redux-驱动-React" class="headerlink" title="RxJS 结合 Redux 驱动 React"></a>RxJS 结合 Redux 驱动 React</h2><p>我们在工作中，大部分时候会用数据管理的库结合 UI 框架去开发，比如 Vuex + Vue，Redux + React 等，所以此处我们来实践一下 Rxjs + Redux + React 。<br>为什么不干脆用 RxJS 代替 Redux ？Redux 的社区相对更成熟，Redux 不足的是对异步的处理，周边已经有了 redux-thunk、redux-promise、redux-saga 等一系列的中间件。RxJS 也可以提供更优雅的异步处理能力，而与此对应的中间件便是redux-observable 。（<a href="https://juejin.im/entry/58db23552f301e007e9786a2" target="_blank" rel="noopener">对比参考</a>）</p><blockquote><p>Store.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;</span><br><span class="line">import &#123; createEpicMiddleware &#125; from &quot;redux-observable&quot;;</span><br><span class="line">import reducer from &quot;./Reducer&quot;;</span><br><span class="line">import epic from &quot;./Epic&quot;;</span><br><span class="line"></span><br><span class="line">const initValues = &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;;</span><br><span class="line">const epicMiddleware = createEpicMiddleware();</span><br><span class="line">const store = createStore(reducer, initValues, applyMiddleware(epicMiddleware));</span><br><span class="line">epicMiddleware.run(epic);</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure></p><p>Epic.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; increment, decrement &#125; from &quot;./Actions&quot;;</span><br><span class="line">import * as ActionTypes from &quot;./ActionTypes&quot;;</span><br><span class="line">import &#123; delay, filter, map &#125; from &quot;rxjs/operators&quot;;</span><br><span class="line"></span><br><span class="line">const epic = (action$, state$) =&gt; &#123;</span><br><span class="line">  return action$.pipe(</span><br><span class="line">    filter(</span><br><span class="line">      action =&gt;</span><br><span class="line">        action.type === ActionTypes.DECREMENT ||</span><br><span class="line">        action.type === ActionTypes.INCREMENT</span><br><span class="line">    ),</span><br><span class="line">    delay(1000),</span><br><span class="line">    map(action =&gt; &#123;</span><br><span class="line">      const count = state$.value.count;</span><br><span class="line">      console.log(action$, state$);</span><br><span class="line">      if (count &gt; 0) &#123;</span><br><span class="line">        return decrement();</span><br><span class="line">      &#125; else if (count &lt; 0) &#123;</span><br><span class="line">        return increment();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#123; type: &quot;no-op&quot; &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default epic;</span><br></pre></td></tr></table></figure></p><p>Counter.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &quot;react-redux&quot;;</span><br><span class="line">import * as Actions from &quot;../../redux/Actions&quot;;</span><br><span class="line">import CounterView from &quot;./CounterView&quot;;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state, ownProps) &#123;</span><br><span class="line">  return &#123; count: state.count &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function mapDispatchToProps(dispatch, ownProps) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onIncrement: () =&gt; dispatch(Actions.increment()),</span><br><span class="line">    onDecrement: () =&gt; &#123;</span><br><span class="line">      debugger;</span><br><span class="line">      const action = Actions.decrement();</span><br><span class="line">      return dispatch(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    reset: () =&gt; &#123;</span><br><span class="line">      dispatch(Actions.reset());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const ReduxCounter = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(CounterView);</span><br><span class="line">export default ReduxCounter;</span><br></pre></td></tr></table></figure></p></blockquote><p>Reducer.js Action.js 等和基础 Redux 使用时没有区别的，最需要关注的就是 Epic.js, 我们在 Epic 里，可以随意的使用 RxJS 提供的异步处理能力，而且可以保证真正的 Action 动作不需要写到组件逻辑中（可以对比 thunk 、promise 等方案的代码）</p><hr><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我认为学习 RxJS 的原因有两点: </p><ul><li>RxJS 为我们提供了便捷处理异步数据流的能力。比如上文所提到的节流防抖、结果竟态、重试、数据流合并、多播等问题。当然，RxJS 不仅限于解决这些问题，还有很多本文没有涉及到，比如调度器的提供使我们更便捷的调度异步数据流、多种 Subject 的变体使我们可以进行便捷的进行多样化的多播。</li><li>RxJS 的编程范式以及设计模式都是我们该去了解的知识。</li></ul><p>学习方法总结:</p><ul><li>掌握基础操作符，才能体会到 RxJS 的能力</li><li>利用弹珠图理解基础操作符</li></ul><hr><h1 id="五、学习资料"><a href="#五、学习资料" class="headerlink" title="五、学习资料"></a>五、学习资料</h1><ul><li><a href="https://cn.rx.js.org/manual/overview.html#h11" target="_blank" rel="noopener">中文文档</a></li><li><a href="https://rxjs.dev/api" target="_blank" rel="noopener">英文文档</a></li><li><a href="https://rxviz.com/examples/custom-operator" target="_blank" rel="noopener">弹珠图</a></li><li><a href="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener">redux-observable</a></li></ul><hr><p>本文部分内容参考自程墨的 《RxJS 深入浅出》，建议大家有时间亲自读一下这本书。<br>本文内容如有错误或不妥，欢迎交流指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJS 最近经常被提起，但其实在工作中，我并没有怎么用到过 RxJS，只在公司内部封装的桥接库中使用过。所以 RxJS 是没多少使用场景么？到底为什么要学习 RxJS 呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JuntingLiu" scheme="http://xgfe.github.io/categories/JuntingLiu/"/>
    
    
      <category term="RxJS" scheme="http://xgfe.github.io/tags/RxJS/"/>
    
      <category term="redux-observable" scheme="http://xgfe.github.io/tags/redux-observable/"/>
    
  </entry>
  
  <entry>
    <title>Android 着色器 tint</title>
    <link href="http://xgfe.github.io/2019/07/04/chenluan/tint/"/>
    <id>http://xgfe.github.io/2019/07/04/chenluan/tint/</id>
    <published>2019-07-04T05:08:30.000Z</published>
    <updated>2019-07-21T06:35:06.295Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设我们想实现一种效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/target.png" alt=""></p><p>不怎么友好的做法是让设计师给五张资源图，然后依次排列五个对应的 ImageView。这种做法是存在一些问题的，apk 包体积增加了五张图的大小；程序运行时内存增加了五张图的大小。</p><p>这时，我们就可以考虑使用着色器来简单快捷高效地实现这个效果了。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>在 drawable 中导入一张资源图，导入的这张图本身的颜色不用太在意，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/icon.png" alt=""></p><p>在布局中配置 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中关键点即是 <strong>android:tint</strong>，这里配置多个 ImageView，<strong>tint</strong> 配置不同的颜色值，就达到了我们的目的，而且没有前述的弊端。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="Paint-amp-ColorFilter"><a href="#Paint-amp-ColorFilter" class="headerlink" title="Paint &amp; ColorFilter"></a>Paint &amp; ColorFilter</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorFilter" target="_blank" rel="noopener">ColorFilter</a><br>颜色过滤器，通过 Paint.setColorFilter 修改渲染某个像素时的颜色值，ColorFilter 有如下一些子类，后续着重介绍一下 PorterDuffColorFilter。</p><h3 id="BlendModeColorFilter"><a href="#BlendModeColorFilter" class="headerlink" title="BlendModeColorFilter"></a>BlendModeColorFilter</h3><p>混合模式，在 API Level 29 中添加的，类似于 Android 原生的 PorterDuffXferMode，在 Flutter、CSS中都有一些体现。</p><h3 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h3><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorMatrix.html" target="_blank" rel="noopener">ColorMatrix</a><br>通过一个 4x5 的矩阵与颜色 [R, G, B, A] 进行矩阵乘积，得到目标颜色值，可以调整亮度、饱和度、色调等来实现类似 PS 中的滤镜效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/color_matrix.png" alt=""></p><h3 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h3><p>通过颜色的相乘与相加，模拟简单的光照效果。</p><h3 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h3><p>使用一个颜色和 PorterDuff 模式对目标进行染色。</p><h4 id="PorterDuff-Mode"><a href="#PorterDuff-Mode" class="headerlink" title="PorterDuff.Mode"></a>PorterDuff.Mode</h4><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html" target="_blank" rel="noopener">PorterDuff.Mode</a><br>假设存在两个形状 SRC 和 DST，其中带颜色的区域的像素点 alpha = 1; color = [red|blue]，其它区域像素点 alpha = 0; color = 0，则它们叠加相交得到 ABCD 4个区，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/composite.png" alt=""></p><p>通过对 SRC 和 DST 图中的像素值 ARGB 进行数学运算，得到一些裁剪混合叠加效果，展示其中三个如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/effect.png" alt=""></p><p>其中每种模式都有对应的数学公式进行运算，例如 SRC_ATOP 的计算方式，如下：<br>alpha_out = alpha_dst<br>color_out = alpha_dst * color_src + (1 - alpha_src) * color_dst</p><p>对于 AD 区，alpha 的运算结果采用了 DST 的 alpha = 0，所以 AD 区是可不见的，BC 区是可见的，最终结果在形状上表现为 DST 的样子，所以 AD 区的颜色也就没有必要计算了。</p><p>对于 B 区的颜色，如下：<br>color_out = 1 * 0 + (1 - 0) * red = red</p><p>对于 C 区的颜色，如下：<br>color_out = 1 * blue + (1 - 1) * red = blue</p><p>最终分析结果与前述图片表现一致。其它种类模式的公式可以参考 Android Developer。</p><h2 id="BitmapDrawable-setTintList"><a href="#BitmapDrawable-setTintList" class="headerlink" title="BitmapDrawable.setTintList"></a>BitmapDrawable.setTintList</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank" rel="noopener">BitmapDrawable</a></p><p>这个方法是在 API Level 21 中添加的，将一个颜色 ColorStateList 设置给 mTintFilter 变量，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PorterDuffColorFilter mTintFilter;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapState state = mBitmapState;</span><br><span class="line">    <span class="keyword">if</span> (state.mTint != tint) &#123;</span><br><span class="line">        state.mTint = tint;</span><br><span class="line">        mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);</span><br><span class="line">        invalidateSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在渲染的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clearColorFilter;</span><br><span class="line">    <span class="keyword">if</span> (mTintFilter != <span class="keyword">null</span> &amp;&amp; paint.getColorFilter() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paint.setColorFilter(mTintFilter);</span><br><span class="line">        clearColorFilter = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearColorFilter = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将这个 PorterDuffColorFilter 交给了 Paint 进行处理。</p><h2 id="ImageView-tint"><a href="#ImageView-tint" class="headerlink" title="ImageView_tint"></a>ImageView_tint</h2><p>ImageView 在使用 tint 属性的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyImageTint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span> &amp;&amp; (mHasDrawableTint || mHasDrawableTintMode)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTint) &#123;</span><br><span class="line">            mDrawable.setTintList(mDrawableTintList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTintMode) &#123;</span><br><span class="line">            mDrawable.setTintMode(mDrawableTintMode);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们从 ImageView 的 tint 属性到 Paint 的使用，过程如下：</p><ul><li>ImageView 读取到 tint 属性之后，将 tint color 和 tint mode 设置给 Drawable</li><li>Drawable 将 tint color 和 tint mode 组装成 PorterDuffColorFilter</li><li>Drawable 在渲染的时候，将 PorterDuffColorFilter 设置给 Paint</li><li>Paint 将效果应用到画布上</li></ul><h2 id="ImageView-tintMode"><a href="#ImageView-tintMode" class="headerlink" title="ImageView_tintMode"></a>ImageView_tintMode</h2><p>ImageView 在使用 tint 属性的时候，也可以配置 tintMode 属性，如下：</p><ul><li>add</li><li>multiply</li><li>screen</li><li>src_atop</li><li>src_in</li><li>src_over</li></ul><p>Drawable 的默认 tint mode 是 SRC_IN，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> PorterDuff.Mode DEFAULT_TINT_MODE = PorterDuff.Mode.SRC_IN;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ImageView 的默认 tint mode 是 SRC_ATOP，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tint)) &#123;</span><br><span class="line">    mDrawableTintList = a.getColorStateList(R.styleable.ImageView_tint);</span><br><span class="line">    mHasDrawableTint = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prior to L, this attribute would always set a color filter with</span></span><br><span class="line">    <span class="comment">// blending mode SRC_ATOP. Preserve that default behavior.</span></span><br><span class="line">    mDrawableTintMode = PorterDuff.Mode.SRC_ATOP;</span><br><span class="line">    mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 PorterDuff 对应的 SRC 默认是一个铺满 DST 宽高的颜色值，所以 SRC_IN 和 SRC_ATOP 效果上是一样的。<br>布局 xml 中只提供了6中模式，若想使用其它 PorterDuff 模式也可以，需要用 Java 代码去实现。</p><h1 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h1><h2 id="Drawable-setTintList"><a href="#Drawable-setTintList" class="headerlink" title="Drawable.setTintList"></a>Drawable.setTintList</h2><p>tint 不仅仅只是 BitmapDrawable 可以使用，setTintList 在 API Level 21 中被添加到 Drawable 中，所以 Drawable 子类都可以使用，如下：</p><ul><li>BitmapDrawable</li><li>NinePatchDrawable</li><li>LayerDrawable</li><li>StateListDrawable</li><li>LevelListDrawable</li><li>TransitionDrawable</li><li>InsetDrawable</li><li>ClipDrawable</li><li>ScaleDrawable</li><li>ShapeDrawable</li><li>GradientDrawable</li><li>AnimationDrawable</li><li>VectorDrawable</li></ul><p>其中有一些 Drawable 可以在布局 xml 中配置 tint，如下：</p><p>BitmapDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NinePatchDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nine-patch</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nine-patch</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>ShapeDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>VectorDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="ColorStateList"><a href="#ColorStateList" class="headerlink" title="ColorStateList"></a>ColorStateList</h2><p>我们可以在 xml 中配置一个 ColorStateList，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#FF0000"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后将这个 ColorStateList 设置给 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"@color/state_color"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样当这个 ImageView 被点击的时候，颜色就可以被改变。</p><p>当然还有一种方式可以实现这种效果，使用 xml 配置两个 bitmap，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后配置一个 selector，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_pressed"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>随后将这个 selector 设置给 ImageView。这种方式占用了更多的内存，因为 BitmapDrawable 在 inflate 的时候直接从输入流读取文件的，没有进行图片重用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.inflate(r, parser, attrs, theme);</span><br><span class="line">        ...</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = r.openRawResource(srcResId, value)) &#123;</span><br><span class="line">            bitmap = BitmapFactory.decodeResourceStream(r, value, is, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing and pick up the error below.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>基于前述几种使用方式，我们就可以将 LevelListDrawable、LayerDrawable、StateListDrawable、BitmapDrawable 组合在一起，这就可以有无限的组合方式了。</p><h2 id="在-View-中配置-tint"><a href="#在-View-中配置-tint" class="headerlink" title="在 View 中配置 tint"></a>在 View 中配置 tint</h2><p>除了前述 ImageView 中可以配置 tint 外，View 也可以对前景和背景配置 tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:backgroundTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:foregroundTint</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>TextView 也可以配置 drawable tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>CompoundButton 也可以配置 button tint，所以 CheckBox、RadioButton 等也可以配置 button tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:buttonTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Compatible"><a href="#Compatible" class="headerlink" title="Compatible"></a>Compatible</h2><h3 id="ViewCompat"><a href="#ViewCompat" class="headerlink" title="ViewCompat"></a>ViewCompat</h3><p>由于 API Level 21 才开始支持 background tint 在 xml 中配置，可以使用 ViewCompat.setBackgroundTintList 和 ViewCompat.setBackgroundTintMode 进行兼容。</p><p>如果我们想在自定义 View 中也实现 tint 的一些特性，可以让自定义 View 实现 TintableBackgroundView 接口，然后调用 ViewCompat.setBackgroundTintList 进行设置，这样就能对 API Level 21 之前的版本进行兼容。</p><p>ViewCompat 的相关实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewCompatBaseImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi26Impl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi24Impl();</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatBaseImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">    IMPL.setBackgroundTintList(view, tintList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatApi21Impl</span> <span class="keyword">extends</span> <span class="title">ViewCompatApi19Impl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        view.setBackgroundTintList(tintList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT == <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="comment">// Work around a bug in L that did not update the state of the background</span></span><br><span class="line">            <span class="comment">// after applying the tint</span></span><br><span class="line">            Drawable background = view.getBackground();</span><br><span class="line">            <span class="keyword">boolean</span> hasTint = (view.getBackgroundTintList() != <span class="keyword">null</span>)</span><br><span class="line">                    &amp;&amp; (view.getBackgroundTintMode() != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((background != <span class="keyword">null</span>) &amp;&amp; hasTint) &#123;</span><br><span class="line">                <span class="keyword">if</span> (background.isStateful()) &#123;</span><br><span class="line">                    background.setState(view.getDrawableState());</span><br><span class="line">                &#125;</span><br><span class="line">                view.setBackground(background);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatBaseImpl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> TintableBackgroundView) &#123;</span><br><span class="line">            ((TintableBackgroundView) view).setSupportBackgroundTintList(tintList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DrawableCompat"><a href="#DrawableCompat" class="headerlink" title="DrawableCompat"></a>DrawableCompat</h3><p>由于 API Level 21 才开始支持对 drawable 设置 tint，可以使用 DrawableCompat.setTintList，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(@NonNull Drawable drawable, @Nullable ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        drawable.setTintList(tint);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> TintAwareDrawable) &#123;</span><br><span class="line">        ((TintAwareDrawable)drawable).setTintList(tint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 DrawableCompat.wrap 对 drawable 进行包装兼容，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">wrap</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi21(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi19(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi14(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>多图并列显示，用颜色来区分类别，图的形状是一样的</li><li>简单的按钮普通、按下、置灰等状态切换</li><li>换肤换主题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。&lt;/p&gt;
    
    </summary>
    
      <category term="chenluan" scheme="http://xgfe.github.io/categories/chenluan/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="tint" scheme="http://xgfe.github.io/tags/tint/"/>
    
  </entry>
  
  <entry>
    <title>非原生 ROM 的 Crash 问题通用排查方法</title>
    <link href="http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/"/>
    <id>http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/</id>
    <published>2019-06-17T08:28:30.000Z</published>
    <updated>2019-06-18T03:58:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。</p><a id="more"></a><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>日常清理 Crash 时，遇到一些空指针异常的问题，每天不多，但是日积月累，数量并不少，堆栈信息如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">'java.lang.Class java.lang.Object.getClass()'</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">at android.os.Message.toStringLite(Message.java:<span class="number">507</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">221</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">5809</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">372</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">1113</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">879</span>)</span><br></pre></td></tr></table></figure></p><p>翻看 android.os.Message 的源代码，并没有 toStringLite() 这个函数，显然，这是手机厂商修改了原生 ROM，自己加上的。如何跟进此类适配性问题呢？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>此类 ROM 相关问题无法修复，只能从 App 的代码调用端进行适配，类似 H5 页面适配各种浏览器一样。所以，主要问题在于找出非原生 ROM 的执行逻辑，从而想办法避免 Crash。那么，如何发掘里面的执行逻辑呢？</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>初步考虑，通过 ClassLoader 动态导出具体的 class 类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            InputStream inputStream = classLoader.getResourceAsStream(<span class="string">"java/util/List.class"</span>);</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"List.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileOutputStream.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法对 Java 是适用的，但是在 Android 中并不适用。</p><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>既然动态方法不行，考虑静态方法，毕竟在手机 ROM 中，必然有对应的文件。</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>首先，通过 Crash 平台的附加信息，找到手机的型号、版本「型号：OPPO R9tm，版本：5.1」，找一台同型号、同版本的手机「美团有云真机平台，上面的手机种类繁多」，连上 adb。</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>把 boot.oat 文件从手机 pull 下来，boot.oat 包含启动相关的代码，可理解为里面有优化过的 framework.jar 文件，对应 SDK 的 android.jar 文件，文件较大，有 85M 左右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ adb -s 172.18.92.198:44429 pull /system/framework/arm64/boot.oat .</span><br><span class="line">/system/framework/arm64/boot.oat: 1 file pulled. 0.4 MB/s (85477748 bytes <span class="keyword">in</span> 229.612s)</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ ls -l boot.oat </span><br><span class="line">-rw-r--r--  1 leidiqiu  staff  85477748 May  8 16:17 boot.oat</span><br></pre></td></tr></table></figure></p><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>下载 <a href="https://github.com/testwhat/SmaliEx/releases/download/0.86/oat2dex.jar" target="_blank" rel="noopener">oat2dex.jar</a> 工具，并将 oat 文件转换成 dex 文件，会生成 odex、dex 两个文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ java -jar ~/libs/oat2dex.jar boot boot.oat </span><br><span class="line">05-08 16:23:27:465 Output raw dex: /Users/leidiqiu/Desktop/odex/core-libart.dex</span><br><span class="line">05-08 16:23:27:466 Output raw dex: /Users/leidiqiu/Desktop/odex/conscrypt.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/okhttp.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/core-junit.dex</span><br><span class="line">05-08 16:23:27:469 Output raw dex: /Users/leidiqiu/Desktop/odex/bouncycastle.dex</span><br><span class="line">05-08 16:23:27:472 Output raw dex: /Users/leidiqiu/Desktop/odex/ext.dex</span><br><span class="line">05-08 16:23:27:488 Output raw dex: /Users/leidiqiu/Desktop/odex/framework.dex</span><br><span class="line">05-08 16:23:27:503 Output raw dex: /Users/leidiqiu/Desktop/odex/framework-classes2.dex</span><br><span class="line">05-08 16:23:27:511 Output raw dex: /Users/leidiqiu/Desktop/odex/telephony-common.dex</span><br><span class="line">05-08 16:23:27:512 Output raw dex: /Users/leidiqiu/Desktop/odex/voip-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/ims-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/mms-common.dex</span><br><span class="line">05-08 16:23:27:517 Output raw dex: /Users/leidiqiu/Desktop/odex/android.policy.dex</span><br><span class="line">05-08 16:23:27:523 Output raw dex: /Users/leidiqiu/Desktop/odex/apache-xml.dex</span><br><span class="line">05-08 16:23:27:529 Output raw dex: /Users/leidiqiu/Desktop/odex/oppo-framework.dex</span><br><span class="line">05-08 16:23:27:530 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-common.dex</span><br><span class="line">05-08 16:23:27:531 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:27:532 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-telephony-common.dex</span><br><span class="line">05-08 16:23:27:786 De-optimizing /system/framework/core-libart.jar</span><br><span class="line">05-08 16:23:30:094 Output to /Users/leidiqiu/Desktop/dex/core-libart.dex</span><br><span class="line">05-08 16:23:30:094 De-optimizing /system/framework/conscrypt.jar</span><br><span class="line">05-08 16:23:30:208 Output to /Users/leidiqiu/Desktop/dex/conscrypt.dex</span><br><span class="line">05-08 16:23:30:208 De-optimizing /system/framework/okhttp.jar</span><br><span class="line">05-08 16:23:30:356 Output to /Users/leidiqiu/Desktop/dex/okhttp.dex</span><br><span class="line">05-08 16:23:30:356 De-optimizing /system/framework/core-junit.jar</span><br><span class="line">05-08 16:23:30:371 Output to /Users/leidiqiu/Desktop/dex/core-junit.dex</span><br><span class="line">05-08 16:23:30:371 De-optimizing /system/framework/bouncycastle.jar</span><br><span class="line">05-08 16:23:30:928 Output to /Users/leidiqiu/Desktop/dex/bouncycastle.dex</span><br><span class="line">05-08 16:23:30:928 De-optimizing /system/framework/ext.jar</span><br><span class="line">05-08 16:23:31:483 Output to /Users/leidiqiu/Desktop/dex/ext.dex</span><br><span class="line">05-08 16:23:31:483 De-optimizing /system/framework/framework.jar</span><br><span class="line">05-08 16:23:36:301 Output to /Users/leidiqiu/Desktop/dex/framework.dex</span><br><span class="line">05-08 16:23:36:301 De-optimizing /system/framework/framework.jar:classes2.dex</span><br><span class="line">05-08 16:23:38:611 Output to /Users/leidiqiu/Desktop/dex/framework-classes2.dex</span><br><span class="line">05-08 16:23:38:611 De-optimizing /system/framework/telephony-common.jar</span><br><span class="line">05-08 16:23:40:395 Output to /Users/leidiqiu/Desktop/dex/telephony-common.dex</span><br><span class="line">05-08 16:23:40:395 De-optimizing /system/framework/voip-common.jar</span><br><span class="line">05-08 16:23:40:440 Output to /Users/leidiqiu/Desktop/dex/voip-common.dex</span><br><span class="line">05-08 16:23:40:440 De-optimizing /system/framework/ims-common.jar</span><br><span class="line">05-08 16:23:40:625 Output to /Users/leidiqiu/Desktop/dex/ims-common.dex</span><br><span class="line">05-08 16:23:40:625 De-optimizing /system/framework/mms-common.jar</span><br><span class="line">05-08 16:23:40:626 Output to /Users/leidiqiu/Desktop/dex/mms-common.dex</span><br><span class="line">05-08 16:23:40:626 De-optimizing /system/framework/android.policy.jar</span><br><span class="line">05-08 16:23:40:764 Output to /Users/leidiqiu/Desktop/dex/android.policy.dex</span><br><span class="line">05-08 16:23:40:764 De-optimizing /system/framework/apache-xml.jar</span><br><span class="line">05-08 16:23:41:178 Output to /Users/leidiqiu/Desktop/dex/apache-xml.dex</span><br><span class="line">05-08 16:23:41:178 De-optimizing /system/framework/oppo-framework.jar</span><br><span class="line">05-08 16:23:41:613 Output to /Users/leidiqiu/Desktop/dex/oppo-framework.dex</span><br><span class="line">05-08 16:23:41:613 De-optimizing /system/framework/mediatek-common.jar</span><br><span class="line">05-08 16:23:41:660 Output to /Users/leidiqiu/Desktop/dex/mediatek-common.dex</span><br><span class="line">05-08 16:23:41:660 De-optimizing /system/framework/mediatek-framework.jar</span><br><span class="line">05-08 16:23:41:889 Output to /Users/leidiqiu/Desktop/dex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:41:889 De-optimizing /system/framework/mediatek-telephony-common.jar</span><br><span class="line">05-08 16:23:41:891 Output to /Users/leidiqiu/Desktop/dex/mediatek-telephony-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>查看 dex 文件夹，发现有 framework.dex 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ <span class="built_in">cd</span> dex/</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ ls</span><br><span class="line">android.policy.dex            ext.dex                       mediatek-telephony-common.dex</span><br><span class="line">apache-xml.dex                framework-classes2.dex        mms-common.dex</span><br><span class="line">bouncycastle.dex              framework.dex                 okhttp.dex</span><br><span class="line">conscrypt.dex                 ims-common.dex                oppo-framework.dex</span><br><span class="line">core-junit.dex                mediatek-common.dex           telephony-common.dex</span><br><span class="line">core-libart.dex               mediatek-framework.dex        voip-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h3><p>下载 <a href="https://sourceforge.net/projects/dex2jar/files/dex2jar-2.0.zip/download" target="_blank" rel="noopener">dex2jar-2.0.zip</a> 工具，将 dex 转成 jar，并用 JD-GUI 打开，JD-GUI 下载地址：<a href="http://java-decompiler.github.io/。" target="_blank" rel="noopener">http://java-decompiler.github.io/。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ dex2jar.sh framework.dex </span><br><span class="line">dex2jar framework.dex -&gt; ./framework-dex2jar.jar</span><br><span class="line">Detail Error Information <span class="keyword">in</span> File ./framework-error.zip</span><br><span class="line">Please report this file to http://code.google.com/p/dex2jar/issues/entry <span class="keyword">if</span> possible.</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ open framework-dex2jar.jar -a JD-GUI.app</span><br></pre></td></tr></table></figure></p><h3 id="步骤六"><a href="#步骤六" class="headerlink" title="步骤六"></a>步骤六</h3><p>通过 JD-GUI 查看，终于找到了 Message 类，里面确实有 toStringLite() 方法。<br><img src="http://s3plus.sankuai.com/v1/mss_7fabbc64efb346df9722fadcafbc20bc/blog/Message.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此类方法相对通用，对定位非原生 ROM 的问题很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="leidiqiu" scheme="http://xgfe.github.io/categories/leidiqiu/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Crash" scheme="http://xgfe.github.io/tags/Crash/"/>
    
      <category term="非原生ROM" scheme="http://xgfe.github.io/tags/%E9%9D%9E%E5%8E%9F%E7%94%9FROM/"/>
    
  </entry>
  
  <entry>
    <title>类Redux的数据中间层的实现</title>
    <link href="http://xgfe.github.io/2019/05/26/yangziyao/%E7%B1%BBRedux%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E9%97%B4%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2019/05/26/yangziyao/类Redux的数据中间层实现/</id>
    <published>2019-05-26T02:00:00.000Z</published>
    <updated>2019-06-14T07:34:42.521Z</updated>
    
    <content type="html"><![CDATA[<p>关于全局单向数据流+视图层computed属性的一个简单实现。</p><a id="more"></a><h1 id="数据中间层简介"><a href="#数据中间层简介" class="headerlink" title="数据中间层简介"></a>数据中间层简介</h1><p>在上家公司工作时，由于使用自研框架比较陈旧，不支持全局的跨视图的数据复用。又由于当时react的BSD+Patents证书事件，团队决定放弃引入开源……于是就自己造了一个支持单向数据流的轮子，就是本文介绍的数据中间层。在视图数据层面，也实现了类似vue的computed属性来优化开发体验。</p><h1 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h1><p><img src="https://github.com/zero-yang/assets/blob/master/data-midware.png?raw=true" alt=""></p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store模块负责存储全局数据和定义操作数据的actions。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel模块负责维护视图自身的数据，接收来自Store的change事件以响应Store数据变更，通过dispatch action操作Store中的数据。</p><h2 id="Updater"><a href="#Updater" class="headerlink" title="Updater"></a>Updater</h2><p>Updater模块定义了数据的操作，包括set，get，assign等，可以通过指定数据源对Store或者ViewModel的实例进行操作。同时也定义了dispatch操作。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>由于这是一年半前写的代码，还有种种原因不方便透露源码，这里只介绍主要的实现思路，具体实现还需要考虑很多边界场景，这里就不细说了。</p><h2 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h2><p>Store的代码实现很简单，主要包含存储数据的对象，定义action对象的数组，以及注册action的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = &#123;</span><br><span class="line">    state: &#123;&#125;, </span><br><span class="line">    actions: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'setFormData'</span>,</span><br><span class="line">            <span class="keyword">async</span> method() &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    addAction(actionList) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions.concat(actionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，action对象中的name类似于redux中的常量，method类似于reducer，可以是异步方法。不同业务模块的action可以维护在独立的模块中，通过Store.addAction注册到Store中。</p><h2 id="Updater-1"><a href="#Updater-1" class="headerlink" title="Updater"></a>Updater</h2><p>Updater负责数据的操作和不同数据实体间的交互，是三个模块中最核心的模块。包含了数据操作的set，get和assign，处理action的dispatch。还有一个buildFactory方法，是为了保证在执行action的过程中对Store数据操作的原子性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Updater = &#123;</span><br><span class="line">    find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    assign(source, path, value) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(source, path, value) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get(source, path) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    buildFactory(source) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍这几个方法。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>对指定数据源和路径进行查找，返回对应字段的父级和对应字段的key，可指定路径中的属性不存在是否创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = path.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tmp.length - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = source[tmp[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next &amp;&amp; create) &#123;</span><br><span class="line">            source[tmp[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source = next || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        key: tmp[tmp.length - <span class="number">1</span>],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设置指定数据源对应路径的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(source, path, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> setObj = <span class="keyword">this</span>.find(source, path, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    setObj.source[setObj.key] = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>跟set类似，只不过是将赋值变成对象合并。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取指定数据源对应路径的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get(source, path) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.find(source, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.source[result.key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>执行action，在执行完成后触发storeChange事件。为了保证action对Store写操作的原子性，在执行action过程中，将所有写操作先以指令的形式储存在通过buildFactory方法创建的一个factory里，再一次性进行写入操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = <span class="keyword">this</span>.buildFactory(source);</span><br><span class="line">    <span class="keyword">const</span> handler = Store.actions[action];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> handler(factory.get, factory.set, factory.assign);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> diff = factory.applyDirective();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (diff.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Event.emit(<span class="string">'storeChange'</span>, &#123;</span><br><span class="line">            diff</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buildFactory"><a href="#buildFactory" class="headerlink" title="buildFactory"></a>buildFactory</h3><p>创建指令工厂对象，提供所有Store写操作的mock方法，mock方法将所有操作以指令形式保存在fatory里，通过applyDirective方法一次执行，并返回操作的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildFactory(source) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = &#123;</span><br><span class="line">        directives: [],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="string">'set'</span>, <span class="string">'assign'</span>].reduce(<span class="function">(<span class="params">fac, key</span>) =&gt;</span> &#123;</span><br><span class="line">        fac[key] = <span class="function">(<span class="params">path, value</span>) =&gt;</span> &#123;</span><br><span class="line">            fac.directives.push(&#123;</span><br><span class="line">                type: key,</span><br><span class="line">                path,</span><br><span class="line">                value</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, factory);</span><br><span class="line"></span><br><span class="line">    factory.get = <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(factory.source, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    factory.applyDirective = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> diff = [];</span><br><span class="line"></span><br><span class="line">        factory.directives.forEach(<span class="function"><span class="params">directive</span> =&gt;</span> &#123;</span><br><span class="line">           diff = diff.concat(<span class="keyword">this</span>[directive[key]](factory.source, directive[path], directive[value]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewModel-1"><a href="#ViewModel-1" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel负责维护视图的数据，提供了类似vue的computed属性，并通过computed属性维护ViewModel实例到Store的数据依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    calDiff(diffFromStore) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    initComputed() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(path, value) &#123;</span><br><span class="line">    Updater.set(<span class="keyword">this</span>.state, path, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get(path) &#123;</span><br><span class="line">    Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>监听storeChange事件，根据diff计算自身的数据变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    Event.on(<span class="string">'storeChange'</span>, diff =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'change'</span>, <span class="keyword">this</span>.calDiff(diff));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><p>初始化computed属性，建立computed属性对自身数据字段以及Store数据字段的依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">initComputed() &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.computed).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.computed[key](</span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从自身state里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.__bindWithState__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithState__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithState__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从全局store里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.__bindWithStore__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithStore__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithStore__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(store, path);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="calDiff"><a href="#calDiff" class="headerlink" title="calDiff"></a>calDiff</h3><p>根据Store数据的diff计算自身数据的变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">calDiff(diffFromStore) &#123;</span><br><span class="line">    <span class="keyword">let</span> stateDiff = [];</span><br><span class="line"></span><br><span class="line">    diffFromStore.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithStore__[diffPath]) &#123;</span><br><span class="line">            stateDiff = stateDiff.concat(<span class="keyword">this</span>.__bindWithStore__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> diffDueToState = [];</span><br><span class="line"></span><br><span class="line">    stateDiff.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithState__[diffPath]) &#123;</span><br><span class="line">            diffDueToState = diffDueToState.concat(<span class="keyword">this</span>.__bindWithState__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(stateDiff.concat(diffDueToState)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环依赖检测"><a href="#环依赖检测" class="headerlink" title="环依赖检测"></a>环依赖检测</h3><p>为了避免在computed属性里遇到环依赖的情况，因此需要一个环依赖检测的方法。depTree为ViewModel实例里的<strong>bindWithStore</strong>或者<strong>bindWithState</strong>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleDetection</span>(<span class="params">depTree</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="built_in">Object</span>.keys(depTree);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doDetection</span>(<span class="params">node, parentSet</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> deps = depTree[node];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!deps || deps.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">const</span> depNode = deps[i];</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (parentSet.has(depNode)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doDetection(depNode, parentSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; root.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> rNode = root[i];</span><br><span class="line"></span><br><span class="line">        pSet.add(rNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!doDetection(rNode, pSet)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>注册业务相关的action：/entity/bidword.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'common/store'</span>;</span><br><span class="line"></span><br><span class="line">Store.addAction([&#123;</span><br><span class="line">name: <span class="string">'fetchBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method(get, set, assign) &#123;</span><br><span class="line"><span class="keyword">let</span> list;</span><br><span class="line"><span class="comment">// fetch list</span></span><br><span class="line"></span><br><span class="line">set(<span class="string">'bidword/list'</span>, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">'addBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method() &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>视图viewModel：/bidword/bidword-vm.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ViewModel <span class="keyword">from</span> <span class="string">'common/view-model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BidwordVM</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">computed = &#123;</span><br><span class="line">displayList(get, getFromStore) &#123;</span><br><span class="line"><span class="keyword">const</span> list = getFromStore(<span class="string">'bidword/list'</span>);</span><br><span class="line"><span class="keyword">const</span> date = get(<span class="string">'theDate'</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">item.date = date;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> init() &#123;</span><br><span class="line"><span class="keyword">this</span>.set(<span class="string">'date'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toDateString());</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.dispatch(<span class="string">'fetchBidword'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结束，页面开始渲染</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图文件view：/bidword/bidword.js</p><p>通过一个connect组件绑定视图和viewModel，connect负责维护view和viewModel实例的生命周期，具体细节这里就不赘述了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> connect <span class="keyword">from</span> <span class="string">'common/connect'</span>;</span><br><span class="line"><span class="keyword">import</span> BidwordVM <span class="keyword">from</span> <span class="string">'./bidword-vm'</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'common/base-view'</span>;</span><br><span class="line"></span><br><span class="line">@connect(BidwordVM)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bidword</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Bidword;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是数据中间层实现的一个大致的思路，希望能对大家有帮助，有问题欢迎指正~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于全局单向数据流+视图层computed属性的一个简单实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangziyao" scheme="http://xgfe.github.io/categories/yangziyao/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2019/04/16/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2019/04/16/zhangpeng/宏任务和微任务/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.258Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。</p><a id="more"></a><h2 id="一、宏任务和微任务"><a href="#一、宏任务和微任务" class="headerlink" title="一、宏任务和微任务"></a>一、宏任务和微任务</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收。</li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><p>微任务：</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br> 事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。</p><p> 事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br> 从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。</p><p> 当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br> 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br> 因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。</p><p> 所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br> 浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br> 现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，</span><br><span class="line">如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，</span><br><span class="line">在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，</span><br><span class="line">且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，</span><br><span class="line">反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，</span><br><span class="line">用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，</span><br><span class="line">可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，</span><br><span class="line">我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms，</span><br><span class="line">第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，</span><br><span class="line">并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。</span><br><span class="line">记住，一个任务一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，</span><br><span class="line">等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，</span><br><span class="line">等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line"></span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，</span><br><span class="line">任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，</span><br><span class="line">UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line"></span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，</span><br><span class="line">secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，</span><br><span class="line">接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，</span><br><span class="line">浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms，</span><br><span class="line">执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，</span><br><span class="line">但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms。</span><br><span class="line"></span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms。</span><br><span class="line"></span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。</span><br><span class="line">因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line"></span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，</span><br><span class="line">但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，</span><br><span class="line">需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line"></span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，</span><br><span class="line">单击firstButton和secondButton按钮这两个任务处于等待状态，</span><br><span class="line">但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，</span><br><span class="line">此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，</span><br><span class="line">若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，</span><br><span class="line">处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，</span><br><span class="line">此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，</span><br><span class="line">第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，</span><br><span class="line">此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，</span><br><span class="line">在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，</span><br><span class="line">添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，</span><br><span class="line">微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，</span><br><span class="line">事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line"></span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，</span><br><span class="line">在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line"></span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。</span><br><span class="line">可以在主线程和第一个按钮单击任务之间重新渲染页面，</span><br><span class="line">但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，</span><br><span class="line">所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，</span><br><span class="line">事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意。</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，<br>将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，<br>在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，</span><br><span class="line">发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.</span><br><span class="line">计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标。</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line"></span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。</span><br><span class="line">新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，</span><br><span class="line">该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，</span><br><span class="line">计时器事件与input输入框的输入事件类似，都会被添加到队列中。</span><br><span class="line">注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，</span><br><span class="line">因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，</span><br><span class="line">3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，</span><br><span class="line">这意味着单击事件处理器开始执行，setTimeout函数只到期一次，</span><br><span class="line">setInterval函数则不同，setTnterval会持续执行到被清除，</span><br><span class="line">因此，在第20ms的时候，setInterval又一次触发，</span><br><span class="line">但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发。</span><br><span class="line">但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，</span><br><span class="line">第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line"></span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，</span><br><span class="line">至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，</span><br><span class="line">而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，</span><br><span class="line">但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，</span><br><span class="line">因为队列中已经有一个与之相匹配的间隔计时器，</span><br><span class="line">在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，</span><br><span class="line">然后进入下一个事件循环迭代。</span><br><span class="line"></span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,</span><br><span class="line">又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line"></span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，</span><br><span class="line">此时，由于间隔处理器正在执行，不是在队列中等待，</span><br><span class="line">设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，</span><br><span class="line">每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line"></span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，</span><br><span class="line">事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，</span><br><span class="line">间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，</span><br><span class="line">回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>js实现算法之动态规划</title>
    <link href="http://xgfe.github.io/2019/03/25/dengzonghui/%20dynamic/"/>
    <id>http://xgfe.github.io/2019/03/25/dengzonghui/ dynamic/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。</p><a id="more"></a><h2 id="一、经典01背包"><a href="#一、经典01背包" class="headerlink" title="一、经典01背包"></a>一、经典01背包</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>背包容量capacity=5，有三个物品(value, weight)，分别是(3,2),(4,3),(5,4)求出其搭配组合，使得背包内总价最大，且最大价值为多少？</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>如果背包总容量为0，那么很显然地，任何物品都无法装进背包，那么背包内总价值必然是0。所以第一步先填满 j=0 的情况。<br>接下来将从上到下，从左往右地填写这个表格。分析第i行时，它的物品组合仅能是小于等于i的情况。所以现在把注意力定位到 i =0, j = 1 的空格上。<br>i=0 j=1 : 背包总容量为1，但是物品0 的重量为 2，无法装下去，所以这一格应该填 0。<br>i=0 j=2 : 背包总容量为2，刚好可以装下物品0 ，由于物品0 的价值为3，因此这一格填 3。<br>后面同理。<br>i=1 j=1 : 背包总容量为1，但是物品0 的重量为 2，物品1重量为3，背包无法装下任何物品，所以填 0。</p><table><thead><tr><th></th><th>val</th><th>weight</th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th></tr></thead><tbody><tr><td>i=0</td><td>3</td><td>2</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>i=1</td><td>4</td><td>3</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td></tr><tr><td>i=2</td><td>5</td><td>4</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&gt;w[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = max(T[i-1][j-w[i]]+val[i], T[i-1][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function backpack(w,val,capacity,n)&#123;</span><br><span class="line">    var T = []</span><br><span class="line"></span><br><span class="line">    for(let i = 0;i &lt; n;i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0;j &lt;= capacity;j++)&#123;</span><br><span class="line">            if(j === 0)&#123; //容量为0</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j &lt; w[i])&#123; //容量小于物品重量，本行hold不住</span><br><span class="line">                if(i === 0)&#123;</span><br><span class="line">                    T[i][j] = 0; // i = 0时，不存在i-1，所以T[i][j]取0</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j]; //容量小于物品重量，参照上一行</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i === 0)&#123;</span><br><span class="line">                T[i][j] = val[i]; //第0行，不存在 i-1, 最多只能放这一行的那一个物品</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                T[i][j] = Math.max(val[i] + T[i-1][j-w[i]],T[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findValue(w,val,capacity,n,T);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line">//找到需要的物品</span><br><span class="line">function findValue(w,val,capacity,n,T)&#123;</span><br><span class="line">    var i = n-1, j = capacity;</span><br><span class="line">    while ( i &gt; 0 &amp;&amp; j &gt; 0 )&#123;</span><br><span class="line">        if(T[i][j] != T[i-1][j])&#123;</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">            j = j- w[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i--;  //如果相等，那么就到 i-1 行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == 0 )&#123;</span><br><span class="line">        if(T[i][j] != 0)&#123; //那么第一行的物品也可以取</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [3,4,5],</span><br><span class="line">weights = [2,3,4],</span><br><span class="line">capacity = 5,</span><br><span class="line">n = values.length;</span><br><span class="line"></span><br><span class="line">console.log(backpack(weights,values,capacity,n));</span><br></pre></td></tr></table></figure><h2 id="二、最少硬币"><a href="#二、最少硬币" class="headerlink" title="二、最少硬币"></a>二、最少硬币</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>4种硬币 1分、2分、5分、6分<br>总共需要11分，求最少的硬币数以及组合</p><h3 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>与经典背包相同，填写第i行表示只能用i和比i小的硬币。硬币数组coins[]，需要的钱数j。<br>当我们只能使用面额为1分的硬币时，根据上面的规则，那么很显然，总额为几分，就需要几个硬币。<br>当我们有1分和2分两种面额时，那么组合方式就相对多了点。<br>i=1 j = 1：总额为1时，只能使用1分的面额。即填1。<br>i=1 j = 2：总额为2时，可以使用2个1分的，也可以使用1个2分的。<br>因为我们要求最少硬币，所以使用1个2分的。表格里填1。<br>以此类推：</p><table><thead><tr><th></th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th><th>j=6</th><th>j=7</th><th>j=8</th><th>j=9</th><th>j=10</th><th>j=11</th></tr></thead><tbody><tr><td>i=0 1分</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>i=1 2分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr><tr><td>i=2 5分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td></tr><tr><td>i=3 6分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&lt;coins[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = min(T[i-1][j], T[i][j-coins[i]]+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;number[]&#125; coins</span><br><span class="line">* @param &#123;number&#125; amount</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*/</span><br><span class="line">var coinChange = function(coins, amount) &#123;</span><br><span class="line">    coins.sort((a,b)=&gt;(a-b));</span><br><span class="line">    var T = [];</span><br><span class="line">    for(let i=0; i&lt;coins.length; i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0; j&lt;=amount; j++)&#123;</span><br><span class="line">            T[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;T.length; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;T[i].length; j++)&#123;</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==0)&#123;</span><br><span class="line">                if(Number.isInteger(j/coins[i]))&#123;</span><br><span class="line">                    T[i][j] = j/coins[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Infinity;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(j&lt;coins[i])&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Math.min(T[i-1][j], T[i][j-coins[i]]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return T[T.length-1][T[0].length-1]===Infinity?-1:T[T.length-1][T[0].length-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、最大正方形"><a href="#三、最大正方形" class="headerlink" title="三、最大正方形"></a>三、最大正方形</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><h3 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先用例中不一定会给正方形，也可能是长方形，所以必须分别求长和宽。<br>其次如果此点的值是0，则直接将结果设为0；如果此点的值为1，则它等于它左方、上方、左上方三者的最小值+1。<br>最后是需要一个变量max，在遍历的过程中不断修改自身获取dp中的最大值。</p><p><img src="http://p0.meituan.net/xgfe/62e9135edf9a68df2624aba1d50b9582537777.jpg" alt="最大正方形的获取"></p><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; matrix</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maximalSquare = function(matrix) &#123;</span><br><span class="line">    let len1 = matrix.length, len2;</span><br><span class="line">    var dp = new Array(len1);//设置长度</span><br><span class="line">    let max = 0;//记录矩阵中最大值</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        len2 = matrix[i].length;</span><br><span class="line">        dp[i] = new Array(len2);</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;len2; j++)&#123;</span><br><span class="line">            if(i==0 || j==0)&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;?1:0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;? (Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1):0;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max*max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、最大加号标志"><a href="#四、最大加号标志" class="headerlink" title="四、最大加号标志"></a>四、最大加号标志</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。</p><p>一个 k” 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k” 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。</p><p>k 阶轴对称加号标志示例:</p><p>阶 1:<br>000<br>010<br>000</p><p>阶 2:<br>00000<br>00100<br>01110<br>00100<br>00000</p><p>阶 3:<br>0000000<br>0001000<br>0001000<br>0111110<br>0001000<br>0001000<br>0000000</p><p>示例 1：</p><p>输入: N = 5, mines = [[4, 2]]<br>输出: 2<br>解释:</p><p>11111<br>11111<br>11111<br>11111<br>11011</p><p>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</p><p>示例 2：</p><p>输入: N = 2, mines = []<br>输出: 1<br>解释:</p><p>11<br>11</p><p>没有 2 阶加号标志，有 1 阶加号标志。</p><p>示例 3：</p><p>输入: N = 1, mines = [[0, 0]]<br>输出: 0<br>解释:</p><p>0</p><p>没有加号标志，返回 0 。</p><h3 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先要给所有位置设置最大值即边长N。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br></pre></td></tr></table></figure></p><p>循环遍历所有行，从四个方向更新dp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>left right up down注意每遍历一行都要更新为0。</strong></p><h3 id="3-代码-3"><a href="#3-代码-3" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; N</span><br><span class="line"> * @param &#123;number[][]&#125; mines</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var orderOfLargestPlusSign = function(N, mines) &#123;</span><br><span class="line">    let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br><span class="line">    for(let i=0; i&lt;mines.length; i++)&#123;</span><br><span class="line">        dp[mines[i][0]][mines[i][1]] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let left, right, up, down;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var max = 0;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;N; j++)&#123;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：<br>本文主要对动态规划几种经典题做了简单介绍，希望对大家对算法方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://juejin.im/post/5affed3951882567161ad511" target="_blank" rel="noopener">https://juejin.im/post/5affed3951882567161ad511</a><br><a href="https://juejin.im/post/5b0a8e0f51882538b2592963" target="_blank" rel="noopener">https://juejin.im/post/5b0a8e0f51882538b2592963</a><br><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。&lt;/p&gt;
    
    </summary>
    
      <category term="dengzonghui" scheme="http://xgfe.github.io/categories/dengzonghui/"/>
    
    
      <category term="算法" scheme="http://xgfe.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/"/>
    <id>http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/</id>
    <published>2019-03-09T08:15:00.000Z</published>
    <updated>2019-06-14T07:28:14.256Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。</p><a id="more"></a><h2 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</p></blockquote><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>用户注册时验证用户名是否被占用为例在输入的时候就在判断这个用户名是否已被注册。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数前<br><img src="/uploads/yangfan/DebounceThrottle/debouncebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数后<br><img src="/uploads/yangfan/DebounceThrottle/debounceafter.gif" width="400px"><br></div><br></div><p>使用防抖函数前做法存在明显缺陷当用户输入发生变化的时候，就请求判断了，不仅对服务器的压力增大了，而且用户在输入中时频繁的校验提示中断用户交互明显降低了用户体验。而理想的做法应该是，用户输入发生变化后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。而函数防抖所做的工作就是延迟一段时间去执行函数而在延迟期间又调用了此动作则重新计时。</p><h3 id="DemoCode"><a href="#DemoCode" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"ordinary"</span>&gt;</span>普通<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'ordinary'</span> <span class="attr">id</span>=<span class="string">'ordinary'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"debounce"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'debounce'</span> <span class="attr">id</span>=<span class="string">'debounce'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ajax requestDtae:<span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ordinaryInput = <span class="built_in">document</span>.getElementById(<span class="string">'ordinary'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceAjax = _.debounce(ajax, <span class="number">1000</span>)</span><br><span class="line">ordinaryInput.addEventListener(<span class="string">'keyup'</span>, ajax);</span><br><span class="line">debounceInput.addEventListener(<span class="string">'keyup'</span>, debounceAjax);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            func(args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Throttle（节流）"><a href="#Throttle（节流）" class="headerlink" title="Throttle（节流）"></a>Throttle（节流）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></blockquote><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>在瀑布流式布局的页面中，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。在发生滚动时就需要判断页面是否滚动到底部。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用节流函数前<br><img src="/uploads/yangfan/DebounceThrottle/throttlebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用节流函数后<br><img src="/uploads/yangfan/DebounceThrottle/throttleafter.gif" width="400px"><br></div><br></div><p>使用节流函数前明显缺点是消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数。</p><h3 id="DemoCode-1"><a href="#DemoCode-1" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`scroll bodyY:<span class="subst">$&#123;body.getBoundingClientRect().y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttleScrollAnimation = _.throttle(scrollAnimation, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//window.addEventListener('scroll', scrollAnimation);</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttleScrollAnimation);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (curr - start &gt;= wait) &#123;</span><br><span class="line">            func(args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func(args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 <a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">这个页面</a> 看一下两者可视化的比较。<br>在实际的开发中根据根据需求的不同合理使用 debounce 或 throttle。<br>例如：在模糊查询时使用 debounce 在无限滚动时使用 throttle。（requestAnimationFrame）</p><h2 id="附lodash实现代码"><a href="#附lodash实现代码" class="headerlink" title="附lodash实现代码"></a>附lodash实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isObject <span class="keyword">from</span> <span class="string">'./isObject.js'</span></span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">'./.internal/root.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span></span><br><span class="line"><span class="comment"> * milliseconds have elapsed since the last time the debounced function was</span></span><br><span class="line"><span class="comment"> * invoked, or until the next browser frame is drawn. The debounced function</span></span><br><span class="line"><span class="comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span></span><br><span class="line"><span class="comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span></span><br><span class="line"><span class="comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span></span><br><span class="line"><span class="comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span></span><br><span class="line"><span class="comment"> * debounced function. Subsequent calls to the debounced function return the</span></span><br><span class="line"><span class="comment"> * result of the last `func` invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span></span><br><span class="line"><span class="comment"> * invoked on the trailing edge of the timeout only if the debounced function</span></span><br><span class="line"><span class="comment"> * is invoked more than once during the `wait` timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span></span><br><span class="line"><span class="comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span></span><br><span class="line"><span class="comment"> * invocation will be deferred until the next frame is drawn (typically about</span></span><br><span class="line"><span class="comment"> * 16ms).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span></span><br><span class="line"><span class="comment"> * for details over the differences between `debounce` and `throttle`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.1.0</span></span><br><span class="line"><span class="comment"> * @category Function</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func The function to debounce.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [wait=0]</span></span><br><span class="line"><span class="comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span></span><br><span class="line"><span class="comment"> *  used (if available).</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; [options=&#123;&#125;] The options object.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.leading=false]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the leading edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [options.maxWait]</span></span><br><span class="line"><span class="comment"> *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.trailing=true]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125; Returns the new debounced function.</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Avoid costly calculations while the window size is in flux.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('resize', debounce(calculateLayout, 150))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span></span><br><span class="line"><span class="comment"> * jQuery(element).on('click', debounce(sendMail, 300, &#123;</span></span><br><span class="line"><span class="comment"> *   'leading': true,</span></span><br><span class="line"><span class="comment"> *   'trailing': false</span></span><br><span class="line"><span class="comment"> * &#125;))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span></span><br><span class="line"><span class="comment"> * const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)</span></span><br><span class="line"><span class="comment"> * const source = new EventSource('/stream')</span></span><br><span class="line"><span class="comment"> * jQuery(source).on('message', debounced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Cancel the trailing debounced invocation.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('popstate', debounced.cancel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Check for pending invocations.</span></span><br><span class="line"><span class="comment"> * const status = debounced.pending() ? "Pending..." : "Ready"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastArgs, </span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span></span><br><span class="line">    <span class="keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> root.requestAnimationFrame === <span class="string">'function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = !!options.leading</span><br><span class="line">        maxing = <span class="string">'maxWait'</span> <span class="keyword">in</span> options</span><br><span class="line">        maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = lastArgs</span><br><span class="line">        <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            root.cancelAnimationFrame(timerId);</span><br><span class="line">            <span class="keyword">return</span> root.requestAnimationFrame(pendingFunc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.cancelAnimationFrame(id)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        <span class="comment">// Start the timer for the trailing edge.</span></span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="comment">// Invoke the leading edge.</span></span><br><span class="line">        <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">        <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxing ?</span><br><span class="line">            <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke) :</span><br><span class="line">            timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either this is the first call, activity has stopped and we're at the</span></span><br><span class="line">        <span class="comment">// trailing edge, the system time has gone backwards and we're treating</span></span><br><span class="line">        <span class="comment">// it as the trailing edge, or we've hit the `maxWait` limit.</span></span><br><span class="line">        <span class="comment">// timeSinceLastCall &lt; 0 修改系统时间时不会出现bug</span></span><br><span class="line">        <span class="keyword">return</span> (lastCallTime === <span class="literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class="line">            (timeSinceLastCall &lt; <span class="number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restart the timer.</span></span><br><span class="line">        timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only invoke if we have `lastArgs` which means `func` has been</span></span><br><span class="line">        <span class="comment">// debounced at least once.</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            cancelTimer(timerId)</span><br><span class="line">        &#125;</span><br><span class="line">        lastInvokeTime = <span class="number">0</span></span><br><span class="line">        lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = <span class="keyword">this</span></span><br><span class="line">        lastCallTime = time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">                <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">                timerId = startTimer(timerExpired, wait)</span><br><span class="line">                <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timerId = startTimer(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = <span class="string">'leading'</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。&lt;/p&gt;
    
    </summary>
    
      <category term="yangfan" scheme="http://xgfe.github.io/categories/yangfan/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="debounce&amp;throttle" scheme="http://xgfe.github.io/tags/debounce-throttle/"/>
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
