<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2019-07-21T03:09:06.154Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 着色器 tint</title>
    <link href="http://xgfe.github.io/2019/07/04/chenluan/tint/"/>
    <id>http://xgfe.github.io/2019/07/04/chenluan/tint/</id>
    <published>2019-07-04T05:08:30.000Z</published>
    <updated>2019-07-21T03:09:06.154Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>假设我们想实现一种效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/target.png" alt=""></p><p>不怎么友好的做法是让设计师给五张资源图，然后依次排列五个对应的 ImageView。这种做法是存在一些问题的，apk 包体积增加了五张图的大小；程序运行时内存增加了五张图的大小。</p><p>这时，我们就可以考虑使用着色器来简单快捷高效地实现这个效果了。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>在 drawable 中导入一张资源图，导入的这张图本身的颜色不用太在意，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/icon.png" alt=""></p><p>在布局中配置 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中关键点即是 <strong>android:tint</strong>，这里配置多个 ImageView，<strong>tint</strong> 配置不同的颜色值，就达到了我们的目的，而且没有前述的弊端。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="Paint-amp-ColorFilter"><a href="#Paint-amp-ColorFilter" class="headerlink" title="Paint &amp; ColorFilter"></a>Paint &amp; ColorFilter</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorFilter" target="_blank" rel="noopener">ColorFilter</a><br>颜色过滤器，通过 Paint.setColorFilter 修改渲染某个像素时的颜色值，ColorFilter 有如下一些子类，后续着重介绍一下 PorterDuffColorFilter。</p><h3 id="BlendModeColorFilter"><a href="#BlendModeColorFilter" class="headerlink" title="BlendModeColorFilter"></a>BlendModeColorFilter</h3><p>混合模式，在 API Level 29 中添加的，类似于 Android 原生的 PorterDuffXferMode，在 Flutter、CSS中都有一些体现。</p><h3 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h3><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/ColorMatrix.html" target="_blank" rel="noopener">ColorMatrix</a><br>通过一个 4x5 的矩阵与颜色 [R, G, B, A] 进行矩阵乘积，得到目标颜色值，可以调整亮度、饱和度、色调等来实现类似 PS 中的滤镜效果，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/color_matrix.png" alt=""></p><h3 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h3><p>通过颜色的相乘与相加，模拟简单的光照效果。</p><h3 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h3><p>使用一个颜色和 PorterDuff 模式对目标进行染色。</p><h4 id="PorterDuff-Mode"><a href="#PorterDuff-Mode" class="headerlink" title="PorterDuff.Mode"></a>PorterDuff.Mode</h4><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html" target="_blank" rel="noopener">PorterDuff.Mode</a><br>假设存在两个形状 SRC 和 DST，其中带颜色的区域的像素点 alpha = 1; color = [red|blue]，其它区域像素点 alpha = 0; color = 0，则它们叠加相交得到 ABCD 4个区，如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/composite.png" alt=""></p><p>通过对 SRC 和 DST 图中的像素值 ARGB 进行数学运算，得到一些裁剪混合叠加效果，展示其中三个如下：<br><img src="https://raw.githubusercontent.com/bayoh36/images/master/android-tint/effect.png" alt=""></p><p>其中每种模式都有对应的数学公式进行运算，例如 SRC_ATOP 的计算方式，如下：<br>alpha_out = alpha_dst<br>color_out = alpha_dst * color_src + (1 - alpha_src) * color_dst</p><p>对于 AD 区，alpha 的运算结果采用了 DST 的 alpha = 0，所以 AD 区是可不见的，BC 区是可见的，最终结果在形状上表现为 DST 的样子，所以 AD 区的颜色也就没有必要计算了。</p><p>对于 B 区的颜色，如下：<br>color_out = 1 * 0 + (1 - 0) * red = red</p><p>对于 C 区的颜色，如下：<br>color_out = 1 * blue + (1 - 1) * red = blue</p><p>最终分析结果与前述图片表现一致。其它种类模式的公式可以参考 Android Developer。</p><h2 id="BitmapDrawable-setTintList"><a href="#BitmapDrawable-setTintList" class="headerlink" title="BitmapDrawable.setTintList"></a>BitmapDrawable.setTintList</h2><p>参考 Android Developer：<a href="https://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank" rel="noopener">BitmapDrawable</a></p><p>这个方法是在 API Level 21 中添加的，将一个颜色 ColorStateList 设置给 mTintFilter 变量，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PorterDuffColorFilter mTintFilter;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapState state = mBitmapState;</span><br><span class="line">    <span class="keyword">if</span> (state.mTint != tint) &#123;</span><br><span class="line">        state.mTint = tint;</span><br><span class="line">        mTintFilter = updateTintFilter(mTintFilter, tint, mBitmapState.mTintMode);</span><br><span class="line">        invalidateSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在渲染的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clearColorFilter;</span><br><span class="line">    <span class="keyword">if</span> (mTintFilter != <span class="keyword">null</span> &amp;&amp; paint.getColorFilter() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paint.setColorFilter(mTintFilter);</span><br><span class="line">        clearColorFilter = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearColorFilter = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将这个 PorterDuffColorFilter 交给了 Paint 进行处理。</p><h2 id="ImageView-tint"><a href="#ImageView-tint" class="headerlink" title="ImageView_tint"></a>ImageView_tint</h2><p>ImageView 在使用 tint 属性的时候，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyImageTint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span> &amp;&amp; (mHasDrawableTint || mHasDrawableTintMode)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTint) &#123;</span><br><span class="line">            mDrawable.setTintList(mDrawableTintList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHasDrawableTintMode) &#123;</span><br><span class="line">            mDrawable.setTintMode(mDrawableTintMode);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们从 ImageView 的 tint 属性到 Paint 的使用，过程如下：</p><ul><li>ImageView 读取到 tint 属性之后，将 tint color 和 tint mode 设置给 Drawable</li><li>Drawable 将 tint color 和 tint mode 组装成 PorterDuffColorFilter</li><li>Drawable 在渲染的时候，将 PorterDuffColorFilter 设置给 Paint</li><li>Paint 将效果应用到画布上</li></ul><h2 id="ImageView-tintMode"><a href="#ImageView-tintMode" class="headerlink" title="ImageView_tintMode"></a>ImageView_tintMode</h2><p>ImageView 在使用 tint 属性的时候，也可以配置 tintMode 属性，如下：</p><ul><li>add</li><li>multiply</li><li>screen</li><li>src_atop</li><li>src_in</li><li>src_over</li></ul><p>Drawable 的默认 tint mode 是 SRC_IN，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> PorterDuff.Mode DEFAULT_TINT_MODE = PorterDuff.Mode.SRC_IN;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ImageView 的默认 tint mode 是 SRC_ATOP，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tint)) &#123;</span><br><span class="line">    mDrawableTintList = a.getColorStateList(R.styleable.ImageView_tint);</span><br><span class="line">    mHasDrawableTint = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prior to L, this attribute would always set a color filter with</span></span><br><span class="line">    <span class="comment">// blending mode SRC_ATOP. Preserve that default behavior.</span></span><br><span class="line">    mDrawableTintMode = PorterDuff.Mode.SRC_ATOP;</span><br><span class="line">    mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 PorterDuff 对应的 SRC 默认是一个铺满 DST 宽高的颜色值，所以 SRC_IN 和 SRC_ATOP 效果上是一样的。<br>布局 xml 中只提供了6中模式，若想使用其它 PorterDuff 模式也可以，需要用 Java 代码去实现。</p><h1 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h1><h2 id="Drawable-setTintList"><a href="#Drawable-setTintList" class="headerlink" title="Drawable.setTintList"></a>Drawable.setTintList</h2><p>tint 不仅仅只是 BitmapDrawable 可以使用，setTintList 在 API Level 21 中被添加到 Drawable 中，所以 Drawable 子类都可以使用，如下：</p><ul><li>BitmapDrawable</li><li>NinePatchDrawable</li><li>LayerDrawable</li><li>StateListDrawable</li><li>LevelListDrawable</li><li>TransitionDrawable</li><li>InsetDrawable</li><li>ClipDrawable</li><li>ScaleDrawable</li><li>ShapeDrawable</li><li>GradientDrawable</li><li>AnimationDrawable</li><li>VectorDrawable</li></ul><p>其中有一些 Drawable 可以在布局 xml 中配置 tint，如下：</p><p>BitmapDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NinePatchDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nine-patch</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nine-patch</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>ShapeDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>VectorDrawable<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="ColorStateList"><a href="#ColorStateList" class="headerlink" title="ColorStateList"></a>ColorStateList</h2><p>我们可以在 xml 中配置一个 ColorStateList，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#FF0000"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后将这个 ColorStateList 设置给 ImageView，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"@color/state_color"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样当这个 ImageView 被点击的时候，颜色就可以被改变。</p><p>当然还有一种方式可以实现这种效果，使用 xml 配置两个 bitmap，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@drawable/icon"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#FF0000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bitmap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后配置一个 selector，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_pressed"</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon_normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>随后将这个 selector 设置给 ImageView。这种方式占用了更多的内存，因为 BitmapDrawable 在 inflate 的时候直接从输入流读取文件的，没有进行图片重用，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.inflate(r, parser, attrs, theme);</span><br><span class="line">        ...</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = r.openRawResource(srcResId, value)) &#123;</span><br><span class="line">            bitmap = BitmapFactory.decodeResourceStream(r, value, is, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing and pick up the error below.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>基于前述几种使用方式，我们就可以将 LevelListDrawable、LayerDrawable、StateListDrawable、BitmapDrawable 组合在一起，这就可以有无限的组合方式了。</p><h2 id="在-View-中配置-tint"><a href="#在-View-中配置-tint" class="headerlink" title="在 View 中配置 tint"></a>在 View 中配置 tint</h2><p>除了前述 ImageView 中可以配置 tint 外，View 也可以对前景和背景配置 tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:backgroundTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:foregroundTint</span>=<span class="string">"#00FF00"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>TextView 也可以配置 drawable tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>CompoundButton 也可以配置 button tint，所以 CheckBox、RadioButton 等也可以配置 button tint，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawableTint</span>=<span class="string">"#FF0000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:buttonTint</span>=<span class="string">"#FF0000"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Compatible"><a href="#Compatible" class="headerlink" title="Compatible"></a>Compatible</h2><h3 id="ViewCompat"><a href="#ViewCompat" class="headerlink" title="ViewCompat"></a>ViewCompat</h3><p>由于 API Level 21 才开始支持 background tint 在 xml 中配置，可以使用 ViewCompat.setBackgroundTintList 和 ViewCompat.setBackgroundTintMode 进行兼容。</p><p>如果我们想在自定义 View 中也实现 tint 的一些特性，可以让自定义 View 实现 TintableBackgroundView 接口，然后调用 ViewCompat.setBackgroundTintList 进行设置，这样就能对 API Level 21 之前的版本进行兼容。</p><p>ViewCompat 的相关实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewCompatBaseImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi26Impl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatApi24Impl();</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewCompatBaseImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">    IMPL.setBackgroundTintList(view, tintList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatApi21Impl</span> <span class="keyword">extends</span> <span class="title">ViewCompatApi19Impl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        view.setBackgroundTintList(tintList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT == <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="comment">// Work around a bug in L that did not update the state of the background</span></span><br><span class="line">            <span class="comment">// after applying the tint</span></span><br><span class="line">            Drawable background = view.getBackground();</span><br><span class="line">            <span class="keyword">boolean</span> hasTint = (view.getBackgroundTintList() != <span class="keyword">null</span>)</span><br><span class="line">                    &amp;&amp; (view.getBackgroundTintMode() != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((background != <span class="keyword">null</span>) &amp;&amp; hasTint) &#123;</span><br><span class="line">                <span class="keyword">if</span> (background.isStateful()) &#123;</span><br><span class="line">                    background.setState(view.getDrawableState());</span><br><span class="line">                &#125;</span><br><span class="line">                view.setBackground(background);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewCompatBaseImpl</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundTintList</span><span class="params">(View view, ColorStateList tintList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> TintableBackgroundView) &#123;</span><br><span class="line">            ((TintableBackgroundView) view).setSupportBackgroundTintList(tintList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DrawableCompat"><a href="#DrawableCompat" class="headerlink" title="DrawableCompat"></a>DrawableCompat</h3><p>由于 API Level 21 才开始支持对 drawable 设置 tint，可以使用 DrawableCompat.setTintList，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTintList</span><span class="params">(@NonNull Drawable drawable, @Nullable ColorStateList tint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        drawable.setTintList(tint);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> TintAwareDrawable) &#123;</span><br><span class="line">        ((TintAwareDrawable)drawable).setTintList(tint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 DrawableCompat.wrap 对 drawable 进行包装兼容，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">wrap</span><span class="params">(@NonNull Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi21(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi19(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(drawable <span class="keyword">instanceof</span> TintAwareDrawable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DrawableWrapperApi14(drawable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>多图并列显示，用颜色来区分类别，图的形状是一样的</li><li>简单的按钮普通、按下、置灰等状态切换</li><li>换肤换主题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了 Android 着色器的使用及其原理，在实现同等效果的情况下，减少资源图的使用以减小 apk 包的体积并降低对内存的占用。&lt;/p&gt;
    
    </summary>
    
      <category term="chenluan" scheme="http://xgfe.github.io/categories/chenluan/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="tint" scheme="http://xgfe.github.io/tags/tint/"/>
    
  </entry>
  
  <entry>
    <title>非原生 ROM 的 Crash 问题通用排查方法</title>
    <link href="http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/"/>
    <id>http://xgfe.github.io/2019/06/17/leidiqiu/resolve-non-google-rom-crash/</id>
    <published>2019-06-17T08:28:30.000Z</published>
    <updated>2019-06-18T03:58:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。</p><a id="more"></a><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>日常清理 Crash 时，遇到一些空指针异常的问题，每天不多，但是日积月累，数量并不少，堆栈信息如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">'java.lang.Class java.lang.Object.getClass()'</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">at android.os.Message.toStringLite(Message.java:<span class="number">507</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">221</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">5809</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">372</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">1113</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">879</span>)</span><br></pre></td></tr></table></figure></p><p>翻看 android.os.Message 的源代码，并没有 toStringLite() 这个函数，显然，这是手机厂商修改了原生 ROM，自己加上的。如何跟进此类适配性问题呢？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>此类 ROM 相关问题无法修复，只能从 App 的代码调用端进行适配，类似 H5 页面适配各种浏览器一样。所以，主要问题在于找出非原生 ROM 的执行逻辑，从而想办法避免 Crash。那么，如何发掘里面的执行逻辑呢？</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>初步考虑，通过 ClassLoader 动态导出具体的 class 类，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            InputStream inputStream = classLoader.getResourceAsStream(<span class="string">"java/util/List.class"</span>);</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"List.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileOutputStream.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法对 Java 是适用的，但是在 Android 中并不适用。</p><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>既然动态方法不行，考虑静态方法，毕竟在手机 ROM 中，必然有对应的文件。</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>首先，通过 Crash 平台的附加信息，找到手机的型号、版本「型号：OPPO R9tm，版本：5.1」，找一台同型号、同版本的手机「美团有云真机平台，上面的手机种类繁多」，连上 adb。</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>把 boot.oat 文件从手机 pull 下来，boot.oat 包含启动相关的代码，可理解为里面有优化过的 framework.jar 文件，对应 SDK 的 android.jar 文件，文件较大，有 85M 左右。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ adb -s 172.18.92.198:44429 pull /system/framework/arm64/boot.oat .</span><br><span class="line">/system/framework/arm64/boot.oat: 1 file pulled. 0.4 MB/s (85477748 bytes <span class="keyword">in</span> 229.612s)</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ ls -l boot.oat </span><br><span class="line">-rw-r--r--  1 leidiqiu  staff  85477748 May  8 16:17 boot.oat</span><br></pre></td></tr></table></figure></p><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>下载 <a href="https://github.com/testwhat/SmaliEx/releases/download/0.86/oat2dex.jar" target="_blank" rel="noopener">oat2dex.jar</a> 工具，并将 oat 文件转换成 dex 文件，会生成 odex、dex 两个文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ java -jar ~/libs/oat2dex.jar boot boot.oat </span><br><span class="line">05-08 16:23:27:465 Output raw dex: /Users/leidiqiu/Desktop/odex/core-libart.dex</span><br><span class="line">05-08 16:23:27:466 Output raw dex: /Users/leidiqiu/Desktop/odex/conscrypt.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/okhttp.dex</span><br><span class="line">05-08 16:23:27:467 Output raw dex: /Users/leidiqiu/Desktop/odex/core-junit.dex</span><br><span class="line">05-08 16:23:27:469 Output raw dex: /Users/leidiqiu/Desktop/odex/bouncycastle.dex</span><br><span class="line">05-08 16:23:27:472 Output raw dex: /Users/leidiqiu/Desktop/odex/ext.dex</span><br><span class="line">05-08 16:23:27:488 Output raw dex: /Users/leidiqiu/Desktop/odex/framework.dex</span><br><span class="line">05-08 16:23:27:503 Output raw dex: /Users/leidiqiu/Desktop/odex/framework-classes2.dex</span><br><span class="line">05-08 16:23:27:511 Output raw dex: /Users/leidiqiu/Desktop/odex/telephony-common.dex</span><br><span class="line">05-08 16:23:27:512 Output raw dex: /Users/leidiqiu/Desktop/odex/voip-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/ims-common.dex</span><br><span class="line">05-08 16:23:27:516 Output raw dex: /Users/leidiqiu/Desktop/odex/mms-common.dex</span><br><span class="line">05-08 16:23:27:517 Output raw dex: /Users/leidiqiu/Desktop/odex/android.policy.dex</span><br><span class="line">05-08 16:23:27:523 Output raw dex: /Users/leidiqiu/Desktop/odex/apache-xml.dex</span><br><span class="line">05-08 16:23:27:529 Output raw dex: /Users/leidiqiu/Desktop/odex/oppo-framework.dex</span><br><span class="line">05-08 16:23:27:530 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-common.dex</span><br><span class="line">05-08 16:23:27:531 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:27:532 Output raw dex: /Users/leidiqiu/Desktop/odex/mediatek-telephony-common.dex</span><br><span class="line">05-08 16:23:27:786 De-optimizing /system/framework/core-libart.jar</span><br><span class="line">05-08 16:23:30:094 Output to /Users/leidiqiu/Desktop/dex/core-libart.dex</span><br><span class="line">05-08 16:23:30:094 De-optimizing /system/framework/conscrypt.jar</span><br><span class="line">05-08 16:23:30:208 Output to /Users/leidiqiu/Desktop/dex/conscrypt.dex</span><br><span class="line">05-08 16:23:30:208 De-optimizing /system/framework/okhttp.jar</span><br><span class="line">05-08 16:23:30:356 Output to /Users/leidiqiu/Desktop/dex/okhttp.dex</span><br><span class="line">05-08 16:23:30:356 De-optimizing /system/framework/core-junit.jar</span><br><span class="line">05-08 16:23:30:371 Output to /Users/leidiqiu/Desktop/dex/core-junit.dex</span><br><span class="line">05-08 16:23:30:371 De-optimizing /system/framework/bouncycastle.jar</span><br><span class="line">05-08 16:23:30:928 Output to /Users/leidiqiu/Desktop/dex/bouncycastle.dex</span><br><span class="line">05-08 16:23:30:928 De-optimizing /system/framework/ext.jar</span><br><span class="line">05-08 16:23:31:483 Output to /Users/leidiqiu/Desktop/dex/ext.dex</span><br><span class="line">05-08 16:23:31:483 De-optimizing /system/framework/framework.jar</span><br><span class="line">05-08 16:23:36:301 Output to /Users/leidiqiu/Desktop/dex/framework.dex</span><br><span class="line">05-08 16:23:36:301 De-optimizing /system/framework/framework.jar:classes2.dex</span><br><span class="line">05-08 16:23:38:611 Output to /Users/leidiqiu/Desktop/dex/framework-classes2.dex</span><br><span class="line">05-08 16:23:38:611 De-optimizing /system/framework/telephony-common.jar</span><br><span class="line">05-08 16:23:40:395 Output to /Users/leidiqiu/Desktop/dex/telephony-common.dex</span><br><span class="line">05-08 16:23:40:395 De-optimizing /system/framework/voip-common.jar</span><br><span class="line">05-08 16:23:40:440 Output to /Users/leidiqiu/Desktop/dex/voip-common.dex</span><br><span class="line">05-08 16:23:40:440 De-optimizing /system/framework/ims-common.jar</span><br><span class="line">05-08 16:23:40:625 Output to /Users/leidiqiu/Desktop/dex/ims-common.dex</span><br><span class="line">05-08 16:23:40:625 De-optimizing /system/framework/mms-common.jar</span><br><span class="line">05-08 16:23:40:626 Output to /Users/leidiqiu/Desktop/dex/mms-common.dex</span><br><span class="line">05-08 16:23:40:626 De-optimizing /system/framework/android.policy.jar</span><br><span class="line">05-08 16:23:40:764 Output to /Users/leidiqiu/Desktop/dex/android.policy.dex</span><br><span class="line">05-08 16:23:40:764 De-optimizing /system/framework/apache-xml.jar</span><br><span class="line">05-08 16:23:41:178 Output to /Users/leidiqiu/Desktop/dex/apache-xml.dex</span><br><span class="line">05-08 16:23:41:178 De-optimizing /system/framework/oppo-framework.jar</span><br><span class="line">05-08 16:23:41:613 Output to /Users/leidiqiu/Desktop/dex/oppo-framework.dex</span><br><span class="line">05-08 16:23:41:613 De-optimizing /system/framework/mediatek-common.jar</span><br><span class="line">05-08 16:23:41:660 Output to /Users/leidiqiu/Desktop/dex/mediatek-common.dex</span><br><span class="line">05-08 16:23:41:660 De-optimizing /system/framework/mediatek-framework.jar</span><br><span class="line">05-08 16:23:41:889 Output to /Users/leidiqiu/Desktop/dex/mediatek-framework.dex</span><br><span class="line">05-08 16:23:41:889 De-optimizing /system/framework/mediatek-telephony-common.jar</span><br><span class="line">05-08 16:23:41:891 Output to /Users/leidiqiu/Desktop/dex/mediatek-telephony-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>查看 dex 文件夹，发现有 framework.dex 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop $ <span class="built_in">cd</span> dex/</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ ls</span><br><span class="line">android.policy.dex            ext.dex                       mediatek-telephony-common.dex</span><br><span class="line">apache-xml.dex                framework-classes2.dex        mms-common.dex</span><br><span class="line">bouncycastle.dex              framework.dex                 okhttp.dex</span><br><span class="line">conscrypt.dex                 ims-common.dex                oppo-framework.dex</span><br><span class="line">core-junit.dex                mediatek-common.dex           telephony-common.dex</span><br><span class="line">core-libart.dex               mediatek-framework.dex        voip-common.dex</span><br></pre></td></tr></table></figure></p><h3 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h3><p>下载 <a href="https://sourceforge.net/projects/dex2jar/files/dex2jar-2.0.zip/download" target="_blank" rel="noopener">dex2jar-2.0.zip</a> 工具，将 dex 转成 jar，并用 JD-GUI 打开，JD-GUI 下载地址：<a href="http://java-decompiler.github.io/。" target="_blank" rel="noopener">http://java-decompiler.github.io/。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ dex2jar.sh framework.dex </span><br><span class="line">dex2jar framework.dex -&gt; ./framework-dex2jar.jar</span><br><span class="line">Detail Error Information <span class="keyword">in</span> File ./framework-error.zip</span><br><span class="line">Please report this file to http://code.google.com/p/dex2jar/issues/entry <span class="keyword">if</span> possible.</span><br><span class="line">[leidiqiu@leidiqiu: ] ~/Desktop/dex $ open framework-dex2jar.jar -a JD-GUI.app</span><br></pre></td></tr></table></figure></p><h3 id="步骤六"><a href="#步骤六" class="headerlink" title="步骤六"></a>步骤六</h3><p>通过 JD-GUI 查看，终于找到了 Message 类，里面确实有 toStringLite() 方法。<br><img src="http://s3plus.sankuai.com/v1/mss_7fabbc64efb346df9722fadcafbc20bc/blog/Message.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此类方法相对通用，对定位非原生 ROM 的问题很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常 Crash 治理过程中，经常会遇到一些比较难排查的问题，比如，Crash 堆栈信息中出现了一些本不应该出现的函数，这些函数其实是手机厂商修改了 Google 的原生 ROM，自己添加进去的。本文介绍了一种定位和排查非原生 ROM 的 Crash 问题的通用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="leidiqiu" scheme="http://xgfe.github.io/categories/leidiqiu/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Crash" scheme="http://xgfe.github.io/tags/Crash/"/>
    
      <category term="非原生ROM" scheme="http://xgfe.github.io/tags/%E9%9D%9E%E5%8E%9F%E7%94%9FROM/"/>
    
  </entry>
  
  <entry>
    <title>类Redux的数据中间层的实现</title>
    <link href="http://xgfe.github.io/2019/05/26/yangziyao/%E7%B1%BBRedux%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E9%97%B4%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2019/05/26/yangziyao/类Redux的数据中间层实现/</id>
    <published>2019-05-26T02:00:00.000Z</published>
    <updated>2019-06-14T07:34:42.521Z</updated>
    
    <content type="html"><![CDATA[<p>关于全局单向数据流+视图层computed属性的一个简单实现。</p><a id="more"></a><h1 id="数据中间层简介"><a href="#数据中间层简介" class="headerlink" title="数据中间层简介"></a>数据中间层简介</h1><p>在上家公司工作时，由于使用自研框架比较陈旧，不支持全局的跨视图的数据复用。又由于当时react的BSD+Patents证书事件，团队决定放弃引入开源……于是就自己造了一个支持单向数据流的轮子，就是本文介绍的数据中间层。在视图数据层面，也实现了类似vue的computed属性来优化开发体验。</p><h1 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h1><p><img src="https://github.com/zero-yang/assets/blob/master/data-midware.png?raw=true" alt=""></p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store模块负责存储全局数据和定义操作数据的actions。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel模块负责维护视图自身的数据，接收来自Store的change事件以响应Store数据变更，通过dispatch action操作Store中的数据。</p><h2 id="Updater"><a href="#Updater" class="headerlink" title="Updater"></a>Updater</h2><p>Updater模块定义了数据的操作，包括set，get，assign等，可以通过指定数据源对Store或者ViewModel的实例进行操作。同时也定义了dispatch操作。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>由于这是一年半前写的代码，还有种种原因不方便透露源码，这里只介绍主要的实现思路，具体实现还需要考虑很多边界场景，这里就不细说了。</p><h2 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h2><p>Store的代码实现很简单，主要包含存储数据的对象，定义action对象的数组，以及注册action的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = &#123;</span><br><span class="line">    state: &#123;&#125;, </span><br><span class="line">    actions: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'setFormData'</span>,</span><br><span class="line">            <span class="keyword">async</span> method() &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    addAction(actionList) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions.concat(actionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，action对象中的name类似于redux中的常量，method类似于reducer，可以是异步方法。不同业务模块的action可以维护在独立的模块中，通过Store.addAction注册到Store中。</p><h2 id="Updater-1"><a href="#Updater-1" class="headerlink" title="Updater"></a>Updater</h2><p>Updater负责数据的操作和不同数据实体间的交互，是三个模块中最核心的模块。包含了数据操作的set，get和assign，处理action的dispatch。还有一个buildFactory方法，是为了保证在执行action的过程中对Store数据操作的原子性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Updater = &#123;</span><br><span class="line">    find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    assign(source, path, value) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(source, path, value) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get(source, path) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    buildFactory(source) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍这几个方法。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>对指定数据源和路径进行查找，返回对应字段的父级和对应字段的key，可指定路径中的属性不存在是否创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find(source = &#123;&#125;, path, create) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = path.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tmp.length - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = source[tmp[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!next &amp;&amp; create) &#123;</span><br><span class="line">            source[tmp[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source = next || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        key: tmp[tmp.length - <span class="number">1</span>],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设置指定数据源对应路径的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(source, path, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> setObj = <span class="keyword">this</span>.find(source, path, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    setObj.source[setObj.key] = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>跟set类似，只不过是将赋值变成对象合并。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取指定数据源对应路径的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get(source, path) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.find(source, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.source[result.key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>执行action，在执行完成后触发storeChange事件。为了保证action对Store写操作的原子性，在执行action过程中，将所有写操作先以指令的形式储存在通过buildFactory方法创建的一个factory里，再一次性进行写入操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> dispatch(source, action) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = <span class="keyword">this</span>.buildFactory(source);</span><br><span class="line">    <span class="keyword">const</span> handler = Store.actions[action];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> handler(factory.get, factory.set, factory.assign);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> diff = factory.applyDirective();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (diff.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Event.emit(<span class="string">'storeChange'</span>, &#123;</span><br><span class="line">            diff</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buildFactory"><a href="#buildFactory" class="headerlink" title="buildFactory"></a>buildFactory</h3><p>创建指令工厂对象，提供所有Store写操作的mock方法，mock方法将所有操作以指令形式保存在fatory里，通过applyDirective方法一次执行，并返回操作的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buildFactory(source) &#123;</span><br><span class="line">    <span class="keyword">const</span> factory = &#123;</span><br><span class="line">        directives: [],</span><br><span class="line">        source</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="string">'set'</span>, <span class="string">'assign'</span>].reduce(<span class="function">(<span class="params">fac, key</span>) =&gt;</span> &#123;</span><br><span class="line">        fac[key] = <span class="function">(<span class="params">path, value</span>) =&gt;</span> &#123;</span><br><span class="line">            fac.directives.push(&#123;</span><br><span class="line">                type: key,</span><br><span class="line">                path,</span><br><span class="line">                value</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, factory);</span><br><span class="line"></span><br><span class="line">    factory.get = <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(factory.source, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    factory.applyDirective = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> diff = [];</span><br><span class="line"></span><br><span class="line">        factory.directives.forEach(<span class="function"><span class="params">directive</span> =&gt;</span> &#123;</span><br><span class="line">           diff = diff.concat(<span class="keyword">this</span>[directive[key]](factory.source, directive[path], directive[value]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewModel-1"><a href="#ViewModel-1" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel负责维护视图的数据，提供了类似vue的computed属性，并通过computed属性维护ViewModel实例到Store的数据依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    calDiff(diffFromStore) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    initComputed() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(path, value) &#123;</span><br><span class="line">    Updater.set(<span class="keyword">this</span>.state, path, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    get(path) &#123;</span><br><span class="line">    Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>监听storeChange事件，根据diff计算自身的数据变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    Event.on(<span class="string">'storeChange'</span>, diff =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'change'</span>, <span class="keyword">this</span>.calDiff(diff));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><p>初始化computed属性，建立computed属性对自身数据字段以及Store数据字段的依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">initComputed() &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.computed).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.computed[key](</span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从自身state里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.__bindWithState__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithState__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithState__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(<span class="keyword">this</span>.state, path);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            path =&gt; &#123;</span><br><span class="line">                <span class="comment">//从全局store里获取数据方法</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.__bindWithStore__[path]) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.__bindWithStore__[path] = [];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.__bindWithStore__[path].push(key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Updater.get(store, path);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="calDiff"><a href="#calDiff" class="headerlink" title="calDiff"></a>calDiff</h3><p>根据Store数据的diff计算自身数据的变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">calDiff(diffFromStore) &#123;</span><br><span class="line">    <span class="keyword">let</span> stateDiff = [];</span><br><span class="line"></span><br><span class="line">    diffFromStore.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithStore__[diffPath]) &#123;</span><br><span class="line">            stateDiff = stateDiff.concat(<span class="keyword">this</span>.__bindWithStore__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> diffDueToState = [];</span><br><span class="line"></span><br><span class="line">    stateDiff.forEach(<span class="function"><span class="params">diffPath</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.__bindWithState__[diffPath]) &#123;</span><br><span class="line">            diffDueToState = diffDueToState.concat(<span class="keyword">this</span>.__bindWithState__[diffPath]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(stateDiff.concat(diffDueToState)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环依赖检测"><a href="#环依赖检测" class="headerlink" title="环依赖检测"></a>环依赖检测</h3><p>为了避免在computed属性里遇到环依赖的情况，因此需要一个环依赖检测的方法。depTree为ViewModel实例里的<strong>bindWithStore</strong>或者<strong>bindWithState</strong>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleDetection</span>(<span class="params">depTree</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="built_in">Object</span>.keys(depTree);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doDetection</span>(<span class="params">node, parentSet</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> deps = depTree[node];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!deps || deps.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">const</span> depNode = deps[i];</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (parentSet.has(depNode)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> doDetection(depNode, parentSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; root.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> pSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> rNode = root[i];</span><br><span class="line"></span><br><span class="line">        pSet.add(rNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!doDetection(rNode, pSet)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>注册业务相关的action：/entity/bidword.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'common/store'</span>;</span><br><span class="line"></span><br><span class="line">Store.addAction([&#123;</span><br><span class="line">name: <span class="string">'fetchBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method(get, set, assign) &#123;</span><br><span class="line"><span class="keyword">let</span> list;</span><br><span class="line"><span class="comment">// fetch list</span></span><br><span class="line"></span><br><span class="line">set(<span class="string">'bidword/list'</span>, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">'addBidword'</span>,</span><br><span class="line"><span class="keyword">async</span> method() &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>视图viewModel：/bidword/bidword-vm.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ViewModel <span class="keyword">from</span> <span class="string">'common/view-model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BidwordVM</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">computed = &#123;</span><br><span class="line">displayList(get, getFromStore) &#123;</span><br><span class="line"><span class="keyword">const</span> list = getFromStore(<span class="string">'bidword/list'</span>);</span><br><span class="line"><span class="keyword">const</span> date = get(<span class="string">'theDate'</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">item.date = date;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> init() &#123;</span><br><span class="line"><span class="keyword">this</span>.set(<span class="string">'date'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toDateString());</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.dispatch(<span class="string">'fetchBidword'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结束，页面开始渲染</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图文件view：/bidword/bidword.js</p><p>通过一个connect组件绑定视图和viewModel，connect负责维护view和viewModel实例的生命周期，具体细节这里就不赘述了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> connect <span class="keyword">from</span> <span class="string">'common/connect'</span>;</span><br><span class="line"><span class="keyword">import</span> BidwordVM <span class="keyword">from</span> <span class="string">'./bidword-vm'</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'common/base-view'</span>;</span><br><span class="line"></span><br><span class="line">@connect(BidwordVM)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bidword</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Bidword;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是数据中间层实现的一个大致的思路，希望能对大家有帮助，有问题欢迎指正~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于全局单向数据流+视图层computed属性的一个简单实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangziyao" scheme="http://xgfe.github.io/categories/yangziyao/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2019/04/16/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2019/04/16/zhangpeng/宏任务和微任务/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.258Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。</p><a id="more"></a><h2 id="一、宏任务和微任务"><a href="#一、宏任务和微任务" class="headerlink" title="一、宏任务和微任务"></a>一、宏任务和微任务</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收。</li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><p>微任务：</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br> 事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。</p><p> 事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br> 从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。</p><p> 当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br> 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br> 因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。</p><p> 所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br> 浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br> 现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，</span><br><span class="line">如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，</span><br><span class="line">在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，</span><br><span class="line">且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，</span><br><span class="line">反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，</span><br><span class="line">用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，</span><br><span class="line">可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，</span><br><span class="line">我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms，</span><br><span class="line">第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，</span><br><span class="line">并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。</span><br><span class="line">记住，一个任务一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，</span><br><span class="line">等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，</span><br><span class="line">等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line"></span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，</span><br><span class="line">任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，</span><br><span class="line">UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line"></span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，</span><br><span class="line">secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，</span><br><span class="line">接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，</span><br><span class="line">浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms，</span><br><span class="line">执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，</span><br><span class="line">但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms。</span><br><span class="line"></span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms。</span><br><span class="line"></span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。</span><br><span class="line">因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line"></span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，</span><br><span class="line">但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，</span><br><span class="line">需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line"></span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，</span><br><span class="line">单击firstButton和secondButton按钮这两个任务处于等待状态，</span><br><span class="line">但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，</span><br><span class="line">此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，</span><br><span class="line">若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，</span><br><span class="line">处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，</span><br><span class="line">此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，</span><br><span class="line">第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，</span><br><span class="line">此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，</span><br><span class="line">在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，</span><br><span class="line">添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，</span><br><span class="line">微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，</span><br><span class="line">事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line"></span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，</span><br><span class="line">在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line"></span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。</span><br><span class="line">可以在主线程和第一个按钮单击任务之间重新渲染页面，</span><br><span class="line">但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，</span><br><span class="line">所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，</span><br><span class="line">事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意。</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，<br>将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，<br>在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，</span><br><span class="line">发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.</span><br><span class="line">计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标。</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line"></span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。</span><br><span class="line">新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，</span><br><span class="line">该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，</span><br><span class="line">计时器事件与input输入框的输入事件类似，都会被添加到队列中。</span><br><span class="line">注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，</span><br><span class="line">因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，</span><br><span class="line">3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，</span><br><span class="line">这意味着单击事件处理器开始执行，setTimeout函数只到期一次，</span><br><span class="line">setInterval函数则不同，setTnterval会持续执行到被清除，</span><br><span class="line">因此，在第20ms的时候，setInterval又一次触发，</span><br><span class="line">但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发。</span><br><span class="line">但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，</span><br><span class="line">第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line"></span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，</span><br><span class="line">至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，</span><br><span class="line">而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，</span><br><span class="line">但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，</span><br><span class="line">因为队列中已经有一个与之相匹配的间隔计时器，</span><br><span class="line">在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，</span><br><span class="line">然后进入下一个事件循环迭代。</span><br><span class="line"></span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,</span><br><span class="line">又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line"></span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，</span><br><span class="line">此时，由于间隔处理器正在执行，不是在队列中等待，</span><br><span class="line">设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，</span><br><span class="line">每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line"></span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，</span><br><span class="line">事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，</span><br><span class="line">间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，</span><br><span class="line">回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>js实现算法之动态规划</title>
    <link href="http://xgfe.github.io/2019/03/25/dengzonghui/%20dynamic/"/>
    <id>http://xgfe.github.io/2019/03/25/dengzonghui/ dynamic/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。</p><a id="more"></a><h2 id="一、经典01背包"><a href="#一、经典01背包" class="headerlink" title="一、经典01背包"></a>一、经典01背包</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>背包容量capacity=5，有三个物品(value, weight)，分别是(3,2),(4,3),(5,4)求出其搭配组合，使得背包内总价最大，且最大价值为多少？</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>如果背包总容量为0，那么很显然地，任何物品都无法装进背包，那么背包内总价值必然是0。所以第一步先填满 j=0 的情况。<br>接下来将从上到下，从左往右地填写这个表格。分析第i行时，它的物品组合仅能是小于等于i的情况。所以现在把注意力定位到 i =0, j = 1 的空格上。<br>i=0 j=1 : 背包总容量为1，但是物品0 的重量为 2，无法装下去，所以这一格应该填 0。<br>i=0 j=2 : 背包总容量为2，刚好可以装下物品0 ，由于物品0 的价值为3，因此这一格填 3。<br>后面同理。<br>i=1 j=1 : 背包总容量为1，但是物品0 的重量为 2，物品1重量为3，背包无法装下任何物品，所以填 0。</p><table><thead><tr><th></th><th>val</th><th>weight</th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th></tr></thead><tbody><tr><td>i=0</td><td>3</td><td>2</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>i=1</td><td>4</td><td>3</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td></tr><tr><td>i=2</td><td>5</td><td>4</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>7</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&gt;w[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = max(T[i-1][j-w[i]]+val[i], T[i-1][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function backpack(w,val,capacity,n)&#123;</span><br><span class="line">    var T = []</span><br><span class="line"></span><br><span class="line">    for(let i = 0;i &lt; n;i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0;j &lt;= capacity;j++)&#123;</span><br><span class="line">            if(j === 0)&#123; //容量为0</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j &lt; w[i])&#123; //容量小于物品重量，本行hold不住</span><br><span class="line">                if(i === 0)&#123;</span><br><span class="line">                    T[i][j] = 0; // i = 0时，不存在i-1，所以T[i][j]取0</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j]; //容量小于物品重量，参照上一行</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i === 0)&#123;</span><br><span class="line">                T[i][j] = val[i]; //第0行，不存在 i-1, 最多只能放这一行的那一个物品</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                T[i][j] = Math.max(val[i] + T[i-1][j-w[i]],T[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findValue(w,val,capacity,n,T);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line">//找到需要的物品</span><br><span class="line">function findValue(w,val,capacity,n,T)&#123;</span><br><span class="line">    var i = n-1, j = capacity;</span><br><span class="line">    while ( i &gt; 0 &amp;&amp; j &gt; 0 )&#123;</span><br><span class="line">        if(T[i][j] != T[i-1][j])&#123;</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">            j = j- w[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i--;  //如果相等，那么就到 i-1 行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == 0 )&#123;</span><br><span class="line">        if(T[i][j] != 0)&#123; //那么第一行的物品也可以取</span><br><span class="line">            console.log(&apos;选择物品&apos;+i+&apos;,重量：&apos;+ w[i] +&apos;,价值：&apos; + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [3,4,5],</span><br><span class="line">weights = [2,3,4],</span><br><span class="line">capacity = 5,</span><br><span class="line">n = values.length;</span><br><span class="line"></span><br><span class="line">console.log(backpack(weights,values,capacity,n));</span><br></pre></td></tr></table></figure><h2 id="二、最少硬币"><a href="#二、最少硬币" class="headerlink" title="二、最少硬币"></a>二、最少硬币</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>4种硬币 1分、2分、5分、6分<br>总共需要11分，求最少的硬币数以及组合</p><h3 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先理清思路列出表格：<br>与经典背包相同，填写第i行表示只能用i和比i小的硬币。硬币数组coins[]，需要的钱数j。<br>当我们只能使用面额为1分的硬币时，根据上面的规则，那么很显然，总额为几分，就需要几个硬币。<br>当我们有1分和2分两种面额时，那么组合方式就相对多了点。<br>i=1 j = 1：总额为1时，只能使用1分的面额。即填1。<br>i=1 j = 2：总额为2时，可以使用2个1分的，也可以使用1个2分的。<br>因为我们要求最少硬币，所以使用1个2分的。表格里填1。<br>以此类推：</p><table><thead><tr><th></th><th>j=0</th><th>j=1</th><th>j=2</th><th>j=3</th><th>j=4</th><th>j=5</th><th>j=6</th><th>j=7</th><th>j=8</th><th>j=9</th><th>j=10</th><th>j=11</th></tr></thead><tbody><tr><td>i=0 1分</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>i=1 2分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>6</td></tr><tr><td>i=2 5分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td><td>3</td></tr><tr><td>i=3 6分</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>2</td></tr></tbody></table><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(j&lt;coins[i])&#123;</span><br><span class="line">    T[i][j] = T[i-1][j]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    T[i][j] = min(T[i-1][j], T[i][j-coins[i]]+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param &#123;number[]&#125; coins</span><br><span class="line">* @param &#123;number&#125; amount</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*/</span><br><span class="line">var coinChange = function(coins, amount) &#123;</span><br><span class="line">    coins.sort((a,b)=&gt;(a-b));</span><br><span class="line">    var T = [];</span><br><span class="line">    for(let i=0; i&lt;coins.length; i++)&#123;</span><br><span class="line">        T[i] = [];</span><br><span class="line">        for(let j=0; j&lt;=amount; j++)&#123;</span><br><span class="line">            T[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;T.length; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;T[i].length; j++)&#123;</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                T[i][j] = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==0)&#123;</span><br><span class="line">                if(Number.isInteger(j/coins[i]))&#123;</span><br><span class="line">                    T[i][j] = j/coins[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Infinity;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(j&lt;coins[i])&#123;</span><br><span class="line">                    T[i][j] = T[i-1][j];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    T[i][j] = Math.min(T[i-1][j], T[i][j-coins[i]]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return T[T.length-1][T[0].length-1]===Infinity?-1:T[T.length-1][T[0].length-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、最大正方形"><a href="#三、最大正方形" class="headerlink" title="三、最大正方形"></a>三、最大正方形</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><h3 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先用例中不一定会给正方形，也可能是长方形，所以必须分别求长和宽。<br>其次如果此点的值是0，则直接将结果设为0；如果此点的值为1，则它等于它左方、上方、左上方三者的最小值+1。<br>最后是需要一个变量max，在遍历的过程中不断修改自身获取dp中的最大值。</p><p><img src="http://p0.meituan.net/xgfe/62e9135edf9a68df2624aba1d50b9582537777.jpg" alt="最大正方形的获取"></p><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;character[][]&#125; matrix</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maximalSquare = function(matrix) &#123;</span><br><span class="line">    let len1 = matrix.length, len2;</span><br><span class="line">    var dp = new Array(len1);//设置长度</span><br><span class="line">    let max = 0;//记录矩阵中最大值</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        len2 = matrix[i].length;</span><br><span class="line">        dp[i] = new Array(len2);</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0; i&lt;len1; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;len2; j++)&#123;</span><br><span class="line">            if(i==0 || j==0)&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;?1:0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] == &apos;1&apos;? (Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1):0;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max*max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、最大加号标志"><a href="#四、最大加号标志" class="headerlink" title="四、最大加号标志"></a>四、最大加号标志</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1. 题目"></a>1. 题目</h3><p>在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。</p><p>一个 k” 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k” 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。</p><p>k 阶轴对称加号标志示例:</p><p>阶 1:<br>000<br>010<br>000</p><p>阶 2:<br>00000<br>00100<br>01110<br>00100<br>00000</p><p>阶 3:<br>0000000<br>0001000<br>0001000<br>0111110<br>0001000<br>0001000<br>0000000</p><p>示例 1：</p><p>输入: N = 5, mines = [[4, 2]]<br>输出: 2<br>解释:</p><p>11111<br>11111<br>11111<br>11111<br>11011</p><p>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</p><p>示例 2：</p><p>输入: N = 2, mines = []<br>输出: 1<br>解释:</p><p>11<br>11</p><p>没有 2 阶加号标志，有 1 阶加号标志。</p><p>示例 3：</p><p>输入: N = 1, mines = [[0, 0]]<br>输出: 0<br>解释:</p><p>0</p><p>没有加号标志，返回 0 。</p><h3 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先要给所有位置设置最大值即边长N。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br></pre></td></tr></table></figure></p><p>循环遍历所有行，从四个方向更新dp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>left right up down注意每遍历一行都要更新为0。</strong></p><h3 id="3-代码-3"><a href="#3-代码-3" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; N</span><br><span class="line"> * @param &#123;number[][]&#125; mines</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var orderOfLargestPlusSign = function(N, mines) &#123;</span><br><span class="line">    let dp = [...Array(N)].map(() =&gt; Array(N).fill(N));</span><br><span class="line">    for(let i=0; i&lt;mines.length; i++)&#123;</span><br><span class="line">        dp[mines[i][0]][mines[i][1]] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    let left, right, up, down;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let l=0, left=0; l&lt;N; l++)&#123;</span><br><span class="line">            dp[i][l] = Math.min(dp[i][l], left = (dp[i][l] == 0 ? 0: left+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let r=N-1, right=0; r&gt;=0; r--)&#123;</span><br><span class="line">            dp[i][r] = Math.min(dp[i][r], right = (dp[i][r] == 0 ? 0: right+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let u=0, up=0; u&lt;N; u++)&#123;</span><br><span class="line">            dp[u][i] = Math.min(dp[u][i], up = (dp[u][i] == 0 ? 0: up+1));</span><br><span class="line">        &#125;</span><br><span class="line">        for(let d=N-1, down=0; d&gt;=0; d--)&#123;</span><br><span class="line">            dp[d][i] = Math.min(dp[d][i], down = (dp[d][i] == 0 ? 0: down+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var max = 0;</span><br><span class="line">    for(let i=0; i&lt;N; i++)&#123;</span><br><span class="line">        for(let j=0; j&lt;N; j++)&#123;</span><br><span class="line">            max = Math.max(max, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：<br>本文主要对动态规划几种经典题做了简单介绍，希望对大家对算法方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://juejin.im/post/5affed3951882567161ad511" target="_blank" rel="noopener">https://juejin.im/post/5affed3951882567161ad511</a><br><a href="https://juejin.im/post/5b0a8e0f51882538b2592963" target="_blank" rel="noopener">https://juejin.im/post/5b0a8e0f51882538b2592963</a><br><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了动态规划的几种经典题型，分别为经典01背包、最少硬币、最大正方形、最大加号标志。&lt;/p&gt;
    
    </summary>
    
      <category term="dengzonghui" scheme="http://xgfe.github.io/categories/dengzonghui/"/>
    
    
      <category term="算法" scheme="http://xgfe.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/"/>
    <id>http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/</id>
    <published>2019-03-09T08:15:00.000Z</published>
    <updated>2019-06-14T07:28:14.256Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。</p><a id="more"></a><h2 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</p></blockquote><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>用户注册时验证用户名是否被占用为例在输入的时候就在判断这个用户名是否已被注册。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数前<br><img src="/uploads/yangfan/DebounceThrottle/debouncebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数后<br><img src="/uploads/yangfan/DebounceThrottle/debounceafter.gif" width="400px"><br></div><br></div><p>使用防抖函数前做法存在明显缺陷当用户输入发生变化的时候，就请求判断了，不仅对服务器的压力增大了，而且用户在输入中时频繁的校验提示中断用户交互明显降低了用户体验。而理想的做法应该是，用户输入发生变化后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。而函数防抖所做的工作就是延迟一段时间去执行函数而在延迟期间又调用了此动作则重新计时。</p><h3 id="DemoCode"><a href="#DemoCode" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"ordinary"</span>&gt;</span>普通<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'ordinary'</span> <span class="attr">id</span>=<span class="string">'ordinary'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"debounce"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'debounce'</span> <span class="attr">id</span>=<span class="string">'debounce'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ajax requestDtae:<span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ordinaryInput = <span class="built_in">document</span>.getElementById(<span class="string">'ordinary'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceAjax = _.debounce(ajax, <span class="number">1000</span>)</span><br><span class="line">ordinaryInput.addEventListener(<span class="string">'keyup'</span>, ajax);</span><br><span class="line">debounceInput.addEventListener(<span class="string">'keyup'</span>, debounceAjax);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            func(args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Throttle（节流）"><a href="#Throttle（节流）" class="headerlink" title="Throttle（节流）"></a>Throttle（节流）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></blockquote><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>在瀑布流式布局的页面中，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。在发生滚动时就需要判断页面是否滚动到底部。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用节流函数前<br><img src="/uploads/yangfan/DebounceThrottle/throttlebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用节流函数后<br><img src="/uploads/yangfan/DebounceThrottle/throttleafter.gif" width="400px"><br></div><br></div><p>使用节流函数前明显缺点是消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数。</p><h3 id="DemoCode-1"><a href="#DemoCode-1" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`scroll bodyY:<span class="subst">$&#123;body.getBoundingClientRect().y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttleScrollAnimation = _.throttle(scrollAnimation, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//window.addEventListener('scroll', scrollAnimation);</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttleScrollAnimation);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (curr - start &gt;= wait) &#123;</span><br><span class="line">            func(args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func(args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 <a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">这个页面</a> 看一下两者可视化的比较。<br>在实际的开发中根据根据需求的不同合理使用 debounce 或 throttle。<br>例如：在模糊查询时使用 debounce 在无限滚动时使用 throttle。（requestAnimationFrame）</p><h2 id="附lodash实现代码"><a href="#附lodash实现代码" class="headerlink" title="附lodash实现代码"></a>附lodash实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isObject <span class="keyword">from</span> <span class="string">'./isObject.js'</span></span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">'./.internal/root.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span></span><br><span class="line"><span class="comment"> * milliseconds have elapsed since the last time the debounced function was</span></span><br><span class="line"><span class="comment"> * invoked, or until the next browser frame is drawn. The debounced function</span></span><br><span class="line"><span class="comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span></span><br><span class="line"><span class="comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span></span><br><span class="line"><span class="comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span></span><br><span class="line"><span class="comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span></span><br><span class="line"><span class="comment"> * debounced function. Subsequent calls to the debounced function return the</span></span><br><span class="line"><span class="comment"> * result of the last `func` invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span></span><br><span class="line"><span class="comment"> * invoked on the trailing edge of the timeout only if the debounced function</span></span><br><span class="line"><span class="comment"> * is invoked more than once during the `wait` timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span></span><br><span class="line"><span class="comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span></span><br><span class="line"><span class="comment"> * invocation will be deferred until the next frame is drawn (typically about</span></span><br><span class="line"><span class="comment"> * 16ms).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span></span><br><span class="line"><span class="comment"> * for details over the differences between `debounce` and `throttle`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.1.0</span></span><br><span class="line"><span class="comment"> * @category Function</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func The function to debounce.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [wait=0]</span></span><br><span class="line"><span class="comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span></span><br><span class="line"><span class="comment"> *  used (if available).</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; [options=&#123;&#125;] The options object.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.leading=false]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the leading edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [options.maxWait]</span></span><br><span class="line"><span class="comment"> *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.trailing=true]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125; Returns the new debounced function.</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Avoid costly calculations while the window size is in flux.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('resize', debounce(calculateLayout, 150))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span></span><br><span class="line"><span class="comment"> * jQuery(element).on('click', debounce(sendMail, 300, &#123;</span></span><br><span class="line"><span class="comment"> *   'leading': true,</span></span><br><span class="line"><span class="comment"> *   'trailing': false</span></span><br><span class="line"><span class="comment"> * &#125;))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span></span><br><span class="line"><span class="comment"> * const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)</span></span><br><span class="line"><span class="comment"> * const source = new EventSource('/stream')</span></span><br><span class="line"><span class="comment"> * jQuery(source).on('message', debounced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Cancel the trailing debounced invocation.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('popstate', debounced.cancel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Check for pending invocations.</span></span><br><span class="line"><span class="comment"> * const status = debounced.pending() ? "Pending..." : "Ready"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastArgs, </span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span></span><br><span class="line">    <span class="keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> root.requestAnimationFrame === <span class="string">'function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = !!options.leading</span><br><span class="line">        maxing = <span class="string">'maxWait'</span> <span class="keyword">in</span> options</span><br><span class="line">        maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = lastArgs</span><br><span class="line">        <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            root.cancelAnimationFrame(timerId);</span><br><span class="line">            <span class="keyword">return</span> root.requestAnimationFrame(pendingFunc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.cancelAnimationFrame(id)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        <span class="comment">// Start the timer for the trailing edge.</span></span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="comment">// Invoke the leading edge.</span></span><br><span class="line">        <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">        <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxing ?</span><br><span class="line">            <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke) :</span><br><span class="line">            timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either this is the first call, activity has stopped and we're at the</span></span><br><span class="line">        <span class="comment">// trailing edge, the system time has gone backwards and we're treating</span></span><br><span class="line">        <span class="comment">// it as the trailing edge, or we've hit the `maxWait` limit.</span></span><br><span class="line">        <span class="comment">// timeSinceLastCall &lt; 0 修改系统时间时不会出现bug</span></span><br><span class="line">        <span class="keyword">return</span> (lastCallTime === <span class="literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class="line">            (timeSinceLastCall &lt; <span class="number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restart the timer.</span></span><br><span class="line">        timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only invoke if we have `lastArgs` which means `func` has been</span></span><br><span class="line">        <span class="comment">// debounced at least once.</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            cancelTimer(timerId)</span><br><span class="line">        &#125;</span><br><span class="line">        lastInvokeTime = <span class="number">0</span></span><br><span class="line">        lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = <span class="keyword">this</span></span><br><span class="line">        lastCallTime = time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">                <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">                timerId = startTimer(timerExpired, wait)</span><br><span class="line">                <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timerId = startTimer(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = <span class="string">'leading'</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。&lt;/p&gt;
    
    </summary>
    
      <category term="yangfan" scheme="http://xgfe.github.io/categories/yangfan/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="debounce&amp;throttle" scheme="http://xgfe.github.io/tags/debounce-throttle/"/>
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 使用及原理分析</title>
    <link href="http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/"/>
    <id>http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。<br><a id="more"></a><br>那么问题来了，什么是依赖注入？</p><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>—摘自百度百科</p></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在日常编码中经常会有类之间的依赖，为了方便理解，我们举个例子。手机类Phone包含了摄像头Camera组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        mCamera = new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到 Phone 和 Carmera 是耦合的，Phone 需要知道 Camera 的实现类 BackCamera 的存在，一旦 Camera 的实现变为其他，比如 FrontCamera 时，我们还需要修改 Phone 的构造方法。类似问题就可以使用依赖注入来解决。依赖注入的常用方法有构造方法注入和 setter 方法注入，两种方式都可以对 Phone 和 Camera 解耦，使得 Phone 无需关注 Camera 的实现，即使 Camera 的类型变了也无需修改 Phone 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone(Camera camera) &#123;</span><br><span class="line">        mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCamera(Camera camera) &#123;</span><br><span class="line">        this.mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Component-和-Inject"><a href="#Component-和-Inject" class="headerlink" title="@Component 和 @Inject"></a>@Component 和 @Inject</h3><p>那使用 Dagger2 该如何注入呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BackCamera implements Camera &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getCameraType() &#123;</span><br><span class="line">        return &quot;后置摄像头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera mCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到首先需要声明一个 @Component，然后需要在 BackCamera 的构造方法前增加注解 @Inject，接着在 Phone 的 mCamera 前增加 @Inject 以及构造方法中调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，几者间关系如下：</p><p><img src="/uploads/wangwenming/dagger-1.png" alt=""></p><h3 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a>@Module 和 @Provides</h3><p>那么问题来了，@Inject 只能标记构造方法，如果需要注入的是来自三方库的对象怎么办呢？这就需要用到 @Module，下面我们用 @Module 改造下上面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    public BackCamera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(modules = &#123;CameraModule.class&#125;)</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Module 和 @Provides 配合可以实现对三方库对象的注入。</p><h3 id="Named-和-Qualifier"><a href="#Named-和-Qualifier" class="headerlink" title="@Named 和 @Qualifier"></a>@Named 和 @Qualifier</h3><p>@Qualifier 是限定符用于自定义注解，@Named 是 @Qualifier 的一种实现。在一些情况下我们需要两个有相同父类或实现同一接口的依赖，当需求方使用的又是他们父类时，Component 就不知道到底提供哪一个了。还是拿手机举例，我们在原有基础上增加一个前置摄像头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera provideFrontCamera() &#123;</span><br><span class="line">        return new FrontCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera mFrontCamera;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera mBackCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为 Module 中的 provide 方法加上 @Named 注解，然后在需要使用的地方加上对应的 @Named 注解。上面例子同样可以使用 @Qualifier 来实现，使用 @Qualifier 定义两个运行时注解 @Front 和 @Back，使用两个注解替换上面的 @Named 注解即可。</p><h3 id="Singleton-和-Scope"><a href="#Singleton-和-Scope" class="headerlink" title="@Singleton 和 @Scope"></a>@Singleton 和 @Scope</h3><p>@Scope 同样用于自定义注解，我能可以通过 @Scope 自定义的注解来限定注解作用域，实现局部的单例；@Singleton 是 @Scope 的一个实现。在一些场景下我们需要使用单例，@Singleton 和 @Scope 可以帮助我们实现局部单例。为什么说是局部单例呢，因为 @Singleton 或 @Scope 能保证在对应的 Component 下是单例的，如果需要全局的单例，我们就需要其他手段保证 Component 是单例。下面看个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Singleton</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    void inject(App app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public Logger()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;Logger&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger2;</span><br><span class="line"></span><br><span class="line">    public App()&#123;</span><br><span class="line">        DaggerAppComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;App&quot;, &quot;app:&quot; + this);</span><br><span class="line">        logger.printMessage();</span><br><span class="line">        logger2.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 @Singleton 标注 Component 和需要注入的类即可。在上面的例子中，如果调用 App 的 printMessage 方法可以看到 logger 和 logger2 为同一对象，对于不同 App 对象的 logger 则是不同对象。当然我们也可以使用 @Scope 自定义一个注解来实现局部注解，来替换 @Singleton。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>前面简单介绍了 Dagger2 使用，接下来我们分析一下实现原理。Dagger2 在编译时根据注解生成一些辅助类，接下来我们具体分析下生成的辅助类。辅助类可以通过 DaggerXXXComponent 来快速定位。上面两个例子对应生成辅助类如下：</p><p><img src="/uploads/wangwenming/dagger-2.png" alt=""></p><p>简单来看辅助类和注解对应关系很明显，拿手机的例子来说对应关系如下：</p><table><thead><tr><th style="text-align:left">辅助类</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">BackCamera_Factory</td><td style="text-align:left">BackCamera 构造方法的 @Inject</td></tr><tr><td style="text-align:left">CameraModule_ProvideBackCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">CameraModule_ProvideFrontCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">DaggerPhoneComponent</td><td style="text-align:left">PhoneComponent 的 @Component</td></tr><tr><td style="text-align:left">Phone_MembersInjector</td><td style="text-align:left">Phone 对应的 @Inject</td></tr></tbody></table><p>原始类以及辅助类类图如下：</p><p><img src="/uploads/wangwenming/dagger-3.png" alt=""></p><p>接下来我们分析下具体的注入过程，首先 Phone 中会调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，我们来看下 DaggerPhoneComponent 的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Generated(</span><br><span class="line">  value = &quot;dagger.internal.codegen.ComponentProcessor&quot;,</span><br><span class="line">  comments = &quot;https://google.github.io/dagger&quot;</span><br><span class="line">)</span><br><span class="line">public final class DaggerPhoneComponent implements PhoneComponent &#123;</span><br><span class="line">  private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">  private DaggerPhoneComponent(Builder builder) &#123;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static PhoneComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private void initialize(final Builder builder) &#123;</span><br><span class="line">    this.cameraModule = builder.cameraModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void inject(Phone phone) &#123;</span><br><span class="line">    injectPhone(phone);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Phone injectPhone(Phone instance) &#123;</span><br><span class="line">    Phone_MembersInjector.injectMFrontCamera(</span><br><span class="line">        instance, CameraModule_ProvideFrontCameraFactory.proxyProvideFrontCamera(cameraModule));</span><br><span class="line">    Phone_MembersInjector.injectMBackCamera(</span><br><span class="line">        instance, CameraModule_ProvideBackCameraFactory.proxyProvideBackCamera(cameraModule));</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public PhoneComponent build() &#123;</span><br><span class="line">      if (cameraModule == null) &#123;</span><br><span class="line">        this.cameraModule = new CameraModule();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DaggerPhoneComponent(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder cameraModule(CameraModule cameraModule) &#123;</span><br><span class="line">      this.cameraModule = Preconditions.checkNotNull(cameraModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DaggerPhoneComponent 在创建时首先会创建一个 CameraModule，在进行注入时首先会调用工厂的代理方法最终调用 Module 中对应 @Provides 的方法创建对象，然后通过 Phone_MembersInjector 将上面创建的对象进行注入，工厂与 Injector 核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 工厂类核心</span><br><span class="line"> public static Camera proxyProvideFrontCamera(CameraModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(</span><br><span class="line">        instance.provideFrontCamera(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Injector 核心</span><br><span class="line"> public static void injectMBackCamera(Phone instance, Camera mBackCamera) &#123;</span><br><span class="line">    instance.mBackCamera = mBackCamera;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Dagger2 的基本使用并从辅助代码的源码层面进行了原理分析。关于从注解到辅助代码的生成并没有介绍，感兴趣的同学可以自行查阅注解处理器相关知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="wangwenming" scheme="http://xgfe.github.io/categories/wangwenming/"/>
    
    
      <category term="dagger2" scheme="http://xgfe.github.io/tags/dagger2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈当Swift中defer和inout同时起作用</title>
    <link href="http://xgfe.github.io/2019/02/20/wangqing28/%E6%B5%85%E8%B0%88%E5%BD%93Swift%E4%B8%ADdefer%E5%92%8Cinout%E5%90%8C%E6%97%B6%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>http://xgfe.github.io/2019/02/20/wangqing28/浅谈当Swift中defer和inout同时起作用/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.255Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对 <code>Swift</code> 中 <code>defer</code>、<code>inout</code> 以及 <code>return</code> 时相互影响的时候的情况进行简单的分析，目的是更好的理解 <code>defer</code>、<code>inout</code> 原理以及使用场合，减少踩坑和提高<code>debug</code>效率。</p><blockquote><p>本文中的示例代码，均为 <code>Swift 4.2</code> 版本</p></blockquote><a id="more"></a><h2 id="inout和defer"><a href="#inout和defer" class="headerlink" title="inout和defer"></a>inout和defer</h2><h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><p>有关 <code>inout</code> 关键字苹果官方描述</p><blockquote><p>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</p></blockquote><p>我们可以了解到，<code>inout</code> 关键字，有点类似于 <code>C</code> 语言中的引用传递或指针传递，目的是为了对入参进行修改。 但实际上 <code>inout</code> 的机制并不是引用传递，或者是指针传递。</p><p>以下是两段比较详细的苹果官方描述，摘出来看比较清晰：</p><blockquote><p>You write an in-out parameter by placing the inout keyword right before a parameter’s type. An in-out parameter has a value that is passed in to the function, is modified by the function, and is passed back out of the function to replace the original value. </p><p>in-out parameters are passed as follows:<br>When the function is called, the value of the argument is copied.<br>In the body of the function, the copy is modified.<br>When the function returns, the copy’s value is assigned to the original argument.<br>This behavior is known as copy-in copy-out or call by value result. </p></blockquote><p>从这两段我们可以看出，<code>inout</code> 的实现原理是：</p><ol><li>参数传入，拷贝一份 <strong>临时变量</strong></li><li>函数体中，修改的是这一份 <strong>临时变量</strong></li><li>函数返回时，这份 <strong>临时变量</strong> 被赋予给 <strong>原始参数</strong></li></ol><p>所以，是先拷贝，再修改，再拷贝回去的逻辑。这一点至关重要。</p><p>使用示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">f(x: &amp;a)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// 结果为 11</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于对象，即非 <code>Swift</code> 类型的，因为本身即为指针，所以本身就是指针传递，函数内部调用对象方法进行操作进而导致对象内部值的变化时，并不需要 <code>inout</code> 关键字。但是如果你想对这个对象变量整体进行的赋值替换操作，并且能反应到外部时，就需要 <code>inout</code>。<br>本文为了方便讨论，此处以及后续将仅仅以 <code>Swift</code> 原生类型作为例子。</p></blockquote><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>有关 <code>defer</code> 关键字苹果官方的描述</p><blockquote><p>A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.</p><p>This means that a defer statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</p></blockquote><p>简单说来， <code>defer</code> 是用来定义一段代码，用来在 <strong>离开</strong> 所在 <code>scope</code> 的时候执行。 苹果官方对 <code>defer</code> 的建议，也是用来关闭描述符、处理一些错误等等。</p><p>使用示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do defer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"do func"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"func done"</span>)</span><br><span class="line">&#125;</span><br><span class="line">g()</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">do func</span></span><br><span class="line"><span class="comment">func done</span></span><br><span class="line"><span class="comment">do defer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>这里注意一下， <code>defer</code> 的生效时机是 <code>scope</code> 离开的时候，而 <strong>不是函数执行完毕</strong> 的时候。 所以如果 <code>defer</code> 写在 <code>if</code> 或者 <code>for</code> 的内部， 会在 <code>if</code> 结束的时候立刻执行。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>因为很多写 <code>Swift</code> 的同学都是从 <code>Objective-C</code> 过来的，从使用习惯上来说，用 <code>inout</code> 会多一些， <code>defer</code> 并不太多。 但是当 <code>inout</code> 和 <code>defer</code> 以及 <code>return</code> 共同起作用的时候往往会有一些微妙的问题。</p><ol><li><code>defer</code> 本身是个 <code>block</code>，他内部也是可以修改变量。比如：<br><code>defer { x += 1 }</code></li><li><code>return</code> 的时候，也是可以执行一个 <code>block</code> 的。 比如 <code>return { x + 1 }()</code>，同时自身也会往栈上压入值</li><li><code>inout</code> 也是会改变入参的值。（再强调下，是复制-&gt;修改-&gt;写回，而不是原地修改）</li></ol><p>假如一个 <code>inout</code> 入参，在 <code>defer</code> 中被修改，在 <code>return</code> 的 <code>block</code> 中被修改。 那么问题来了：</p><ol><li>这几处修改的生效顺序是什么</li><li>对于 <code>inout</code> 和 <code>return</code> 而言，外界拿到的是什么时候的什么值</li></ol><p>用代码来举例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ret: \( fdo(x: &amp;outX) )"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after-ret: \( outX )"</span>)</span><br></pre></td></tr></table></figure></p><p>问题：</p><ol><li>几处修改何时生效</li><li><code>fdo</code> 返回的值是多少</li><li>最后的 <code>outX</code> 值又是多少</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了能知道结果，对上述代码进行扩充<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tag: String,  v:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(tag):\t\(v)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-def"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-def"</span>, v: x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"st-fdo"</span>, v: x)</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"ed-fdo"</span>, v: x)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-ret"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-ret"</span>, v: x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-before"</span>, v: outX)</span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"v-return"</span>, v: fdo(x: &amp;outX)) <span class="comment">// 如果代码改成 outX = fdo(x: &amp;outX)，下一行会如何？ 和现在会一样吗</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-after"</span>, v: outX)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x-before:10</span><br><span class="line">st-fdo:10</span><br><span class="line">ed-fdo:11</span><br><span class="line">st-ret:11</span><br><span class="line">ed-ret:12</span><br><span class="line">st-def:12</span><br><span class="line">ed-def:13</span><br><span class="line">v-return:12</span><br><span class="line">x-after:13</span><br><span class="line">// 如果代码改动 outX = fdo(x: &amp;outX)</span><br><span class="line">// 结果将是  x-after:12</span><br></pre></td></tr></table></figure></p><p>几个关注点</p><ol><li>打印顺序</li><li>各个节点的值</li><li><code>Swift</code> 执行的是写时拷贝</li></ol><blockquote><p>除了打日志分析之外，也可以检查汇编代码。</p></blockquote><p>简单分析一下可知如下执行顺序：</p><ol><li>正常调用<ol><li>此时内部生成临时变量 <code>x&#39;</code>，后续均操作此 <code>x&#39;</code></li></ol></li><li><code>return</code> 中 <code>block</code> 执行</li><li><code>defer</code> 执行 （如果多个，按倒序）</li><li><code>return</code> 返回<ol><li>此时返回出来的是 <strong>临时变量</strong></li><li>只是返回，<strong>函数调用</strong> 所在的整个语句并未执行</li></ol></li><li><code>inout</code> 生效<ol><li>用内部生成 <code>x&#39;</code> 回填栈顶，即将入参的 <code>x</code> 替换成 <code>x&#39;</code>，调用方取回</li></ol></li><li><strong>函数调用</strong> 所在的代码行生效，使用 <code>return</code> 返回的值对外操作，如外赋值、打印等等</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从实际的实现角度来说，执行顺序是:<br><strong>return中代码</strong> -&gt; <code>defer</code> -&gt; <code>return</code> -&gt; <code>inout</code> -&gt; <strong>调用处代码</strong></p><p>从变量和内存的角度考虑</p><ol><li><code>Swift</code> 是写时拷贝</li><li><code>inout</code> 是创建临时变量 -&gt; 返回时用临时变量覆盖传入变量，而不是原地修改</li></ol><p>从实际使用来说</p><ol><li>对于 <code>defer</code> 使用，应遵循苹果的官方建议，主要用于关闭描述符、处理一些错误。虽然可以做一些额外的副作用，甚至可以根据执行的特性，来在 <code>return</code> 之后再影响外部的一些东东，但是不建议做这些操作。</li><li>对于 <code>inout</code> ，需要了解执行的机制，不能根据现象对机制有所误判。</li><li>建议尽量少用 <strong>副作用</strong> 来达成一些预期，如在函数中过多的对外部变量进行修改，尤其是值类型的变量。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://onevcat.com/2018/11/defer/" target="_blank" rel="noopener">关于 Swift defer 的正确使用</a></li><li><a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" target="_blank" rel="noopener">Swift Language Guide</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_defer-statement" target="_blank" rel="noopener">Swift Language Reference - Statements - defer</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" target="_blank" rel="noopener">Swift Language Reference - Declarations - In-Out Parameters</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对 &lt;code&gt;Swift&lt;/code&gt; 中 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 以及 &lt;code&gt;return&lt;/code&gt; 时相互影响的时候的情况进行简单的分析，目的是更好的理解 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 原理以及使用场合，减少踩坑和提高&lt;code&gt;debug&lt;/code&gt;效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文中的示例代码，均为 &lt;code&gt;Swift 4.2&lt;/code&gt; 版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="wangqing28" scheme="http://xgfe.github.io/categories/wangqing28/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://xgfe.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Angular CDK 部分功能介绍</title>
    <link href="http://xgfe.github.io/2019/01/17/luanmingyang/Angular%20CDK%20%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xgfe.github.io/2019/01/17/luanmingyang/Angular CDK 部分功能介绍/</id>
    <published>2019-01-17T11:31:00.000Z</published>
    <updated>2019-06-14T07:28:14.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。</p><a id="more"></a><h1 id="Angular-CDK-部分功能介绍"><a href="#Angular-CDK-部分功能介绍" class="headerlink" title="Angular CDK 部分功能介绍"></a>Angular CDK 部分功能介绍</h1><p>Angular CDK(Component Dev Kit) 是一个组件开发工具包，实现了一些公共的交互，同时不关注组件的具体呈现，可以在组件的开发中使用。</p><p>Angular CDK主要分为两大类：</p><ul><li><p>Common Behaviors</p><p>一组包括了常见功能需求的工具，只与组件行为相关，不影响组件的呈现。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/a11y" target="_blank" rel="noopener">Accessibility</a> 提供了许多改进可访问性的工具</li><li><a href="https://material.angular.io/cdk/bidi" target="_blank" rel="noopener">Bidirectionality</a> 用于获取和响应LTR / RTL布局方向的变化</li><li><a href="https://material.angular.io/cdk/drag-drop" target="_blank" rel="noopener">Drag and Drop</a> 提供了声明式创建拖拽的接口，支持自由拖拽、列表排序等</li><li><a href="https://material.angular.io/cdk/layout" target="_blank" rel="noopener">Layout</a> 用于构建响应屏幕大小改变的响应式UI</li><li><a href="https://material.angular.io/cdk/observers" target="_blank" rel="noopener">Observers</a> 提供了一组 observers 指令</li><li><a href="https://material.angular.io/cdk/overlay" target="_blank" rel="noopener">Overlay</a> 提供了一种在屏幕上打开浮动面板的方法</li><li><a href="https://material.angular.io/cdk/platform" target="_blank" rel="noopener">Platform</a> 用于收集当前平台及其支持的不同功能的信息</li><li><a href="https://material.angular.io/cdk/portal" target="_blank" rel="noopener">Portal</a> 用于将动态内容呈现到应用程序</li><li><a href="https://material.angular.io/cdk/scrolling" target="_blank" rel="noopener">Scrolling</a> 提供了对滚动的处理</li><li><a href="https://material.angular.io/cdk/text-field" target="_blank" rel="noopener">Text field</a> 用于处理文本输入</li></ul></li><li><p>Components</p><p>一组具有实用功能的无样式组件。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/stepper" target="_blank" rel="noopener">Stepper</a> 步进器</li><li><a href="https://material.angular.io/cdk/table" target="_blank" rel="noopener">Table</a> 可自定义的 data-table</li><li><a href="https://material.angular.io/cdk/tree" target="_blank" rel="noopener">Tree</a> 方便为结构化数据构建树型结构</li></ul></li></ul><p>本文主要包括了三部分的介绍：Portal、Overlay、a11y/FocusTrap</p><h2 id="1-Angular-CDK-之-Portal"><a href="#1-Angular-CDK-之-Portal" class="headerlink" title="1. Angular CDK 之 Portal"></a>1. Angular CDK 之 Portal</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Portal 用于将动态内容呈现到应用程序。</p><p>Portal：动态内容，可以是 <code>Component</code> 或 <code>TemplateRef</code></p><p>PortalOutlet：放置动态内容的地方</p><p><a href="https://material.angular.io/cdk/portal/api#DomPortalOutlet" target="_blank" rel="noopener">Portal API</a></p><h3 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2 指令"></a>1.2 指令</h3><h4 id="CdkPortal"><a href="#CdkPortal" class="headerlink" title="CdkPortal"></a>CdkPortal</h4><p>指令版本 <code>TemplatePortal</code>，用于从 <code>&lt;ng-template&gt;</code> 获取一个Portal。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件内部可以使用 <code>@ViewChild</code> 或 <code>@ViewChildren</code> 获取引用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChildren</span>(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br></pre></td></tr></table></figure><p><img src="/Users/luanmingyang/Desktop/luan/img/portal-cdkportal.png" width="540"></p><h4 id="CdkPortalOutlet"><a href="#CdkPortalOutlet" class="headerlink" title="CdkPortalOutlet"></a>CdkPortalOutlet</h4><p>用于添加 <code>PortalOutlet</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="🌰-动态切换内容"><a href="#🌰-动态切换内容" class="headerlink" title="🌰 动态切换内容"></a>🌰 动态切换内容</h4><p><a href="https://stackblitz.com/edit/angular-hua49e?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用时需要先引入对应模块：</p><p><code>import {PortalModule} from &#39;@angular/cdk/portal&#39;;</code></p><p>首先设置一个插槽，用于放置动态内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要动态显示的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">template</span>&gt;</span>Portal3<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过改变 <code>curPortal</code> 切换显示内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PortalDemoComponent</span> </span>&#123;</span><br><span class="line">  curPortal: Portal&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 获取动态内容引用</span></span><br><span class="line">  @ViewChildren(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br><span class="line">  @ViewChild(<span class="string">'template'</span>) template: TemplateRef&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 切换</span></span><br><span class="line">  changePortal() &#123;</span><br><span class="line">    <span class="comment">// this.curPortal = xxx;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用class"><a href="#1-3-常用class" class="headerlink" title="1.3 常用class"></a>1.3 常用class</h3><h4 id="Portal"><a href="#Portal" class="headerlink" title="Portal"></a>Portal</h4><p>想要渲染在其它位置的内容，可以附加到 <code>PortalOutlet</code>，或从 <code>PortalOutlet</code> 分离。</p><p>可以通过 <code>isAttached</code> 属性判断是否已经被附加到某个 <code>PortalOutlet</code>。</p><h4 id="ComponentPortal"><a href="#ComponentPortal" class="headerlink" title="ComponentPortal"></a>ComponentPortal</h4><p>可以在attach时实例化某些组件</p><p><code>new ComponentPortal&lt;{}&gt;(component: ComponentType&lt;{}&gt;, viewContainerRef?: ViewContainerRef, injector?: Injector, componentFactoryResolver?: ComponentFactoryResolver): ComponentPortal&lt;{}&gt;</code></p><h4 id="TemplatePortal"><a href="#TemplatePortal" class="headerlink" title="TemplatePortal"></a>TemplatePortal</h4><p>表示一些嵌入的模版</p><p><code>new TemplatePortal&lt;{}&gt;(template: TemplateRef&lt;{}&gt;, viewContainerRef: ViewContainerRef, context?: {}): TemplatePortal&lt;{}&gt;</code></p><h4 id="DomPortalOutlet"><a href="#DomPortalOutlet" class="headerlink" title="DomPortalOutlet"></a>DomPortalOutlet</h4><p>用于将 Portal 附加到Angular应用程序上下文之外的任意DOM元素，也就是附加到 <code>&lt;app-root&gt;</code> 之外</p><h5 id="🌰-简单使用示例"><a href="#🌰-简单使用示例" class="headerlink" title="🌰 简单使用示例"></a>🌰 简单使用示例</h5><p><a href="https://stackblitz.com/edit/angular-dxl7fg?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">domPortalOutlet: DomPortalOutlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(</span><br><span class="line">    private viewContainerRef: ViewContainerRef,</span><br><span class="line">    private injector: Injector,</span><br><span class="line">    private componentFactoryResolver: ComponentFactoryResolver,</span><br><span class="line">    private appRef: ApplicationRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">createOutletOutApp() &#123;</span><br><span class="line">  <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  elem.innerHTML = <span class="string">'&amp;ltapp-root&amp;gt;外的插槽'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet = <span class="keyword">new</span> DomPortalOutlet(elem, <span class="keyword">this</span>.componentFactoryResolver, <span class="keyword">this</span>.appRef, <span class="keyword">this</span>.injector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attachTemplatePortal() &#123;</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet.attachTemplatePortal(<span class="keyword">this</span>.templatPortals.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>new DomPortalOutlet(elem, this.componentFactoryResolver, this.appRef, this.injector);</code> 把elem 变成Angular可管理的插槽。</p><p><img width="360" src="/Users/luanmingyang/Desktop/luan/img/portal-DomPortalOutlet.png"></p><h5 id="DomPortalOutlet-在-Angular-Material-中的使用"><a href="#DomPortalOutlet-在-Angular-Material-中的使用" class="headerlink" title="DomPortalOutlet 在 Angular Material 中的使用"></a>DomPortalOutlet 在 Angular Material 中的使用</h5><p>在 Angular Material CDK Overlay 中，通过使用 DomPortalOutlet 在 <code>&lt;app-root&gt;</code> 之外创建 Overlay container</p><p><a href="https://github.com/angular/material2/blob/master/src/cdk/overlay/overlay.ts#L117" target="_blank" rel="noopener">源码</a> 部分代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pane = <span class="keyword">this</span>._createPaneElement(host);</span><br><span class="line"><span class="keyword">const</span> portalOutlet = <span class="keyword">this</span>._createPortalOutlet(pane);</span><br><span class="line"></span><br><span class="line">private _createPaneElement(host: HTMLElement): HTMLElement &#123;</span><br><span class="line">    <span class="keyword">const</span> pane = <span class="keyword">this</span>._document.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">    pane.id = <span class="string">`cdk-overlay-<span class="subst">$&#123;nextUniqueId++&#125;</span>`</span>;</span><br><span class="line">    pane.classList.add(<span class="string">'cdk-overlay-pane'</span>);</span><br><span class="line">    host.appendChild(pane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private _createPortalOutlet(pane: HTMLElement): DomPortalOutlet &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._appRef) &#123;</span><br><span class="line">      <span class="keyword">this</span>._appRef = <span class="keyword">this</span>._injector.get&lt;ApplicationRef&gt;(ApplicationRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DomPortalOutlet(pane, <span class="keyword">this</span>._componentFactoryResolver, <span class="keyword">this</span>._appRef, <span class="keyword">this</span>._injector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Angular-CDK-之-Overlay"><a href="#2-Angular-CDK-之-Overlay" class="headerlink" title="2. Angular CDK 之 Overlay"></a>2. Angular CDK 之 Overlay</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Overlay 提供了一种在屏幕上打开浮动面板的方法，即在 <code>&lt;app-root&gt;</code> 之外创建叠加层，并且该叠加层仍在 Angular 控制范围内。</p><p>主要用于构建公共组件，Modal、Tooltip、Menu、Select等组件的构建过程中都可以选择使用 Overlay。</p><p>使用时需要先引入对应模块：</p><p><code>import {OverlayModule} from &#39;@angular/cdk/overlay&#39;;</code></p><p>通过调用 <code>overlay.create()</code> 创建一个 <code>OverlayRef</code> 实例，<code>OverlayRef</code> 是一个 <code>PortalOutlet</code>，一旦被创建，可以通过附加 <code>Portal</code> 为其添加内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> overlayRef = overlay.create();</span><br><span class="line"><span class="keyword">const</span> userProfilePortal = <span class="keyword">new</span> ComponentPortal(UserProfile);</span><br><span class="line">overlayRef.attach(userProfilePortal);</span><br></pre></td></tr></table></figure><p>创建时 <code>OverlayRef</code> 时可以提供可选的配置对象 <code>OverlayConfig</code>。</p><p><a href="https://material.angular.io/cdk/overlay/api#Overlay" target="_blank" rel="noopener">Overlay API</a></p><h3 id="2-2-OverlayRef"><a href="#2-2-OverlayRef" class="headerlink" title="2.2 OverlayRef"></a>2.2 OverlayRef</h3><p>使用服务创建的Overlay引用，用于对其操纵或处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverlayDemoComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  overlayRef: OverlayRef;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(private overlay: Overlay) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-create.png"></p><h3 id="2-3-OverlayConfig"><a href="#2-3-OverlayConfig" class="headerlink" title="2.3 OverlayConfig"></a>2.3 OverlayConfig</h3><p>创建Overlay时使用的配置对象。</p><p>属性：</p><ul><li>hasBackdrop：是否使用遮罩</li><li>backdropClass：遮罩的classname，使得我们可以自定义遮罩的样式</li><li>positionStrategy：PositionStrategy 指定位置策略</li><li>scrollStrategy：ScrollStrategy 指定在打开时处理滚动事件的策略</li><li>direction：文本的方向</li><li>panelClass：指定 Overlay 类名</li><li>disposeOnNavigation：当用户在前进/后退时是否应该丢弃。注意，通常不包括单击链接（除非在使用<code>HashLocationStrategy</code>）。</li><li>width/minWidth/maxWidth：定义宽度。类型为number时，则默认单位为px</li><li>height/minHeight/maxHeight：定义高度。类型为number时，则默认单位为px</li></ul><p>可以通过 OverlayRef 指定 backdrop 的点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-4-两种位置策略"><a href="#2-4-两种位置策略" class="headerlink" title="2.4 两种位置策略"></a>2.4 两种位置策略</h3><ul><li><p>GlobalPositionStrategy</p><p>使用此策略，叠加层被赋予相对于浏览器视口的显式位置，与其他元素无关。</p></li><li><p>ConnectedPositionStrategy（弃用）</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li><li><p>FlexibleConnectedPositionStrategy</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li></ul><h3 id="2-5-四种滚动策略"><a href="#2-5-四种滚动策略" class="headerlink" title="2.5 四种滚动策略"></a>2.5 四种滚动策略</h3><ul><li><p>NoopScrollStrategy</p><p>默认，什么都不做。</p></li><li><p>CloseScrollStrategy</p><p>滚动时会自动关闭叠加层。</p></li><li><p>BlockScrollStrategy</p><p>将在打开时阻止页面滚动。</p></li><li><p>RepositionScrollStrategy</p><p>滚动时会重新定位覆盖元素，会对滚动产生一些性能影响。</p></li></ul><h3 id="🌰-示例"><a href="#🌰-示例" class="headerlink" title="🌰 示例"></a>🌰 示例</h3><p><a href="https://stackblitz.com/edit/angular-zmcuh9?file=src%2Fapp%2Foverlay%2Foverlay-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用 Overlay 需要先引入必要的样式</p><p><code>@import &#39;~@angular/cdk/overlay-prebuilt.css&#39;;</code></p><h4 id="1-创建菜单"><a href="#1-创建菜单" class="headerlink" title="1. 创建菜单"></a>1. 创建菜单</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createMenu() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position()</span><br><span class="line">    .flexibleConnectedTo(<span class="keyword">this</span>.createMenuBtn).withPositions([&#123;</span><br><span class="line">      originX: <span class="string">'center'</span>,</span><br><span class="line">      originY: <span class="string">'bottom'</span>,</span><br><span class="line">      overlayX: <span class="string">'center'</span>,</span><br><span class="line">      overlayY: <span class="string">'top'</span></span><br><span class="line">    &#125;]);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(&#123;</span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.menuTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>overlay.position()</code> 方法获取一个 <code>OverlayPositionBuilder</code> ，通过它来配置位置策略。</p><p>通过调用 <code>flexibleConnectedTo(elementRef)</code> 方法创建位置策略 <code>FlexibleConnectedPositionStrategy</code></p><p><img width="100" src="/Users/luanmingyang/Desktop/luan/img/overlay-menu.png"></p><h4 id="2-创建弹出框"><a href="#2-创建弹出框" class="headerlink" title="2. 创建弹出框"></a>2. 创建弹出框</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createDialog() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position().global().centerHorizontally().centerVertically();</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">new</span> OverlayConfig(&#123;</span><br><span class="line">    hasBackdrop: <span class="literal">true</span>, <span class="comment">// 使用backdrop</span></span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(config);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.dialogTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">  <span class="comment">// 绑定backdrop点击事件</span></span><br><span class="line">  <span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>global()</code> 方法创建位置策略 <code>GlobalPositionStrategy</code></p><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-dialog.png"></p><h2 id="3-Angular-CDK-之-a11y"><a href="#3-Angular-CDK-之-a11y" class="headerlink" title="3. Angular CDK 之 a11y"></a>3. Angular CDK 之 a11y</h2><h3 id="3-1-a11y-概述"><a href="#3-1-a11y-概述" class="headerlink" title="3.1 a11y 概述"></a>3.1 a11y 概述</h3><p>a11y 提供了许多改进可访问性的工具。</p><p>使用时需要先引入对应模块：</p><p><code>import {A11yModule} from &#39;@angular/cdk/a11y&#39;;</code></p><h3 id="3-2-FocusTrap"><a href="#3-2-FocusTrap" class="headerlink" title="3.2 FocusTrap"></a>3.2 FocusTrap</h3><p>旨在用于为对话框等<strong>焦点必须受到约束</strong>的组件创建可访问的体验。</p><h4 id="3-2-1-指令"><a href="#3-2-1-指令" class="headerlink" title="3.2.1 指令"></a>3.2.1 指令</h4><p><code>cdkTrapFocus</code> 在区域内捕获焦点的指令。</p><p>可以显式地声明聚焦的区域：</p><p><code>cdkFocusInitial</code> 指定在初始化区域时将获得焦点的元素。</p><p><code>cdkFocusRegionStart</code> 与 <code>cdkFocusRegionEnd</code> 定义焦点将被捕获的区域。使用Tab键时，焦点将在此区域中移动并在两端环绕。</p><h4 id="3-2-2-FocusTrapFactory"><a href="#3-2-2-FocusTrapFactory" class="headerlink" title="3.2.2 FocusTrapFactory"></a>3.2.2 FocusTrapFactory</h4><p>用于根据给定的元素创建一个焦点捕获区域。</p><p><code>focusTrap = focusTrapFactory.create(element);</code></p><h4 id="3-2-3-FocusTrap"><a href="#3-2-3-FocusTrap" class="headerlink" title="3.2.3 FocusTrap"></a>3.2.3 FocusTrap</h4><p>允许在DOM元素中捕获焦点的类。</p><p>它假定Tab键顺序与DOM顺序相同，但实际上这是不一定的，如 tabIndex &gt; 0 或 指定了 flex order 等情况。</p><ul><li>focusFirstTabbableElement()   聚焦区域内的第一个可捕捉元素</li><li>focusFirstTabbableElementWhenReady()</li><li>focusInitialElement()  </li><li>focusInitialElementWhenReady()</li><li>focusLastTabbableElement()</li><li>focusLastTabbableElementWhenReady()</li></ul><h4 id="3-2-4-实际中的使用"><a href="#3-2-4-实际中的使用" class="headerlink" title="3.2.4 实际中的使用"></a>3.2.4 实际中的使用</h4><p>以公共组件 Dialog 为例，需要在 Dialog 打开时，将焦点约束在 Dialog 区域内部。</p><p>主要分为三步：</p><ol><li>打开 Dialog 时，保存当前获得焦点的元素</li><li>使 Dialog 获得焦点，并将焦点约束在 Dialog 内</li><li>Dialog 关闭时，将焦点恢复到之前聚焦的元素上</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Inject &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FocusTrap, FocusTrapFactory &#125; <span class="keyword">from</span> <span class="string">'@angular/cdk/a11y'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DOCUMENT &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    focusTrap: FocusTrap;</span><br><span class="line">    prevFocusedElem: HTMLElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        private elementRef: ElementRef,</span><br><span class="line">        private focusTrapFactory: FocusTrapFactory,</span><br><span class="line">        @Inject(DOCUMENT) private document: any) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 Dialog open 之前聚焦的元素</span></span><br><span class="line">    savePrevFocusedElement() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.document) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem = <span class="keyword">this</span>.document.activeElement <span class="keyword">as</span> HTMLElement;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.elementRef.nativeElement.focus) &#123;</span><br><span class="line">                <span class="comment">// 元素可能无法立即聚焦</span></span><br><span class="line">                <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.elementRef.nativeElement.focus();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将焦点限制在 Dialog 内部</span></span><br><span class="line">    trapFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="keyword">this</span>.focusTrapFactory.create(<span class="keyword">this</span>.elementRef.nativeElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.focusTrap.focusInitialElementWhenReady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dialog close 时恢复原来聚焦的元素</span></span><br><span class="line">    restoreFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prevFocusedElem &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>.prevFocusedElem.focus === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap.destroy();</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。&lt;/p&gt;
    
    </summary>
    
      <category term="luanmingyang" scheme="http://xgfe.github.io/categories/luanmingyang/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
      <category term="Angular CDK" scheme="http://xgfe.github.io/tags/Angular-CDK/"/>
    
  </entry>
  
  <entry>
    <title>mysql通信协议浅解</title>
    <link href="http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/"/>
    <id>http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2019-06-14T07:08:56.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。</p><p>代码部分经过nodejs的mysql模块和php的mysqli模块验证。</p><p>此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。</p><a id="more"></a><hr><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>mysql链接分为TCP握手链接，服务端对客户端认证，数据交互，断开链接几个阶段。<br>服务器启动后，会使用 TCP 监听一个本地端口，当客户端的连接请求到达时，就会执行三段握手以及 MySQL 的权限验证；验证成功后，客户端开始发送请求，服务器会以响应的报文格式返回数据；当客户端发送完成后，会发送一个特殊的报文，告知服务器已结束会话。</p><p>MySQL 定义了几种包类型，A) 客户端-&gt;服务器，登录时的 auth 包、执行 SQL 时的 CMD 包；B) 服务器-&gt;客户端，登录时的握手包、数据包、数据流结束包、成功包(OK Packet)、错误信息包。</p><p>协议定义了基本的数据类型，如 int、string 等；数据的传送格式等。</p><h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h3><p>当server端和client端数据交互时，如果数据包size大于2^24时，要将包拆成多个；<br>每个包由header和payload两部分组成；</p><h3 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h3><pre><code>服务端 -&gt; 客户端：发送握手初始化包 (Handshake Initialization Packet)。客户端 -&gt; 服务端：发送验证包 (Client Authentication Packet)。服务端 -&gt; 客户端：认证结果消息</code></pre><p>mysql的认证过程相对复杂，这里简单介绍4.1版本之后的认证过程（计划功能中对这部分请求可以透明透给远程mysql，没有必要进行处理，以下内容摘自网络）。</p><ol><li><p>服务器发送随机字符串 (scramble) 给客户端。</p></li><li><p>客户端作如下计算，然后客户端将 token 发送给服务端。</p><blockquote><p>stage1_hash = SHA1(明文密码)</p><p>token = SHA1(scramble + SHA1(stage1_hash)) XOR stage1_hash</p></blockquote></li><li><p>服务端作如下计算，比对 SHA1(stage1_hash) 和 mysql.user.password 是否相同</p><blockquote><p>stage1_hash = token XOR SHA1(scramble + mysql.user.password)<br>server -&gt; client， client-&gt; server 包类型</p></blockquote><p> 校验时，只需要 SHA1(stage1_hash) 与 mysql.user.password 比较一下即可</p></li></ol><p>handshake包(protocol41)</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>protocol_version</td></tr><tr><td>n</td><td>(Null-Terminated String)   server_version</td></tr><tr><td>4</td><td>thread_id</td></tr><tr><td>8</td><td>scramble_buff</td></tr><tr><td>1</td><td>(filler) always 0x00</td></tr><tr><td>2</td><td>server_capabilities</td></tr><tr><td>1</td><td>server_language</td></tr><tr><td>2</td><td>server_status</td></tr><tr><td>13</td><td>(filler) always 0x00 …</td></tr><tr><td>13</td><td>rest of scramble_buff (4.1)</td></tr></tbody></table><h3 id="获得use-db"><a href="#获得use-db" class="headerlink" title="获得use db"></a>获得use db</h3><p> 对本次需求只需要取出初始化mysql链接的时候会初始化使用哪个库(use database;),需要从包里解出，其它部分忽略。</p><pre><code>function parseHandShake(buff){    let _check_pos = buff.indexOf(Buffer.alloc(23,0x00));    if (_check_pos &gt; 0){        //protocol41        buff =  buff.slice(_check_pos + 23);        protocol41 = true;    }    //find user field end    _check_pos = buff.indexOf(0x00);    buff =  buff.slice(_check_pos + 1);    if (protocol41) {        buff =  buff.slice(21);         } else {        buff =  buff.slice(10);         }    _check_pos = buff.indexOf(0x00);    let default_db = buff.slice(0, _check_pos).toString(); }</code></pre><hr><h2 id="query请求-封包"><a href="#query请求-封包" class="headerlink" title="query请求 封包"></a>query请求 封包</h2><p>client到server的包（Command Packet ），由两部分构成：header 和 payload。header包括3位整数表示payload长度，1位整数表示顺序号；payload包括1位COM标识符和请求sql语句</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<3></3></td><td>payload_length</td><td>payload的长度</td></tr><tr><td>int<1></1></td><td>sequence_id</td><td>顺序号，每次从0开始</td></tr><tr><td>string<var></var></td><td>payload</td><td>COM + sql ，COM_QUERY 标识符为0x03</td></tr></tbody></table><p>Example:</p><table><thead><tr><th>header</th><th>sequence</th><th>Description</th></tr></thead><tbody><tr><td>01 00 00</td><td>00</td><td>03 xx xx…</td></tr><tr><td>length 1</td><td>sequence_id 0</td><td>payload [0x03,Buffer from sql string …]</td></tr></tbody></table><p>部分代码</p><pre><code> var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1; var buffer = Buffer.from(sql); for (var packet = 0; packet &lt; packets; packet++) {        var isLast = (packet + 1 === packets);    var packetLength = (isLast)           ? length % MAX_PACKET_LENGTH           : MAX_PACKET_LENGTH;       var packetNumber = incrementPacketNumber();       this.writeUnsignedNumber(3, packetLength);       this.writeUnsignedNumber(1, packetNumber);       var start = packet * MAX_PACKET_LENGTH;       var end   = start + packetLength;       this.writeBuffer(buffer.slice(start, end));}</code></pre><p>writeUnsignedNumber用来把包长度和序号写入packet header</p><pre><code>function writeUnsignedNumber(bytes, value) {       for (var i = 0; i &lt; bytes; i++) {       this._buffer[this._offset++] = (value &gt;&gt; (i * 8)) &amp; 0xff       }}</code></pre><p>当header的长度小于MAX_PACKET_LENGTH时表示包传输完成，极端情况下会多传个空包过去（正好整分）。</p><p>通常sql不长的情况下，只需要一个包就可以。</p><pre><code>ComQueryPacket.prototype.write = function write(){    let _sql_buff = Buffer.from(this.sql),        _cmd_len = Buffer.byteLength(this.sql),        _buff = Buffer.alloc(_cmd_len + 1 + 3 + 1);        _sql_buff.copy(_buff , 5);    this._buffer = _buff;    this.writeUnsignedNumber(4, _cmd_len+1);    this.writeUnsignedNumber(1, this.command);    return this._buffer; }</code></pre><hr><h2 id="query返回-解包"><a href="#query返回-解包" class="headerlink" title="query返回 解包"></a>query返回 解包</h2><p>从服务器发往客户端的数据包有四种：成功报告包以及错误消息包，数据结束包、数据包。</p><ul><li>0x00: Packets.OkPacket</li><li>0xff: Packets.ErrorPacket</li><li>0xfe: Packets.EofPacket</li><li>其它</li></ul><h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><pre><code>let first = data.readUInt8(4)，    //探测包类型    last = data.readUInt8(Buffer.byteLength(data) -1); //用来检测字符串类型数据是否传输完成if (first === 0xff) {    //查询错误} else if (first === 0x00) {    //查询OK，这里可以解析握手包等} else {    //数据包    //NullTerminatedString（Null结尾方式）: 字符串以遇到Null作为结束标志，相应的字节为00    if (last === 0x00 ){         //检查数据包中列信息和数据信息是否都接收完成    }}</code></pre><h3 id="OK-Packet"><a href="#OK-Packet" class="headerlink" title="OK Packet"></a>OK Packet</h3><p>Payload</p><table><thead><tr><th>相对包内容的位置</th><th>长度（字节）</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>包头标识</td><td>0x00 代表这是一个OK 包</td></tr><tr><td>1</td><td>rows_len</td><td>影响行数</td><td>相应操作影响的行数，比如一个Update操作的记录是5条，那么这个值就为5</td></tr><tr><td>1 + rows_len</td><td>id_len</td><td>自增id</td><td>插入一条记录时，如果是自增id的话，返回的id值</td></tr><tr><td>1 + rows_len + id_len</td><td>2</td><td>服务器状态</td><td>用于表示服务器状态，比如是否是事务模式或者自动提交模式</td></tr><tr><td>3 + rows_len + id_len</td><td>2</td><td>警告数</td><td>上次命令引起的警告数</td></tr><tr><td>5 + rows_len + id_len</td><td>msg_len</td><td>额外信息</td><td>此次操作的一些额外信息</td></tr></tbody></table><h3 id="Error-Packet"><a href="#Error-Packet" class="headerlink" title="Error Packet"></a>Error Packet</h3><p>Payload</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<1> [ff]</1></td><td>header</td><td>header of the ERR packet</td></tr><tr><td>int<2></2></td><td>error_code</td><td>错误码</td></tr><tr><td>if capabilities &amp; CLIENT_PROTOCOL_41 {</td></tr><tr><td>string[1]</td><td>sql_state_marker</td><td># marker of the SQL State</td></tr><tr><td>string[5]</td><td>sql_state</td><td>SQL State</td></tr><tr><td>} </td></tr><tr><td>string<eof></eof></td><td>error_message</td><td>报错信息</td></tr></tbody></table><h3 id="Result-Set-Packet"><a href="#Result-Set-Packet" class="headerlink" title="Result Set Packet"></a>Result Set Packet</h3><p>Result Set包产生于我们每次数据库执行需要返回结果集的时候，Server端发送给我们的包，比如平常的SELECT,SHOW等命令，Result Set包相对比较复杂，查询结果的完整内容由：<br>列数量信息 + 列包 + EOF包 + 行包 + EOF包，这五部分组成。</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>Result Set Header</td><td>返回数据的字段(列)数量</td></tr><tr><td>Field</td><td>返回数据的列信息（多个）</td></tr><tr><td>EOF</td><td>列结束</td></tr><tr><td>Row Data</td><td>行数据（多个）</td></tr><tr><td>EOF</td><td>数据结束</td></tr></tbody></table><p>例子 SELECT @@version_comment查询的返回结果：</p><pre><code>01 00 00 01 01|27 00 00    02 03 64 65 66 00 00 00    .....&apos;....def...11 40 40 76 65 72 73 69    6f 6e 5f 63 6f 6d 6d 65    .@@version_comme6e 74 00 0c 08 00 1c 00    00 00 fd 00 00 1f 00 00|   nt..............05 00 00 03 fe 00 00 02    00|1d 00 00 04 1c 4d 79    ..............My53 51 4c 20 43 6f 6d 6d    75 6e 69 74 79 20 53 65    SQL Community Se72 76 65 72 20 28 47 50    4c 29|05 00 00 05 fe 00    rver (GPL)......00 02 00                                              ...</code></pre><p>VERSION 4.0</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>4 (Length Coded Binary)</td><td>length</td></tr><tr><td>2 (Length Coded Binary)</td><td>type</td></tr><tr><td>2 (Length Coded Binary)</td><td>flags</td></tr><tr><td>1</td><td>decimals</td></tr><tr><td>n (Length Coded Binary)</td><td>default</td></tr></tbody></table><p>VERSION 4.1</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>catalog</td></tr><tr><td>n (Length Coded String)</td><td>db</td></tr><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>org_table 原表名</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>n (Length Coded String)</td><td>org_name 原字段名</td></tr><tr><td>(filler)            0c</td><td></td></tr><tr><td>charsetnr           08 00</td><td></td></tr><tr><td>n (Length Coded String)</td><td>length</td></tr><tr><td>n (Length Coded String)</td><td>type</td></tr><tr><td>n (Length Coded String)</td><td>flags</td></tr><tr><td>n (Length Coded String)</td><td>decimals</td></tr><tr><td>(filler) 00 00</td></tr></tbody></table><p> 处理代码：</p><pre><code>/** 解析字段信息* @param Buffer * @result Object */function parseColDef(buff){    let _stack = _parseLine(buff);    if (_stack.length &lt; 2) return false;    if (!_stack) return false;    if (_stack[0] === &apos;def&apos;){        //protocol41        return {            &apos;db&apos; : _stack[1],            &apos;table&apos; : _stack[2],            &apos;table_full&apos; : _stack[3],            &apos;field&apos; : _stack[4],            &apos;field_full&apos; : _stack[5]        };        }else{        return {            &apos;table&apos; : _stack[0],            &apos;field&apos; : _stack[1],        };    }}/** 解析行数据* @param Buffer * @result Array */function parseColVal(buff){    let _stack = _parseLine(buff);    return _stack;}function _parseLine(buff){    let _stack = [];    for(let i=0,j=buff.length ; i &lt; j ; i++){        let _len = buff[i].toString() * 1;        let _content = buff.slice(i+1, i+ 1 + _len  );        _stack.push(_content.toString());        i += _len;      }    return _stack;}function Parser(options) {    options = options || {};    this.reset(options);}Parser.prototype.reset = function(options){    this._header = [];    this._body = [];    this._parsed_columns = [];    this._parsed_col_vals = [];    this.header_len = 4;    this._head_set = false;    this._body_set = false;    this._reset();}Parser.prototype._reset = function(){    this._buffer = Buffer.alloc(0);    this._offset = 0;}//将字段部分和数据部分分开存放Parser.prototype._put = function(chunk){    if (0 === chunk.length) return;    if (this._head_set){        this._body.push(chunk);    }else{        this._header.push(chunk);    }}//获得result packetParser.prototype.write = function(chunk ,to_parse){    if (this._body_set) return false;    this._buffer = Buffer.concat([this._buffer,chunk]);    this._offset = 0;    this._process(to_parse);}Parser.prototype._process = function(to_parse){    let _header_len = this.header_len;    while(true){        if (this._buffer.length === 0 ){            break;        }        let _len = this.parseUnsignedNumber(3),            _number = this.parseUnsignedNumber(1);        if ((_len + _header_len) &gt; this._buffer.length){            break;        }        let _piece = this._buffer.slice(0,_len + _header_len),             _first = _piece.readUInt8(4);        this._put(_piece);        if (0xfe === _first){            if (!this._head_set){                this._head_set = true;                    this._parsed_col_vals = [];                for (let _m = 0,_n = this._parsed_columns.length; _m &lt; _n ; _m++){                    this._parsed_col_vals.push([]);                }            }else{                this._body_set = true;            }        } else if(to_parse){            if (!this._head_set){                let _column = parseColDef(_piece.slice(_header_len));                if (_column){                    this._parsed_columns.push(_column.field);                }            }else{                let _col_val = parseColVal(_piece.slice(_header_len));                for(let _m=0,_n=_col_val.length; _m &lt; _n;_m++){                    this._parsed_col_vals[_m].push(_col_val[_m]);                    }             }        }        this._buffer = this._buffer.slice(_piece.length );        this._offset = 0;    }}//读取解析后数据Parser.prototype.read = function(){    return {        head : this._header,        body : this._body,        headed : this._head_set,        bodyed : this._body_set,        columns : this._parsed_columns,        columns_vals : this._parsed_col_vals    }}//写入数字类型信息Parser.prototype.parseUnsignedNumber = function parseUnsignedNumber(bytes) {    if (bytes === 1) {        return this._buffer[this._offset++];    }    var buffer = this._buffer;    var offset = this._offset + bytes - 1;    var value  = 0;    if (bytes &gt; 4) {        var err    = new Error(&apos;parseUnsignedNumber: Supports only up to 4 bytes&apos;);        err.offset = (this._offset - this._packetOffset - 1);        err.code   = &apos;PARSER_UNSIGNED_TOO_LONG&apos;;        throw err;    }    while (offset &gt;= this._offset) {        value = ((value &lt;&lt; 8) | buffer[offset]) &gt;&gt;&gt; 0;        offset--;    }    this._offset += bytes;    return value;}; </code></pre><hr><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a><br><a href="https://blog.csdn.net/caisini_vc/article/details/5356136" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/5356136</a><br><a href="https://jin-yang.github.io/post/mysql-protocol.html" target="_blank" rel="noopener">https://jin-yang.github.io/post/mysql-protocol.html</a></p><p>HandShake:<br><a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a> ,  <a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a></p><p>com标识:<br><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。&lt;/p&gt;
&lt;p&gt;代码部分经过nodejs的mysql模块和php的mysqli模块验证。&lt;/p&gt;
&lt;p&gt;此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。&lt;/p&gt;
    
    </summary>
    
      <category term="rongweiwei" scheme="http://xgfe.github.io/categories/rongweiwei/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="mysql" scheme="http://xgfe.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 React-Native 与 Redux 数据流</title>
    <link href="http://xgfe.github.io/2018/11/25/juga/%E6%B5%85%E8%B0%88React-Native%E4%B8%8ERedux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://xgfe.github.io/2018/11/25/juga/浅谈React-Native与Redux数据流/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。</p><a id="more"></a><h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React-Native 介绍"></a>React-Native 介绍</h4><ul><li><p>React-Native 在官网上给的定义是：使用 JavaScript 和 React 编写原生移动应用。在设计原理上是和 React 一致的，可以通过生命是的组件机制来搭建丰富多彩的用户界面。RN 产出的不是“网页应用”或者“HTML5应用”，RN 所产出的其实是一个真正的移动应用。从感受上来说和 Objective-C 或 Java 编写的应用基本是一样的。</p></li><li><p><a href="https://reactnative.cn/" target="_blank" rel="noopener">RN官网</a></p></li></ul><h4 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h4><ul><li><p>官网上有教大家如何构建一个新的 React-Native 应用，这里就不多说了，这里直接切入组件的开发。可以在项目里面新建一个 Component 组件文件夹，专门用来存放组件。在该文件家里面建一个 TestComponen 子文件夹，然后在此子文件下面再建 TestComponent.js 和TestComponentStyle.js 两个文件夹，组件的逻辑写在TestComponent.js 文件下，样式写在 TestComponentStyle.js 文件下。<br><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc82f8j20hk03uaaa.jpg" alt="文件结构"></p></li><li><p>JS文件分析</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">//引入Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>; <span class="comment">//引入RN原生组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;Style&#125; <span class="keyword">from</span> <span class="string">'./TestComponentStyle'</span>; <span class="comment">//引入样式</span></span><br></pre></td></tr></table></figure><ul><li>简单的计数器实现</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc2m1qj207g010dfq.jpg" alt="计数器"></p><p>点击加号数字动态变化 +1，点击减号数字动态 -1。首先这个组件由一个 Text 和两个  Button 组件组成，其中 Text 组件中有两个变量，children 作为对外暴露的属性，写在 this.props 里面，state 是组件内部的可变化的状态，写在 this.state 里面。<br>官网上是这样描述 props 和 state：我们使用两种数据来控制一个组件：props 和 state.props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用 state 。<br>这里先介绍一下 render 函数部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      children</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props; <span class="comment">//组件对外暴露的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state; <span class="comment">//组件内部的状态</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="comment">//返回要渲染的组件</span></span><br><span class="line">      &lt;View style=&#123;Style.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;Style.txt&#125;&gt;&#123;<span class="string">`<span class="subst">$&#123;children&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button title=&#123;'-'&#125; color=&#123;'red'&#125; onPress=&#123;this.clickBtnSub&#125;/</span>&gt;</span><br><span class="line">        &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;<span class="keyword">this</span>.clickBtnAdd&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件的结构由一个 View 组件包裹一个 Text ，两个 Button 组件。Text 组件为展示的数字名和数字大小，Button 则是两个加减按钮。</p><p>然后可以看到 Style.container 和 Style.txt 都是引自  TestComponentStyle.js 文件。接下来我们看一下该文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Style = StyleSheet.create(&#123;</span><br><span class="line"><span class="comment">// styles</span></span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'space-around'</span>,</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  txt: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个是 RN 样式的基本写法，这个文件专门放 css 层的东西。这里要注意的是 css 的属性值接受的是字符串形式，在 RN 里面的 css 很多样式的值都被阉割了，所以这点要特别注意，这里有个推荐的网站可以看常用的RN样式：<br><a href="https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html" target="_blank" rel="noopener">RN css 样式</a></p><p>然后可以看到 Button 组件里面分别有一个点击事件。clickBtnSub 事件处理减 1，clickBtnAdd 处理加 1。<br>这里我推荐是使用箭头函数来定义函数，就可以在该组件的作用域里面直接调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickBtnSub = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num - <span class="number">1</span>&#125;);<span class="comment">//调用setState()函数，改变组件内部的状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> clickBtnAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num + <span class="number">1</span>&#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h4><p>组件写好之后可以引入到某个功能模块中使用。这里我们可以建一个 TestModule 文件夹来存放模块文件，里面可以建这么几个文件。如下图<br><img src="https://wx2.sinaimg.cn/mw690/ba56005dgy1fxkcvcd0coj20ia08o755.jpg" alt="文件结构"><br>接下来我们一个一个来介绍这几个文件的用处。<br>其实上面的组件计数器，除了使用 setState 来改变数字还可以使用 Redux 来完成这件事。<br>接下来就让我们来看看如何使用 Redux 完成</p><ul><li>TestModule.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import部分省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;计数器&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;num&#125; = this.props.data /</span><span class="regexp">/从store取得的数据，在reducer里面初始化</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*引入计数器组件*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View style=&#123;Style.container&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;TestComponent children=&#123;'数字: '&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*使用Redux完成的计数器*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;Text&gt;&#123;num&#125;&lt;/</span>Text&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'-'</span>&#125; color=&#123;<span class="string">'red'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.sub(num)&#125; /&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.add(num)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  (state) =&gt; (&#123; <span class="comment">//state其实就是store.getState()，得到数据</span></span><br><span class="line">    data: state.modules[CONSTANTS.NAME]</span><br><span class="line">  &#125;),</span><br><span class="line">  (dispatch) =&gt; (&#123; <span class="comment">//dispatch是一个发布器他需要接受一个对象用于触发reducer</span></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    add: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.add(num)),</span><br><span class="line">    sub: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.sub(num))</span><br><span class="line">  &#125;)</span><br><span class="line">)(TestModule);</span><br></pre></td></tr></table></figure></li></ul><p>模块的主要页面内容都是写在这个文件里面，这里我们直接从 components 引入了 TestComponent 组件进行使用。直接将组件当成标签名使用 <testcomponent>。这就是自定义组件方便的地方。中间可以看到组件渲染不一定要都放在 render() 里面，可以利用一个渲染函数，单独抽出来，这样可以让程序的结构上看起来更加明了，不要让所有的子组件都堆积在 render() 函数中。当然如果抽出来的组件内容太少，就没必要抽了。<br>这个文件的最下面 connect 函数是 Provider 提供的一种 store 注入方式，其中封装了两个函数，第一个函数其实是 store.getState() ，是从 store 得到数据的。<br>第二个函数 dispatch 是一个触发器，在里面写 action 函数来触发 reducer 来对数据进行所需要的操作。dispatch 触发 TestModuleActions.js 里面的函数。下面就介绍一下 TestModuleActions.js 文件<br>这里我们写了一个加一个减函数，接着在 actions.js 文件里定义这两个 action 函数。</testcomponent></p><ul><li>TestModuleActios.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ADD,</span><br><span class="line">  SUB</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ADD, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: SUB, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件主要是写 actions 的文件，定义 action，dispatch中根据 type 类型去 TestModuleReducers.js 那处理数据。通过 payload 把数据传到 reducer 里面。</p><ul><li>TestModuleConstants.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAME = <span class="string">'testmodule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action types</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/ADD`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/SUB`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件用来放全局常量。这里定义了 ADD 和 SUB 。</p><ul><li>TestModuleReducer.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ADD, SUB&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">//初始化数据的地方</span></span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123; <span class="comment">//处理数据的地方</span></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  [ADD]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SUB]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, initialState);</span><br></pre></td></tr></table></figure></li></ul><p>reducer 利用 action.payload 拿到从 action 传来的数据，处理数据，处理完返回。<br>这里就要说一下Redux的数据流了，请先看一下下图：<br><img src="https://wx3.sinaimg.cn/mw690/ba56005dgy1fxkcvc6dthj20xm0mk77l.jpg" alt="Redux Flow"></p><p>(图片来自网上)<br>这里我们在TestModule.js 文件中的 connect 中 dispatch( action ) ，把原先的计数器中数字 num (图中 previousState )，和 action ( ADD 或 SUB )传到了 reducer 里面，根据 actions 文件里面的 action 的 TYPE 来执行各自的数据处理。处理完之后就有新的 newState 传到 Store ，再传到组件中，驱动组件改变状态重新渲染。</p><ul><li>index.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./TestModule'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./TestModuleReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./TestModuleActions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NAME&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  NAME,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  reducer,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件将 NAME，module，reducer，actions 暴露出去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 RN + Redux 为基础框架开发已有三个多月，很多东西都还需要多加学习研究，这只是最基础的组件和模块开发。</p><p>组件开发总的时间为十的话，一定要思考占七，动手写占三，认真的多思考组件的构造，这样在动手写的时候才能尽量的避免结构的冗余，或者是样式的冗余，而且要想为什么做这个组件，必需能在某个项目中能多次的使用该组件，这样组件的开发才会变得有意义，不然一个组件只用一次的话，就没有必要单独拿出来封装成一个组件。另外就是组件写的过程尽量的思考拓展性，很多结构不要写死了，这次组件可能只需要展示 2 个 tab，但是下一次就不一定了，所以写的时候要多想。</p><p>模块开发的时候，尽量保持结构层次的清晰，这样的话代码的维护就会得比较轻松，模块里有很多独立的功能部分可以单抽出来做成一个渲染函数，这样就能让 render 函数看起来没那么的冗余，且结构不会过于复杂。一些点击事件和逻辑功能也是能单独抽出来写成事件函数，这样的话，调试出问题的时候就可以快速定位到问题代码块。还有就是尽量避免写一些重复的组件，能简化的就简化，可以考虑使用 map 函数来渲染重复的组件。</p><p>虽然这里用 Redux 也实现了计数器，但是其实是杀鸡用牛刀了，这样的简单的数据重新渲染其实大可不必，用 setState 就可以了，当然 Redux 也有其优点，他让数据和我们的组件模块解耦，数据单独处理了，不需要在每一个组件中来对 state 进行管理，需要的数据从上游作为 props 传进来了。不过经常可以看到这么一句话，如果你不知道你为什么需要 Redux，那你就是不需要 Redux..   (=. = redux 对于新手真的有点不友好)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/Helloyongwei/article/details/82937808" target="_blank" rel="noopener">Redux 的数据流</a></li><li><a href="https://www.jianshu.com/p/2a20c8485a90" target="_blank" rel="noopener">看了我这篇 RN 你就入门了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="juga" scheme="http://xgfe.github.io/categories/juga/"/>
    
    
      <category term="React Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="http://xgfe.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>koa-router 源码解读</title>
    <link href="http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/"/>
    <id>http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/</id>
    <published>2018-09-27T11:18:00.000Z</published>
    <updated>2019-06-14T07:45:42.234Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果实现一个简单的路由，可以解析<code>node</code>原生<code>request即IncomingMessage</code>对象的<code>url</code>属性，用 <code>if...else</code>判断路径从而返回不同的结果；当然也可以利用<code>koa</code>的<code>request</code>对象和<code>response</code>对象来处理。下面就是用<code>koa</code>实现的简单路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span>;</span><br><span class="line">        fs.readFile(pageUrl, <span class="string">"binary"</span>, (err,data) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">444</span>);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">'404.html'</span>;</span><br><span class="line">    <span class="keyword">switch</span>(url)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/index'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/todo'</span>:</span><br><span class="line">            page = <span class="string">'todo.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/404'</span>:</span><br><span class="line">            page = <span class="string">'404.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> render(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> route(url);</span><br><span class="line">    </span><br><span class="line">    ctx.body = html;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'starting at 3000'</span>);</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>路由越多消耗的性能也就越大</li><li>不能对特殊路由添加中间件</li><li>也没有处理响应头类型</li></ul><p>更好的方法是使用面向对象的方式，根据请求的<code>path</code>和<code>method</code>执行相应的中间件处理函数；而在实际开发中我们常用的是<code>koa</code>路由库<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>。本文通过解析<code>koa-router</code>的源码来达到深入学习其原理的目的。</p><h2 id="kao-router的简单使用demo"><a href="#kao-router的简单使用demo" class="headerlink" title="kao-router的简单使用demo"></a>kao-router的简单使用demo</h2><p>使用<code>koa-router</code>第一步就是新建一个<code>router</code>实例对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> pagePromptRouter <span class="built_in">require</span>(<span class="string">'./controllers/pagePrompt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 创建router实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套路由</span></span><br><span class="line">router.use(<span class="string">'/admin/prompt'</span>, pagePromptRouter.routes(), pagePrompt.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.routes()); </span><br><span class="line"><span class="comment">// 对请求进行一些限制处理</span></span><br><span class="line">app.use(router.allowedMethods()); </span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>构建应用的时候，我们的首要目标就是创建多个<code>CGI</code>接口以适配不同的业务需求，那么接下来就需要注册对应的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/queryPagePromptList'</span>, queryPagePromptList);</span><br><span class="line">router.post(<span class="string">'/deletePagePromptById'</span>, deletePagePromptById);</span><br><span class="line">router.post(<span class="string">'/savePagePrompt'</span>, savePagePrompt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryPagePromptList</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> getResult();</span><br><span class="line">ctx.body = &#123;</span><br><span class="line">    data: result.data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了让<code>koa</code>实例使用我们配置后的路由模块，需要使用<code>routes()</code>方法将路由(上面的例子中为了代码分层使用了嵌套路由)加入到应用全局的中间件函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/router.js" target="_blank" rel="noopener">router.js</a></p><p><img src="http://vfile.meituan.net/xgfe/88ed43b2f2951c77384f10d7ff4e1a6a172778.png" alt="router"></p><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/layer.js" target="_blank" rel="noopener">layer.js</a></p><p><img src="http://vfile.meituan.net/xgfe/190cd799e93c05d43fd05b1bda3574ad116451.png" alt="layer"></p><p>router和layer的关系</p><p><img src="http://p0.meituan.net/xgfe/b736ea9f7cc83ba0f0aeaf22782185ff20689.png" alt="router-layer"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Router-构造函数"><a href="#Router-构造函数" class="headerlink" title="Router 构造函数"></a>Router 构造函数</h3><p><code>Node</code>本身提供了数十个<code>HTTP</code>请求动词，<code>koa-router</code>只是实现了部分常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Router(opts) &#123;</span><br><span class="line">  if (!(this instanceof Router)) &#123;</span><br><span class="line">    return new Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  this.methods = this.opts.methods || [</span><br><span class="line">    &apos;HEAD&apos;,</span><br><span class="line">    &apos;OPTIONS&apos;,</span><br><span class="line">    &apos;GET&apos;,</span><br><span class="line">    &apos;PUT&apos;,</span><br><span class="line">    &apos;PATCH&apos;,</span><br><span class="line">    &apos;POST&apos;,</span><br><span class="line">    &apos;DELETE&apos;</span><br><span class="line">  ];</span><br><span class="line">  //省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="router-get-post-delete-all…"><a href="#router-get-post-delete-all…" class="headerlink" title="router.(get|post|delete|all…)()"></a>router.(get|post|delete|all…)()</h3><p>这些请求动词的实现是通过第三方模块<a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>支持的，然后<code>koa-router</code>内部进行了注册处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 这里的methods就是上面的methods模块提供的数组</span><br><span class="line">methods.forEach(function (method) &#123;</span><br><span class="line">  Router.prototype[method] = function (name, path, middleware) &#123;</span><br><span class="line">    var middleware;</span><br><span class="line"></span><br><span class="line">    // 这段代码做了两件事：</span><br><span class="line">    // 1.name 参数是可选的，所以要做一些参数置换的处理</span><br><span class="line">    // 2.将所有路由中间件（因为可以注册多个中间件）合并成一个数组</span><br><span class="line">    if (typeof path === &apos;string&apos; || path instanceof RegExp) &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">      path = name;</span><br><span class="line">      name = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用register方法</span><br><span class="line">    this.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面函数先判断<code>path</code>是否是字符串或者正则表达式，是因为注册路由的时候还可以为路由进行命名(命名空间方便管理)，然后准确地获取回调的函数数组(注册路由可以接收多个回调)， 这样如果匹配到某个路由，回调函数数组中的函数就会依次执行。留意到每个方法都会返回对象本身，也就是说注册路由的时候是可以支持链式调用的。</p><h3 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h3><p><code>this.register</code>接受请求路径、方法、中间件作为参数，返回已经注册的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = function (path, methods, middleware, opts) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  var router = this;</span><br><span class="line"></span><br><span class="line">  // 全部路由</span><br><span class="line">  var stack = this.stack;</span><br><span class="line"></span><br><span class="line">  // 说明路由的path是支持数组的</span><br><span class="line">  // 如果是数组的话，需要递归调用register来注册路由，因为一个path对应一个路由</span><br><span class="line">  if (Array.isArray(path)) &#123;</span><br><span class="line">    path.forEach(function (p) &#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建路由，路由就是Layer的实例</span><br><span class="line">  // methods是路由处理的http方法</span><br><span class="line">  // 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span><br><span class="line">  var route = new Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === false ? opts.end : true,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || this.opts.sensitive || false,</span><br><span class="line">    strict: opts.strict || this.opts.strict || false,</span><br><span class="line">    prefix: opts.prefix || this.opts.prefix || &quot;&quot;,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 处理路径前缀</span><br><span class="line">  if (this.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(this.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将全局的路由参数添加到每个路由中</span><br><span class="line">  Object.keys(this.params).forEach(function (param) &#123;</span><br><span class="line">    route.param(param, this.params[param]);</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 往路由数组中添加新创建的路由</span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  return route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的逻辑我们应该知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/test&apos;, async (ctx, next) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>其实它相当于下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(&apos;/test&apos;, [&apos;GET&apos;], [async (ctx, next) =&gt; &#123;&#125;], &#123; name: null &#125;);</span><br></pre></td></tr></table></figure><p><code>register</code>函数将路由作为第一个参数传入，然后方法名放入到方法数组中作为第二个参数， 第三个函数是路由的回调数组；其实每个路由注册的时候，后面都可以添加很多个函数，而这些函数都会被添加到一个数组里面，如果被匹配到，就会利用中间件机制来逐个执行这些函数。最后一个参数是将路由的命名空间传入。</p><p>对于<code>stack</code>数组，则是存储每一个路由，也就是<code>Layer</code>的实例对象，每一个路由都相当于一个<code>Layer</code>实例对象。</p><p>对于<code>Layer</code>类来说, 创建一个实例对象用于管理每个路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Layer(path, methods, middleware, opts) &#123;</span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  // 路由命名</span><br><span class="line">  this.name = this.opts.name || null;</span><br><span class="line">  // 路由对应的方法</span><br><span class="line">  this.methods = [];</span><br><span class="line">  // 路由参数名数组</span><br><span class="line">  this.paramNames = [];</span><br><span class="line">  // 路由处理中间件数组</span><br><span class="line">  this.stack = Array.isArray(middleware) ? middleware : [middleware];</span><br><span class="line">  // 存储路由方法</span><br><span class="line">  methods.forEach(function(method) &#123;</span><br><span class="line">    var l = this.methods.push(method.toUpperCase());</span><br><span class="line">    if (this.methods[l-1] === &apos;GET&apos;) &#123;</span><br><span class="line">      this.methods.unshift(&apos;HEAD&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 将添加的回调处理中间件函数添加到Layer实例对象的 stack 数组中</span><br><span class="line">  this.stack.forEach(function(fn) &#123;</span><br><span class="line">    var type = (typeof fn);</span><br><span class="line">    if (type !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot;</span><br><span class="line">        + &quot;must be a function, not `&quot; + type + &quot;`&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  this.path = path;</span><br><span class="line">  this.regexp = pathToRegExp(path, this.paramNames, this.opts);</span><br><span class="line"></span><br><span class="line">  debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到, 对于<code>Layer</code>的实例对象, 核心的逻辑还是在于将<code>path</code>转化为正则表达式用于匹配请求的路由,  然后将路由的处理中间件添加到<code>Layer</code>的<code>stack</code>数组中。 注意这里的<code>stack</code>和<code>Router</code>里面的<code>stack</code>是不一样的, <code>Router</code>的<code>stack</code>数组是存放每个路由对应的<code>Layer</code>实例对象的, 而 <code>Layer</code>实例对象里面的<code>stack</code>数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数。</p><p>下面的图详细描述了<code>Router</code>和<code>Layer</code>的关系：</p><p><img src="https://vfile.meituan.net/xgfe/baf7698bb56fa67e38d3c84ad2121a0725705.png" alt="Router和Layer的关系"></p><h3 id="router-routes"><a href="#router-routes" class="headerlink" title="router.routes()"></a>router.routes()</h3><p><code>app.use(router.routes())</code>就这样，<code>koa-router</code>就启动了，所以大家也一定会很好奇这个<code>routes</code>函数到底做了什么，但可以肯定的是<code>router.routes()</code>返回了一个中间件函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = this;</span><br><span class="line">  return dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了一个闭包，在<code>routes</code>函数内部返回了一个<code>dispatch</code>函数作为中间件。 </p><p>接下来看下<code>dispatch</code>函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">    var path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">    // router.match函数内部遍历所有路由（this.stack),</span><br><span class="line">    // 根据路径和请求方法找到对应的路由</span><br><span class="line">    // 返回的matched对象为： </span><br><span class="line">    /* </span><br><span class="line">      var matched = &#123;</span><br><span class="line">        path: [], // 保存了path匹配的路由数组</span><br><span class="line">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span><br><span class="line">        route: false // 是否有对应的路由</span><br><span class="line">      &#125;;</span><br><span class="line">    */</span><br><span class="line">    var matched = router.match(path, ctx.method);</span><br><span class="line">    var layerChain, layer, i;</span><br><span class="line">    if (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有对应的路由，则直接进入下一个中间件</span><br><span class="line">    if (!matched.route) return next();</span><br><span class="line"></span><br><span class="line">    // 找到正确的路由的path</span><br><span class="line">    var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path;</span><br><span class="line">    ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">    // 使用reduce方法将路由的所有中间件形成一条链</span><br><span class="line">    // 构建路径对应路由的处理中间件函数数组</span><br><span class="line">    // 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理</span><br><span class="line">    // 对应路由的 captures, params, 以及路由命名的函数</span><br><span class="line">    layerChain = matched.pathAndMethod.reduce(function(memo, layer) &#123;</span><br><span class="line"></span><br><span class="line">      // 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span><br><span class="line">      // 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span><br><span class="line">      memo.push(function(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">       // captures是存储路由中参数的值的数组</span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">        // params是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从captures中拿</span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">        // 执行下一个中间件</span><br><span class="line">        return next();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 将上面另外加的中间件和已有的路由中间件合并到一起</span><br><span class="line">      // 所以最终 layerChain 将会是一个中间件的数组</span><br><span class="line">      return memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    // 最后调用上面提到的compose模块提供的方法，返回将layerChain(中间件的数组) </span><br><span class="line">    // 顺序执行所有中间件的执行函数， 并立即执行。</span><br><span class="line">    return compose(layerChain)(ctx, next);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="router-allowedMethod"><a href="#router-allowedMethod" class="headerlink" title="router.allowedMethod()"></a>router.allowedMethod()</h3><p>对于<code>allowedMethod</code>方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行。同样地, 它也是以一个<code>koa</code>的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = function (options) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  var implemented = this.methods;</span><br><span class="line"></span><br><span class="line">  return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码很简单, 就是保存<code>Router</code>配置中允许的<code>HTTP</code>方法数组在闭包内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    // 从这里可以看出, allowedMethods函数是用于在中间件机制中处理返回结果的函数</span><br><span class="line">    // 先执行next函数, next函数返回的是一个Promise对象</span><br><span class="line">    return next().then(function() &#123;</span><br><span class="line">      var allowed = &#123;&#125;;</span><br><span class="line">      // allowedMethods函数的逻辑建立在statusCode没有设置或者值为404的时候</span><br><span class="line">      if (!ctx.status || ctx.status === 404) &#123;</span><br><span class="line">        // 这里的matched就是在match函数执行之后返回结果集中的 path 数组</span><br><span class="line">        // 也就是说请求路径与路由正则匹配的 layer 实例对象数组</span><br><span class="line">        ctx.matched.forEach(function (route) &#123;</span><br><span class="line">          // 将这些layer路由的HTTP方法存储起来</span><br><span class="line">          route.methods.forEach(function (method) &#123;</span><br><span class="line">            allowed[method] = method;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将上面的allowed整理为数组</span><br><span class="line">        var allowedArr = Object.keys(allowed);</span><br><span class="line">        // implemented就是Router配置中的methods数组, 也就是允许的方法</span><br><span class="line">        // 这里通过~运算判断当前的请求方法是否在配置允许的方法中</span><br><span class="line">        // 如果该方法不被允许</span><br><span class="line">        if (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          // 如果 Router 配置中配置 throw 为 true</span><br><span class="line">          if (options.throw) &#123;</span><br><span class="line">            var notImplementedThrowable;</span><br><span class="line">            // 如果配置中规定了throw抛出错误的函数, 那么就执行对应的函数</span><br><span class="line">            if (typeof options.notImplemented === &apos;function&apos;) &#123;</span><br><span class="line">              notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 如果没有则直接抛出HTTP Error</span><br><span class="line">              notImplementedThrowable = new HttpError.NotImplemented();</span><br><span class="line">            &#125;</span><br><span class="line">            // 抛出错误</span><br><span class="line">            throw notImplementedThrowable;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // Router配置throw为false</span><br><span class="line">            // 设置状态码为 501</span><br><span class="line">            ctx.status = 501;</span><br><span class="line">            // 并且设置Allow头部, 值为上面得到的允许的方法数组allowedArr</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (allowedArr.length) &#123;</span><br><span class="line">          // 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码statusCode或者 statusCode为404呢?</span><br><span class="line">          // 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理OPTIONS请求的</span><br><span class="line">          // 发出这个请求一般常见就是非简单请求, 则会发出预检请求OPTIONS</span><br><span class="line">          // 例如 application/json 格式的POST请求</span><br><span class="line">          </span><br><span class="line">          // 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods</span><br><span class="line">          if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            ctx.status = 200;</span><br><span class="line">            ctx.body = &apos;&apos;;</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125; else if (!allowed[ctx.method]) &#123;</span><br><span class="line">          // 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数</span><br><span class="line">            // 类似上面的逻辑</span><br><span class="line">            if (options.throw) &#123;</span><br><span class="line">              var notAllowedThrowable;</span><br><span class="line">              if (typeof options.methodNotAllowed === &apos;function&apos;) &#123;</span><br><span class="line">                notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                notAllowedThrowable = new HttpError.MethodNotAllowed();</span><br><span class="line">              &#125;</span><br><span class="line">              throw notAllowedThrowable;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 这里的状态码为 405</span><br><span class="line">              ctx.status = 405;</span><br><span class="line">              ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是, <code>Router.methods</code>数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误<code>501</code>, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的<code>POST</code>路由但是用<code>GET</code>方法来获取数据), 这是一个客户端错误<code>405</code>。</p><h3 id="router-use"><a href="#router-use" class="headerlink" title="router.use()"></a>router.use()</h3><p><code>use</code>函数就是用于添加中间件的, 只不过不同于<code>koa</code>中的<code>use</code>函数, <code>router</code>的<code>use</code>函数添加的中间件函数会在所有路由执行之前执行。此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">router.prototype.use = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  // 中间件函数数组</span><br><span class="line">  var middleware = Array.prototype.slice.call(arguments);</span><br><span class="line">  var path;</span><br><span class="line"></span><br><span class="line">  // 支持同时为多个路由绑定中间件函数: router.use([&apos;/use&apos;, &apos;/admin&apos;], auth());</span><br><span class="line">  if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123;</span><br><span class="line">    middleware[0].forEach(function (p) &#123;</span><br><span class="line">      // 递归调用</span><br><span class="line">      router.use.apply(router, [p].concat(middleware.slice(1)));</span><br><span class="line">    &#125;);</span><br><span class="line">    // 直接返回, 下面是非数组 path 的逻辑</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果第一个参数有传值为字符串, 说明有传路径</span><br><span class="line">  var hasPath = typeof middleware[0] === &apos;string&apos;;</span><br><span class="line">  if (hasPath) &#123;</span><br><span class="line">    path = middleware.shift();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  middleware.forEach(function (m) &#123;</span><br><span class="line">    // 如果有router属性, 说明这个中间件函数是由 Router.prototype.routes暴露出来的</span><br><span class="line">    // 属于嵌套路由</span><br><span class="line">    if (m.router) &#123;</span><br><span class="line">      // 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上</span><br><span class="line">      m.router.stack.forEach(function (nestedLayer) &#123;</span><br><span class="line">        // 如果有path, 那么为需要嵌套的路由加上路径前缀</span><br><span class="line">        if (path) nestedLayer.setPrefix(path);</span><br><span class="line">        // 如果本身的router有前缀配置, 也添加上</span><br><span class="line">        if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);</span><br><span class="line">        // 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上</span><br><span class="line">        router.stack.push(nestedLayer);</span><br><span class="line">      &#125;);</span><br><span class="line">      // 这里与register函数的逻辑类似, 注册的时候检查添加参数校验函数 params</span><br><span class="line">      if (router.params) &#123;</span><br><span class="line">        Object.keys(router.params).forEach(function (key) &#123;</span><br><span class="line">          m.router.param(key, router.params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有router属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理</span><br><span class="line">      // 如果没有path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理</span><br><span class="line">      router.register(path || &apos;(.*)&apos;, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些 http code：404, 501, 204, 405 。那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法<code>koa-router</code>不支持并且没有设置<code>throw</code>选项，则返回<code>501</code>(未实现)</li><li>如果是<code>options</code>请求，则返回 <code>204</code>(无内容)</li><li>如果请求的方法支持但没有设置<code>throw</code>选项，则返回 <code>405</code>(不允许此方法 )</li></ul><h3 id="Router-prototype-match"><a href="#Router-prototype-match" class="headerlink" title="Router.prototype.match"></a>Router.prototype.match</h3><p>我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用<code>match</code>函数.先看一下<code>match</code>函数的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.match = function (path, method) &#123;</span><br><span class="line">  // 取所有路由 Layer 实例</span><br><span class="line">  var layers = this.stack;</span><br><span class="line">  var layer;</span><br><span class="line">  // 匹配结果</span><br><span class="line">  var matched = &#123;</span><br><span class="line">    path: [],</span><br><span class="line">    pathAndMethod: [],</span><br><span class="line">    route: false</span><br><span class="line">  &#125;;</span><br><span class="line">  // 遍历路由 Router 的 stack 逐个判断</span><br><span class="line">  for (var len = layers.length, i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    layer = layers[i];</span><br><span class="line"></span><br><span class="line">    debug(&apos;test %s %s&apos;, layer.path, layer.regexp);</span><br><span class="line">    // 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则</span><br><span class="line">    if (layer.match(path)) &#123;</span><br><span class="line">      // 将对应的 Layer 实例加入到结果集的 path 数组中</span><br><span class="line">      matched.path.push(layer);</span><br><span class="line">      // 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法</span><br><span class="line">      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123;</span><br><span class="line">        // 将 layer 放入到结果集的 pathAndMethod 中</span><br><span class="line">        matched.pathAndMethod.push(layer);</span><br><span class="line">        // 这里是用于判断是否有真正匹配到路由处理函数</span><br><span class="line">        // 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空</span><br><span class="line">        if (layer.methods.length) matched.route = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return matched;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在<code>path</code>数组或者<code>pathAndMethod</code>数组中找到对应的<code>Layer</code>实例对象.</p><h2 id="router处理请求的流程"><a href="#router处理请求的流程" class="headerlink" title="router处理请求的流程"></a>router处理请求的流程</h2><p><img src="https://vfile.meituan.net/xgfe/63d452eb5a23d3fe3e1bf2e0219bceea93599.png" alt="router处理请求的流程"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>koa-router</code>用到了第三方的<code>node</code>模块</p><ul><li><p><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a>:<br> 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数。</p></li><li><p><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>：<br> <code>node</code>中支持的<code>http</code>动词，就是<code>http.METHODS</code>，可以在终端输出看看。 </p></li><li><p><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>：<br> 将路径字符串转换成强大的正则表达式，还可以输出路径参数。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过分析<code>koa-router</code>的源码，总结了：</p><ul><li><code>koa-router</code>涉及到的<code>router</code>和<code>layer</code>的关系；</li><li><code>koa-router</code>处理请求的整体流程；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。&lt;/p&gt;
    
    </summary>
    
      <category term="zuopengfei" scheme="http://xgfe.github.io/categories/zuopengfei/"/>
    
    
      <category term="node" scheme="http://xgfe.github.io/tags/node/"/>
    
      <category term="koa" scheme="http://xgfe.github.io/tags/koa/"/>
    
      <category term="koa-router" scheme="http://xgfe.github.io/tags/koa-router/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Observable</title>
    <link href="http://xgfe.github.io/2018/08/23/objectisundefined/observable/"/>
    <id>http://xgfe.github.io/2018/08/23/objectisundefined/observable/</id>
    <published>2018-08-23T04:00:00.000Z</published>
    <updated>2019-06-14T07:28:14.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。</p><a id="more"></a><h2 id="Observable是什么"><a href="#Observable是什么" class="headerlink" title="Observable是什么"></a>Observable是什么</h2><p>数据处理过程中，存在数据的生产者 (Producer) 和数据的消费者 (Consumer) ，处理方式基本分为拉取 (Pull) 和 推送 (Push)两种。</p><table><thead><tr><th></th><th>生产者</th><th>消费者</th></tr></thead><tbody><tr><td><strong>拉取</strong></td><td><strong>被动的:</strong> 当被请求时产生数据。</td><td><strong>主动的:</strong> 决定何时请求数据。</td></tr><tr><td><strong>推送</strong></td><td><strong>主动的:</strong> 按自己的节奏产生数据。</td><td><strong>被动的:</strong> 对收到的数据做出反应。</td></tr></tbody></table><p>在拉取体系中，由消费者来决定何时从生产者那里接收数据。生产者本身不知道数据是何时交付到消费者手中的。每个 JavaScript 函数都是拉取体系。函数是数据的生产者，调用该函数的代码通过从函数调用中“取出”一个单个返回值来对该函数进行消费。ES2015 引入了一种新的的拉取体系, generator 和 iterator。由消费者调用 iterator.next() 从 iterator(生产者) 那“取出”值。</p><p>在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据。在当今的 JavaScript 世界中，Promise 是最常见的推送类型。Promise(生产者) 将一个 resolve 过的值传递给已注册的回调函数(消费者)，但不同于函数的是，由 Promise 来决定何时把值“推送”给回调函数。</p><p><strong>Observable 是多个值的生产者，并将值“推送”给观察者(消费者)。</strong></p><pre><code>Function 是惰性的评估运算，调用时会同步地返回一个单一值。Generator 是惰性的评估运算，调用时会同步地返回零到(有可能的)无限多个值。Promise 是最终可能(或可能不)返回单个值的运算。Observable 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到(有可能的)无限多个值。</code></pre><p><strong>Observable 像是没有参数, 但可以泛化为多个值的函数。</strong></p><p>考虑如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> y = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure></p><p>我们期待看到的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br></pre></td></tr></table></figure></p><p>使用Rx.js，你可以使用 Observable 重写上面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出是一样的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></p><p>这是因为函数和 Observable 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observable 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observable 与之相反，不会共享副作用并且是延迟执行。</p><p>订阅 Observable 类似于调用函数。</p><p>如果你使用console.log包围一个函数调用，像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.call());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>你会看到这样的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>使用 Observable 来做同样的事：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>这证明了 foo 的订阅完全是同步的，就像函数一样。Observable 传递值可以是同步的，也可以是异步的。<br>那么 Observable 和 函数的区别是什么呢？Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。你无法这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 死代码，永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数只能返回一个值。但 Observable 可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>); <span class="comment">// “返回”另外一个值</span></span><br><span class="line">  observer.next(<span class="number">200</span>); <span class="comment">// 还可以再“返回”值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>同步输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>但你也可以异步地“返回”值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>);</span><br><span class="line">  observer.next(<span class="number">200</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">300</span>); <span class="comment">// 异步执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br><span class="line">300</span><br></pre></td></tr></table></figure></p><p>结论:</p><pre><code>func.call() 意思是 &quot;同步地给我一个值&quot;observable.subscribe() 意思是 &quot;给我任意数量的值，无论是同步还是异步&quot;</code></pre><h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> once = <span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    f(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// just return a subscribe function</span></span><br><span class="line">  <span class="comment">// error and complete can be invoked just once</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next, error, complete</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unsubscribe = f(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(val)</span><br><span class="line">      &#125;,</span><br><span class="line">      error: once(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        error &amp;&amp; error(err)</span><br><span class="line">      &#125;),</span><br><span class="line">      complete: once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        complete &amp;&amp; complete()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should return a dispose function</span></span><br><span class="line">    <span class="comment">// think case like timeout, interval, websocket connection...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      unsubscribe &amp;&amp; unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> number$ = create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>)</span><br><span class="line">  observer.next(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  observer.error(<span class="built_in">Error</span>(<span class="string">'crash'</span>))</span><br><span class="line"></span><br><span class="line">  observer.next(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe</span></span><br><span class="line">number$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// error: Error: crash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval = <span class="function"><span class="params">delay</span> =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), delay)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line"></span><br><span class="line">    clearInterval(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unsubscribe = interval$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 0</span></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// next: 3</span></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line"></span><br><span class="line">setTimeout(unsubscribe, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Observable 作为多个值的生产者这样的数据抽象，在使用时，我们还需要操作符。操作符是允许复杂的异步代码以声明式的方式进行轻松组合的基础代码单元。操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。</p><p><img src="https://cn.rx.js.org/img/map.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(f(x))</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/filter.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      f(x) &amp;&amp; observer.next(x)</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/merge.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        i === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineLatest.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineLatest = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        !(i <span class="keyword">in</span> arr) &amp;&amp; (k += <span class="number">1</span>)</span><br><span class="line">        arr[i] = x</span><br><span class="line"></span><br><span class="line">        k === l &amp;&amp; observer.next(arr)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineAll.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineAll = <span class="function">(<span class="params">...observables</span>) =&gt;</span> observer =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">      !(i <span class="keyword">in</span> arr) &amp;&amp; (n += <span class="number">1</span>)</span><br><span class="line">      arr[i] = x</span><br><span class="line"></span><br><span class="line">      n === l &amp;&amp; observer(arr)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/share.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> share = <span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> obs = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> observable(</span><br><span class="line">    x =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.next(x)),</span><br><span class="line">    err =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.error(err)),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.complete())</span><br><span class="line">      obs = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (finished || obs.indexOf(observer) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obs.push(observer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazy subscribe until the first observer occurs</span></span><br><span class="line">    obs.length === <span class="number">1</span> &amp;&amp; start()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/take.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function"><span class="params">n</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> unsubscribe = observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(x)</span><br><span class="line"></span><br><span class="line">      n--</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">        observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concat.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= l) &#123;</span><br><span class="line">      <span class="keyword">return</span> observer.complete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observables[n](</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        f(n + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concatMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concatMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> observables = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> c = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> g = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flushing || !observables.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> observable = observables.shift()</span><br><span class="line"></span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        observer.next(x)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">          observables = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">return</span> observer.complete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observables.push(f(x))</span><br><span class="line">      g()</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      c = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/switchMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> switchMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">let</span> unsubscribe</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (unsubscribe) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      current = f(x)</span><br><span class="line"></span><br><span class="line">      unsubscribe = current(</span><br><span class="line">        x =&gt; observer.next(x),</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          observer.error(err)</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          observer.complete()</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从数据处理的拉取和推送的方式着手，了解了 Observable 是基于推送模型的多值生产者的抽象，像是没有参数, 但可以泛化为多个值的函数。通过代码实现了一个 Observable 的创建函数，还实现了很多操作符。这只是个开始，在工作和学习中，你要认真思考自己的场景，观察这个场景中是不是存在着类似多个管道产生值，这些管道也存在着组合变换的逻辑，这时候，Observable 就可以大显身手了。从编程范式上来讲，使用 Observable，其实是 反应式编程（Reactive Programming） 的思维，它可以帮助我们摆脱命令式的状态处理，状态和逻辑杂合在一起，用声明式的方式去组合我们的逻辑，希望你能去探索下 Reactive Programming 和 Functional Reactive Programming的世界。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">The introduction to Reactive Programming you’ve been missing</a></li><li><a href="https://zhuanlan.zhihu.com/p/20213244" target="_blank" rel="noopener">谈谈FRP和Observable（一）</a></li><li><a href="http://jerryzou.com/posts/rxjs-practice-01/" target="_blank" rel="noopener">RxJS 实战篇（一）拖拽</a></li><li><a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">http://reactivex.io/rxjs/</a></li><li><a href="https://cn.rx.js.org/manual/overview.html" target="_blank" rel="noopener">cn.rx.js.org</a></li><li><a href="https://github.com/btroncone/learn-rxjs" target="_blank" rel="noopener">learn-rxjs</a></li><li><a href="https://github.com/ichpuchtli/awesome-rxjs" target="_blank" rel="noopener">awesome-rxjs</a></li><li><a href="https://github.com/staltz/xstream" target="_blank" rel="noopener">xstream</a></li><li><a href="https://github.com/paldepind/flyd" target="_blank" rel="noopener">flyd</a></li><li><a href="https://github.com/staltz/callbag-basics/" target="_blank" rel="noopener">callbag-basics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。&lt;/p&gt;
    
    </summary>
    
      <category term="tianzhen" scheme="http://xgfe.github.io/categories/tianzhen/"/>
    
      <category term="Observable" scheme="http://xgfe.github.io/categories/tianzhen/Observable/"/>
    
    
      <category term="Observable" scheme="http://xgfe.github.io/tags/Observable/"/>
    
      <category term="RxJS" scheme="http://xgfe.github.io/tags/RxJS/"/>
    
      <category term="Functional Reactive Programming" scheme="http://xgfe.github.io/tags/Functional-Reactive-Programming/"/>
    
  </entry>
  
  <entry>
    <title>angularjs的双向数据绑定</title>
    <link href="http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs双向绑定/</id>
    <published>2018-08-15T13:00:00.000Z</published>
    <updated>2019-06-14T07:08:56.540Z</updated>
    
    <content type="html"><![CDATA[<p>angularjs的双向数据绑定原理及简单的实现。</p><a id="more"></a><p>之前对vue.js的双向绑定比较感兴趣，自己动手实现了一个类似于vue.js的mvvm框架。vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。其核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">this.watch = function(obj, callback) &#123;</span><br><span class="line">this.$observeObj = function() &#123;</span><br><span class="line">var that = this;</span><br><span class="line">this.callback = callback;</span><br><span class="line">//console.log(Object.keys(obj));</span><br><span class="line">Object.keys(obj).forEach(function(prop) &#123;</span><br><span class="line">var val = obj[prop];</span><br><span class="line">Object.defineProperty(obj, prop, &#123;</span><br><span class="line">get: function() &#123;</span><br><span class="line">return val;</span><br><span class="line">&#125;,</span><br><span class="line">set: function(newVal) &#123;</span><br><span class="line">var temp = val;</span><br><span class="line">//console.log(newVal);</span><br><span class="line">val = newVal;</span><br><span class="line">//通知所有订阅者改变</span><br><span class="line"></span><br><span class="line">that.cache.forEach(function(item) &#123;</span><br><span class="line">if (item[prop]) &#123;</span><br><span class="line">item[prop] = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">that.callback();</span><br><span class="line">&#125;,    </span><br><span class="line">enumerable: true,</span><br><span class="line">   configurable: true</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$observeObj();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>set</code>属性在改变数据的同时触发视图的更新。</p><p>angularjs实现数据双向绑定与vue.js有所不同，它依赖于脏值检测，这里我写了一个简易的版本，其主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">initWatch() &#123;  </span><br><span class="line">    for (let i = 0, len = this.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">        //用来保证初值的正常加载，以及当我改变input框中的值为空时能正常显示</span><br><span class="line">        this.flags.push(false);</span><br><span class="line">        this.watch(() =&gt; &#123;</span><br><span class="line">            let value = this.elements[i].value;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            let key = this.elements[i].getAttribute(&apos;ng-model&apos;);</span><br><span class="line">            const elementType = this.elements[i].tagName.toLowerCase();</span><br><span class="line"></span><br><span class="line">            this.data[key] = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            //设置属性值</span><br><span class="line">            if (elementType === &apos;input&apos; || elementType === &apos;textarea&apos; || elementType === &apos;select&apos;) &#123;</span><br><span class="line">                this.elements[i].value = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.elements[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let j = 0, len = this.bind.length; j &lt; len; j++) &#123;</span><br><span class="line">                let item = this.bind[i].getAttribute(&apos;ng-bind&apos;);</span><br><span class="line">                if (item === key) &#123;</span><br><span class="line">                    this.bind[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">    document.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听函数</span><br><span class="line">watch(watchFn, callback) &#123;</span><br><span class="line">    this.watchers.push(&#123;</span><br><span class="line">        watchFn: watchFn,</span><br><span class="line">        callback: callback || function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新数据</span><br><span class="line">digest() &#123;</span><br><span class="line">    let dirty;</span><br><span class="line">    do &#123;</span><br><span class="line">        dirty = false;</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = this.watchers.length; i &lt; len; i++) &#123;</span><br><span class="line">        let newVal = this.watchers[i].watchFn();</span><br><span class="line">        let oldVal = this.watchers[i].last;</span><br><span class="line"></span><br><span class="line">        if (newVal !== oldVal) &#123;</span><br><span class="line">            this.watchers[i].callback(newVal, oldVal);</span><br><span class="line">            dirty = true;</span><br><span class="line">            this.watchers[i].last = newVal;</span><br><span class="line">            this.flags[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; while(dirty);</span><br></pre></td></tr></table></figure><p><code>watch</code>接受两个参数（这里只考虑了单值的情况，用<code>ng-bind</code>来绑定值），监听的数据与监听的回调函数。digest函数只会在指定事件触发后，才执行，比如这里input框    ,改变输入的值会触发keyup事件，调用<code>digest</code>函数，这个函数会遍历所有的<code>watchers</code>，对比以前的值和新值是否一样，如果不一样就执行回调函数更新数据和视图。<br>我自己实现的版本很基础也很片面，我们可以看看angularjs源码对这部分的描述（这里看angularjs 1.3.20版本）：</p><h3 id="parse"><a href="#parse" class="headerlink" title="$parse"></a>$parse</h3><p><code>parse</code>是一个解析函数，angularjs中单独在一个名叫parse.js的文件中。我们从<code>$get</code>方法出发，它最后会返回一个<code>$parse</code>函数，这个函数的核心部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lexer = new Lexer(parseOptions);</span><br><span class="line">var parser = new Parser(lexer, $filter, parseOptions);</span><br><span class="line">parsedExpression = parser.parse(exp);</span><br></pre></td></tr></table></figure><p>其中，<code>Lexer</code>这个构造函数中的<code>lex</code>方法用于解析传入数据的所有特殊情况，比如当我检测到这个监控数据为带有引号的字符串时（检查到第一个字符为单引号或者双引号），readString方法就会继续解析后面的字符，最后将结果存到this.tokens中，同理，当检测到是number类型的便会执行readNumber方法，将结果存在this.tokens中。<code>parse</code>就是处理<code>lexer</code>实例返回的this.tokens值，生成执行表达式，其实就是返回一个执行函数。因为这个函数中对四则运算也做了处理，所以当输入1+2的表达式时，最终会返回结果3。  </p><h3 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$watch: function(watchExp, listener, objectEquality) &#123;</span><br><span class="line">    var get = $parse(watchExp);</span><br><span class="line"></span><br><span class="line">    if (get.$$watchDelegate) &#123;</span><br><span class="line">      return get.$$watchDelegate(this, listener, objectEquality, get);</span><br><span class="line">    &#125;</span><br><span class="line">    var scope = this,</span><br><span class="line">        array = scope.$$watchers,</span><br><span class="line">        watcher = &#123;</span><br><span class="line">          fn: listener,</span><br><span class="line">          last: initWatchVal,</span><br><span class="line">          get: get,</span><br><span class="line">          exp: watchExp,</span><br><span class="line">          eq: !!objectEquality</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">    if (!isFunction(listener)) &#123;</span><br><span class="line">      watcher.fn = noop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!array) &#123;</span><br><span class="line">      array = scope.$$watchers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // we use unshift since we use a while loop in $digest for speed.</span><br><span class="line">    // the while loop reads in reverse order.</span><br><span class="line">    array.unshift(watcher);</span><br><span class="line"></span><br><span class="line">    return function deregisterWatch() &#123;</span><br><span class="line">      arrayRemove(array, watcher);</span><br><span class="line">      lastDirtyWatch = null;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>$watch</code>主要接收三个参数:监听的数据，监听的回调函数，是否深度监听。  </p><ul><li>watch参数：  </li><li>fn：监听函数，当新旧值不想等的时候会执行  </li><li>last：存放旧值  </li><li>get：保存监控表达式对应的函数，主要用来获取表达式的值做新旧值的对比  </li><li>exp：原始监控表达式  </li><li>eq：是否深度比较，存储的是<code>$watch</code>的第三个参数  </li></ul><p>当需要监听数据的时候，<code>get.$$watchDelegate</code>是否存在取决于<code>parse</code>中的parsedExpression.constant的值，而它的值取决于<code>$watch</code>监听的数据是否为常量，如果是常量的话，这个监听函数只会执行一次，不会被push进<code>$$watchers</code>的队列中，如果监听的是变量，那么这个<code>watch</code>会被push到<code>$$watchers</code>队列的最前面。最后会返回一个函数，这个函数的功能就是删除当前的<code>watch</code>，所以如果我们想取消这个监听，可以用一个变量接收<code>$watch</code>的返回值，再执行这个函数就达到了效果。</p><h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$evalAsync: function(expr, locals) &#123;</span><br><span class="line">// if we are outside of an $digest loop and this is the first time we are scheduling async</span><br><span class="line">// task also schedule async auto-flush</span><br><span class="line">if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) &#123;</span><br><span class="line">  $browser.defer(function() &#123;</span><br><span class="line">    if (asyncQueue.length) &#123;</span><br><span class="line">      $rootScope.$digest();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncQueue.push(&#123;scope: this, expression: expr, locals: locals&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>$evalAsync</code>函数的作用是延迟执行表达式，<code>$$asyncQueue</code>是一个异步的队列，保存着所有需要异步执行的表达式。<code>$bowser.defer</code>是用setTimeout来实现的。</p><h3 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">$digest: function() &#123;</span><br><span class="line">       var watch, value, last,</span><br><span class="line">           watchers,</span><br><span class="line">           length,</span><br><span class="line">           dirty, ttl = TTL,</span><br><span class="line">           next, current, target = this,</span><br><span class="line">           watchLog = [],</span><br><span class="line">           logIdx, logMsg, asyncTask;</span><br><span class="line"></span><br><span class="line">       beginPhase(&apos;$digest&apos;);</span><br><span class="line">       // Check for changes to browser url that happened in sync before the call to $digest</span><br><span class="line">       $browser.$$checkUrlChange();</span><br><span class="line"></span><br><span class="line">       if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123;</span><br><span class="line">         // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span><br><span class="line">         // cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span><br><span class="line">         $browser.defer.cancel(applyAsyncId);</span><br><span class="line">         flushApplyAsync();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">       do &#123; // &quot;while dirty&quot; loop</span><br><span class="line">         dirty = false;</span><br><span class="line">         current = target;</span><br><span class="line"></span><br><span class="line">         while (asyncQueue.length) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">             asyncTask = asyncQueue.shift();</span><br><span class="line">             asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</span><br><span class="line">           &#125; catch (e) &#123;</span><br><span class="line">             $exceptionHandler(e);</span><br><span class="line">           &#125;</span><br><span class="line">           lastDirtyWatch = null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         traverseScopesLoop:</span><br><span class="line">          do &#123; // &quot;traverse the scopes&quot; loop</span><br><span class="line">           if ((watchers = current.$$watchers)) &#123;</span><br><span class="line">             // process our watches</span><br><span class="line">             length = watchers.length;</span><br><span class="line">             while (length--) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 watch = watchers[length];</span><br><span class="line">                 // Most common watches are on primitives, in which case we can short</span><br><span class="line">                 // circuit it with === operator, only when === fails do we use .equals</span><br><span class="line">                 if (watch) &#123;</span><br><span class="line">                   if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</span><br><span class="line">                       !(watch.eq</span><br><span class="line">                           ? equals(value, last)</span><br><span class="line">                           : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">                              &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123;</span><br><span class="line">                     dirty = true;</span><br><span class="line">                     lastDirtyWatch = watch;</span><br><span class="line">                     watch.last = watch.eq ? copy(value, null) : value;</span><br><span class="line">                     watch.fn(value, ((last === initWatchVal) ? value : last), current);</span><br><span class="line">                     if (ttl &lt; 5) &#123;</span><br><span class="line">                       logIdx = 4 - ttl;</span><br><span class="line">                       if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">                       watchLog[logIdx].push(&#123;</span><br><span class="line">                         msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">                         newVal: value,</span><br><span class="line">                         oldVal: last</span><br><span class="line">                       &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">                     // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">                     // have already been tested.</span><br><span class="line">                     dirty = false;</span><br><span class="line">                     break traverseScopesLoop;</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125; catch (e) &#123;</span><br><span class="line">                 $exceptionHandler(e);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">            // Insanity Warning: scope depth-first traversal</span><br><span class="line">           // yes, this code is a bit crazy, but it works and we have tests to prove it!</span><br><span class="line">           // this piece should be kept in sync with the traversal in $broadcast</span><br><span class="line">           if (!(next = (current.$$childHead ||</span><br><span class="line">               (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">             while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">               current = current.$parent;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while ((current = next));</span><br><span class="line"></span><br><span class="line">         // `break traverseScopesLoop;` takes us to here</span><br><span class="line"></span><br><span class="line">         if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">           clearPhase();</span><br><span class="line">           throw $rootScopeMinErr(&apos;infdig&apos;,</span><br><span class="line">               &apos;&#123;0&#125; $digest() iterations reached. Aborting!\n&apos; +</span><br><span class="line">               &apos;Watchers fired in the last 5 iterations: &#123;1&#125;&apos;,</span><br><span class="line">               TTL, watchLog);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; while (dirty || asyncQueue.length);</span><br><span class="line"></span><br><span class="line">       clearPhase();</span><br><span class="line"></span><br><span class="line">       while (postDigestQueue.length) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">           postDigestQueue.shift()();</span><br><span class="line">         &#125; catch (e) &#123;</span><br><span class="line">           $exceptionHandler(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p><code>asyncQueue</code>代表异步队列，这里有两层循环，外层循环是为了保证所有的model都能被检测到，循环的两个条件，一是asyncQueue.length不为空；二是dirty为true,在监控watch的值的变化时，会将dirty置为true，循环开始会执行<code>asyncQueue</code>队列中的表达式。</p><p>内层循环用来遍历所有的watch函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(value = watch.get(current)) !== (last = watch.last) &amp;&amp;  </span><br><span class="line">!(watch.eq</span><br><span class="line">    ? equals(value, last)</span><br><span class="line">    : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">       &amp;&amp; isNaN(value) &amp;&amp; isNaN(last))))</span><br></pre></td></tr></table></figure><p>判断新值和旧值是否发生了变化，并且用watch.eq判断是否为深度监听，<code>equals</code>函数用来比较两个值是否相等，这个函数把所有可能的情况都考虑了进去，以前自己实现过两个值的比较，但是对于像DateRegExp这种类型的值的比较是没有考虑的，也正好查漏补缺。<br>内层循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">  while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">    current = current.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码表示，在当前作用域下执行完对watch的监控之后，还要继续查找它的子作用域，兄弟作用域，父作用域，如果next有值就会一直循环，直到这一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (ttl &lt; 5) &#123;</span><br><span class="line">    logIdx = 4 - ttl;</span><br><span class="line">    if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">    watchLog[logIdx].push(&#123;</span><br><span class="line">      msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">      newVal: value,</span><br><span class="line">      oldVal: last</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">  // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">  // have already been tested.</span><br><span class="line">  dirty = false;</span><br><span class="line">  break traverseScopesLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的ttl的初始值为10（默认值），ttl的存在就是为了防止循环次数过多，如果超过最大次数，就会throw错误并告诉开发者循环可能永远不会稳定。当ttl小于5的时候开始记录<code>watchLog</code>对象，如果当前的watch与最后一次检查的<code>lastDirtyWatch</code>相等的话就跳出内层循环同时结束外层循环。最后会执行<code>postDigestQueue</code>队列中的函数，这个跟asyncQueue不同的是，它不会主动触发<code>digest</code>方法,只是往<code>postDigestQueue</code>队列中增加执行表达式，在<code>digest</code>内最后执行。</p><p>通过阅读angularjs脏值检测的源码部分，对它底层的实现有了大致的了解，对于parse.js可以作为一个字符串的解析器，实际场景比如实现一个计算器，equals函数用来比较两个值是否相等，都是值得借鉴的部分。与之前实现的简易版本比较，实际angularjs框架做的东西就多得多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;angularjs的双向数据绑定原理及简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangxiaotong" scheme="http://xgfe.github.io/categories/yangxiaotong/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 源码学习</title>
    <link href="http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/"/>
    <id>http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/</id>
    <published>2018-07-11T04:00:00.000Z</published>
    <updated>2019-06-14T07:08:56.524Z</updated>
    
    <content type="html"><![CDATA[<p>dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。<br><a id="more"></a></p><p>📚<a href="https://github.com/iamkun/dayjs/blob/master/docs/zh-cn/API-reference.md" target="_blank" rel="noopener">官方 API 文档（中文）</a></p><h2 id="一-特性"><a href="#一-特性" class="headerlink" title="一 特性"></a>一 特性</h2><ul><li>和 Moment.js 相同的 API 和用法</li><li>不可变数据（Immutable）</li><li>支持链式操作（Chainable）</li><li>l18n 国际化</li><li>仅 2kb 大小</li><li>全浏览器兼容</li></ul><p>基本用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(<span class="string">'month'</span>).add(<span class="number">1</span>, <span class="string">'day'</span>).set(<span class="string">'year'</span>, <span class="number">2018</span>).format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="二-解析"><a href="#二-解析" class="headerlink" title="二 解析"></a>二 解析</h2><h3 id="构造器-dayjs-existing-string-number-Date-Dayjs"><a href="#构造器-dayjs-existing-string-number-Date-Dayjs" class="headerlink" title="构造器 dayjs(existing?: string | number | Date | Dayjs)"></a>构造器 dayjs(existing?: string | number | Date | Dayjs)</h3><p>从源码可以看出，调用 dayjs 时会返回一个 Dayjs 对象，Dayjs 构造器调用了 parseDate 方法，返回了一个全新的包含 Javascript Date 对象的 Dayjs 的对象；其他的值都是根据 Javascript Date 对象得来的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="function">(<span class="params">date, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDayjs(date)) &#123;</span><br><span class="line">    <span class="keyword">return</span> date.clone()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cfg = c || &#123;&#125;</span><br><span class="line">  cfg.date = date</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dayjs(cfg) <span class="comment">// eslint-disable-line no-use-before-define</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parseDate = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg</span><br><span class="line">  <span class="keyword">if</span> (date === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="literal">NaN</span>) <span class="comment">// Treat null as an invalid date</span></span><br><span class="line">  <span class="keyword">if</span> (Utils.isUndefined(date)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> date</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> date === <span class="string">'string'</span>)</span><br><span class="line">    &amp;&amp; (<span class="regexp">/.*[^Z]$/i</span>.test(date)) <span class="comment">// looking for a better way</span></span><br><span class="line">    &amp;&amp; (reg = date.match(C.REGEX_PARSE))) &#123;</span><br><span class="line">    <span class="comment">// 2018-08-08 or 20180808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(</span><br><span class="line">      reg[<span class="number">1</span>], reg[<span class="number">2</span>] - <span class="number">1</span>, reg[<span class="number">3</span>] || <span class="number">1</span>,</span><br><span class="line">      reg[<span class="number">5</span>] || <span class="number">0</span>, reg[<span class="number">6</span>] || <span class="number">0</span>, reg[<span class="number">7</span>] || <span class="number">0</span>, reg[<span class="number">8</span>] || <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date) <span class="comment">// timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dayjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(cfg) <span class="comment">// for plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">  parse(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$d = parseDate(cfg.date)</span><br><span class="line">    <span class="keyword">this</span>.init(cfg)</span><br><span class="line">  &#125;</span><br><span class="line">  init(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$y = <span class="keyword">this</span>.$d.getFullYear()</span><br><span class="line">    <span class="keyword">this</span>.$M = <span class="keyword">this</span>.$d.getMonth()</span><br><span class="line">    <span class="keyword">this</span>.$D = <span class="keyword">this</span>.$d.getDate()</span><br><span class="line">    <span class="keyword">this</span>.$W = <span class="keyword">this</span>.$d.getDay()</span><br><span class="line">    <span class="keyword">this</span>.$H = <span class="keyword">this</span>.$d.getHours()</span><br><span class="line">    <span class="keyword">this</span>.$m = <span class="keyword">this</span>.$d.getMinutes()</span><br><span class="line">    <span class="keyword">this</span>.$s = <span class="keyword">this</span>.$d.getSeconds()</span><br><span class="line">    <span class="keyword">this</span>.$ms = <span class="keyword">this</span>.$d.getMilliseconds()</span><br><span class="line">    <span class="keyword">this</span>.$L = <span class="keyword">this</span>.$L || parseLocale(cfg.locale, <span class="literal">null</span>, <span class="literal">true</span>) || L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 init 实例方法中，使用实例属性 $d（为 JavaScript 原生 Date 对象）来获取 年、月、日、周、时、分、秒、毫秒，且保存在实例中。并且调用 parseLocale 函数来获取语言，赋值给 Dayjs 实例的 $L 属性。</p><p>可传参数有5类：  </p><h5 id="1-当前时间"><a href="#1-当前时间" class="headerlink" title="1.当前时间"></a>1.当前时间</h5><p>dayjs 本质上是个函数，因此可以直接运行该函数，得到包含当前时间和日期的 Dayjs 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs();</span><br></pre></td></tr></table></figure></p><h5 id="2-标准的-ISO-8601-时间字符串"><a href="#2-标准的-ISO-8601-时间字符串" class="headerlink" title="2.标准的 ISO 8601 时间字符串"></a>2.标准的 ISO 8601 时间字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="string">"2018-07-14"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-解析-Unix-时间戳-毫秒"><a href="#3-解析-Unix-时间戳-毫秒" class="headerlink" title="3.解析 Unix 时间戳(毫秒)"></a>3.解析 Unix 时间戳(毫秒)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="number">1531469940578</span>);</span><br></pre></td></tr></table></figure><h5 id="4-解析-Date-对象"><a href="#4-解析-Date-对象" class="headerlink" title="4.解析 Date 对象"></a>4.解析 Date 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h5 id="5-解析-dayjs-对象"><a href="#5-解析-dayjs-对象" class="headerlink" title="5.解析 dayjs 对象"></a>5.解析 dayjs 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(dayjs());</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>dayjs 对象是不可变的如果要复制对象，需要调用 .clone()，或者是在解析一个 dayjs 对象。 向 dayjs() 里传入一个 Dayjs 对象也能实现同样的效果。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().clone();</span><br><span class="line">dayjs(Dayjs);</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function">(<span class="params">date, instance</span>) =&gt;</span> dayjs(date, &#123; <span class="attr">locale</span>: instance.$L &#125;)</span><br><span class="line">clone() &#123;</span><br><span class="line">  <span class="keyword">return</span> wrapper(<span class="keyword">this</span>.toDate(), <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>检测当前 Dayjs 对象是否是一个有效的时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().isValid();</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isValid() &#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="keyword">this</span>.$d.toString() === <span class="string">'Invalid Date'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三-获取-设置"><a href="#三-获取-设置" class="headerlink" title="三 获取+设置"></a>三 获取+设置</h2><h5 id="获取各种时间"><a href="#获取各种时间" class="headerlink" title="获取各种时间"></a>获取各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dayjs().year();        <span class="comment">// 年</span></span><br><span class="line">dayjs().month();       <span class="comment">// 月</span></span><br><span class="line">dayjs().date();        <span class="comment">// 日</span></span><br><span class="line">dayjs().day();         <span class="comment">// 星期(星期天 0, 星期六 6)</span></span><br><span class="line">dayjs().hour();        <span class="comment">// 时</span></span><br><span class="line">dayjs().minute();      <span class="comment">// 分</span></span><br><span class="line">dayjs().second();      <span class="comment">// 秒</span></span><br><span class="line">dayjs().millisecond(); <span class="comment">// 毫秒</span></span><br></pre></td></tr></table></figure><h5 id="设置各种时间"><a href="#设置各种时间" class="headerlink" title="设置各种时间"></a>设置各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().set(unit : <span class="built_in">String</span>, <span class="attr">value</span> : Int);</span><br><span class="line">dayjs().set(<span class="string">'date'</span>, <span class="number">1</span>);</span><br><span class="line">dayjs().set(<span class="string">'month'</span>, <span class="number">3</span>); <span class="comment">// 四月</span></span><br><span class="line">dayjs().set(<span class="string">'second'</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>设置时间也是通过返回一个新的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(string, int) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clone().$set(string, int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四-格式化显示"><a href="#四-格式化显示" class="headerlink" title="四 格式化显示"></a>四 格式化显示</h2><p>格式化显示和 momentjs 一样，通过 .format() 即可，返回的是 String 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().format(<span class="built_in">String</span>);</span><br><span class="line">dayjs().format();             <span class="comment">// "2018-07-13T20:10:31+08:00"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// "2018-07-13"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY/MM/DD'</span>); <span class="comment">// "2018/07/13"</span></span><br></pre></td></tr></table></figure></p><h2 id="五-操作"><a href="#五-操作" class="headerlink" title="五 操作"></a>五 操作</h2><h5 id="增加和减少"><a href="#增加和减少" class="headerlink" title="增加和减少"></a>增加和减少</h5><p>在此之前先看看源码实现的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 部分源码</span></span><br><span class="line">add(number, units) &#123;</span><br><span class="line">  number = <span class="built_in">Number</span>(number) <span class="comment">// eslint-disable-line no-param-reassign</span></span><br><span class="line">  <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">  <span class="keyword">const</span> instanceFactory = <span class="function">(<span class="params">u, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">this</span>.set(C.DATE, <span class="number">1</span>).set(u, n + number)</span><br><span class="line">    <span class="keyword">return</span> date.set(C.DATE, <span class="built_in">Math</span>.min(<span class="keyword">this</span>.$D, date.daysInMonth()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.M) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.M, <span class="keyword">this</span>.$M)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.Y) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.Y, <span class="keyword">this</span>.$y)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> step</span><br><span class="line">  <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">    <span class="keyword">case</span> C.MIN:</span><br><span class="line">      step = C.MILLISECONDS_A_MINUTE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.H:</span><br><span class="line">      step = C.MILLISECONDS_A_HOUR</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.D:</span><br><span class="line">      step = C.MILLISECONDS_A_DAY</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.W:</span><br><span class="line">      step = C.MILLISECONDS_A_WEEK</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.S:</span><br><span class="line">      step = C.MILLISECONDS_A_SECOND</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// ms</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextTimeStamp = <span class="keyword">this</span>.valueOf() + (number * step)</span><br><span class="line">  <span class="keyword">return</span> wrapper(nextTimeStamp, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">subtract(number, string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.add(number * <span class="number">-1</span>, string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dayjs 类中 add、subtract 等方法，都会通过 wrapper 返回一个新的 Dayjs 实例，是通过使用 Dayjs 类中的 clone() 方法实现的。所以，通过这个 clone() 方法，实现了 dayjs 的 immutable 特性。<br>当增加或减少的单位是年或月时，会先将日设置为1，然后再加减，最后再比较当前月的总天数和原来的天数（主要是解决像2月只有28天这类问题），取较小的值再返回；对于天／周／时／分／秒则是按照时间戳来计算，再通过 wrapper 返回一个新的 Date 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().add(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().add(<span class="number">5</span>, <span class="string">'day'</span>);</span><br><span class="line">dayjs().subtract(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().subtract(<span class="number">2</span>, <span class="string">'year'</span>);</span><br></pre></td></tr></table></figure></p><h5 id="开头和末尾"><a href="#开头和末尾" class="headerlink" title="开头和末尾"></a>开头和末尾</h5><p>返回当前时间的开头时间的 Dayjs 对象，如月份的第一天。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().startOf(<span class="string">'year'</span>).format(<span class="string">'YYYY-MM-DD'</span>);  <span class="comment">// 2018-01-01</span></span><br></pre></td></tr></table></figure></p><p>返回当前时间的末尾时间的 Dayjs 对象，如月份的最后一天。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().endOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().endOf(<span class="string">'month'</span>).format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// 2018-07-31</span></span><br></pre></td></tr></table></figure><h2 id="六-时间差"><a href="#六-时间差" class="headerlink" title="六 时间差"></a>六 时间差</h2><p>时间差是两个 dayjs 对象的之差所得的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().diff(Dayjs, unit);</span><br><span class="line">dayjs().diff(dayjs(<span class="string">'2000-2-1'</span>), <span class="string">'years'</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p><p>源码逻辑是先计算出两个时间相差的毫秒数和月数，再根据传入的单位去选择计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff(input, units, float) &#123;</span><br><span class="line">    <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">    <span class="keyword">const</span> that = dayjs(input)</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="keyword">this</span> - that</span><br><span class="line">    <span class="keyword">let</span> result = Utils.monthDiff(<span class="keyword">this</span>, that)</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">      <span class="keyword">case</span> C.Y:</span><br><span class="line">        result /= <span class="number">12</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.M:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.Q:</span><br><span class="line">        result /= <span class="number">3</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.W:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_WEEK</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.D:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_DAY</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.H:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_HOUR</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.MIN:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_MINUTE</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.S:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_SECOND</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// milliseconds</span></span><br><span class="line">        result = diff</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> float ? result : Utils.absFloor(result)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="七-其他方法"><a href="#七-其他方法" class="headerlink" title="七 其他方法"></a>七 其他方法</h2><h5 id="获取-unix-毫秒时间戳："><a href="#获取-unix-毫秒时间戳：" class="headerlink" title="获取 unix 毫秒时间戳："></a>获取 unix 毫秒时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().valueOf(); <span class="comment">// 1531633650522</span></span><br></pre></td></tr></table></figure><h5 id="获取-unix-秒级时间戳："><a href="#获取-unix-秒级时间戳：" class="headerlink" title="获取 unix 秒级时间戳："></a>获取 unix 秒级时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().unix(); <span class="comment">// 1531633677</span></span><br></pre></td></tr></table></figure><h5 id="返回月份的天数："><a href="#返回月份的天数：" class="headerlink" title="返回月份的天数："></a>返回月份的天数：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().daysInMonth(); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h5 id="获取-Date-对象："><a href="#获取-Date-对象：" class="headerlink" title="获取 Date 对象："></a>获取 Date 对象：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toDate(); <span class="comment">// Sun Jul 15 2018 13:48:41 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure><h5 id="获取数组格式："><a href="#获取数组格式：" class="headerlink" title="获取数组格式："></a>获取数组格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toArray(); <span class="comment">//[2018, 6, 13, 20, 34, 13, 424];</span></span><br></pre></td></tr></table></figure><h5 id="获取对象格式："><a href="#获取对象格式：" class="headerlink" title="获取对象格式："></a>获取对象格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toObject();<span class="comment">// &#123;years: 2018, months: 6, date: 13, hours: 20, minutes: 34...&#125;</span></span><br></pre></td></tr></table></figure><h2 id="八-dayjs-插件用法"><a href="#八-dayjs-插件用法" class="headerlink" title="八 dayjs 插件用法"></a>八 dayjs 插件用法</h2><p>dayjs 的插件，通过挂载到 dayjs 函数下的 extend 函数加载，然后使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plugin <span class="comment">// 导入插件</span></span><br><span class="line">dayjs.extend(plugin, options) <span class="comment">// 加载插件的同时，加入插件所需要的参数</span></span><br></pre></td></tr></table></figure></p><p>使用官方的 IsLeapYear 插件(判断是否是闰年):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isLeapYear <span class="keyword">from</span> <span class="string">'dayjs/plugin/isLeapYear'</span></span><br><span class="line">dayjs.extend(isLeapYear)</span><br><span class="line">dayjs(<span class="string">'2000-01-01'</span>).isLeapYear() <span class="comment">// true</span></span><br><span class="line">dayjs(<span class="string">'2018-01-01'</span>).isLeapYear() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>dayjs.extend() 方法，接受两个参数，即插件（函数）和插件的选项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展插件的方法</span></span><br><span class="line"><span class="comment">// plugin：插件函数</span></span><br><span class="line"><span class="comment">// option：插件的选项</span></span><br><span class="line">dayjs.extend = <span class="function">(<span class="params">plugin, option</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 插件函数接受三个参数</span></span><br><span class="line">  <span class="comment">// 1.插件选项 2.Dayjs 类 3.dayjs 函数</span></span><br><span class="line">  <span class="comment">// 插件的方法都是挂载在 Dayjs 类的原型对象上的（Dayjs.prototype）。</span></span><br><span class="line">  plugin(option, Dayjs, dayjs)</span><br><span class="line">  <span class="keyword">return</span> dayjs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IsLeapYear 的源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (o, c) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> proto = c.prototype</span><br><span class="line">  proto.isLeapYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.$y % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.$y % <span class="number">100</span> !== <span class="number">0</span>)) || (<span class="keyword">this</span>.$y % <span class="number">400</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 isLeapYear 函数挂载到 Dayjs 类的原型上，所以每个 Dayjs 实例都可以使用 isLeapYear 方法。</p><hr><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p> 特别感谢 DaisyXL 和 Young 的支持和分析！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="dayjs" scheme="http://xgfe.github.io/tags/dayjs/"/>
    
      <category term="momentjs" scheme="http://xgfe.github.io/tags/momentjs/"/>
    
  </entry>
  
  <entry>
    <title>Category 与Extension 相关知识</title>
    <link href="http://xgfe.github.io/2018/07/04/wanglibin/category%E4%B8%8EExtension%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://xgfe.github.io/2018/07/04/wanglibin/category与Extension相关知识/</id>
    <published>2018-07-04T01:30:48.000Z</published>
    <updated>2019-06-14T07:28:14.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Category 和 Extension 的相关知识以及使用。<br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul><li>Category的背景和概念</li><li>Category的声明及实现</li><li>Category的使用</li><li>Category扩展属性（变量）</li></ul><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><ul><li>Extension的格式</li><li>Extension的实现</li></ul><h2 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><h3 id="一、Category"><a href="#一、Category" class="headerlink" title="一、Category"></a>一、Category</h3><h4 id="1、Category的背景和概念"><a href="#1、Category的背景和概念" class="headerlink" title="1、Category的背景和概念"></a>1、Category的背景和概念</h4><p>在日常开发中，经常需要对已有类进行功能上的扩展，在学习“类别”之前，常用的类扩展方式有以下三种：</p><ul><li>原有类的修改</li><li>继承</li><li>protocol（协议）</li></ul><p>针对以上三种扩展方式，</p><ol><li><p>第一种为最原始的方法；</p></li><li><p>第二种在继承父类的同时，也扩展自己，包括（方法和变量）。但是在面向对象的开发原则中“优先使用组合慎用继承”，因为继承在一定程度上破坏了封装性、子类随父类变动。</p></li><li><p>第三种协议，主要是依靠实现类的具体方法实现，当扩展功能时，需要修改原有类，协议定义过多，实现类过于庞大。</p></li></ol><p>那么，在oc中，当我们想避免上述两种扩展方式的缺点，又想只对现有类进行扩展些方法，并且不用去修改原有类以及使用它的地方的代码，就用到了Category（类别）。</p><p>类别是OC的特有语法，可以通过在类上声明和实现方法来扩展现有类的功能。原则上只能增加方法（包括对象方法和类方法），不能增加成员变量。</p><h4 id="2、Category的声明及实现"><a href="#2、Category的声明及实现" class="headerlink" title="2、Category的声明及实现"></a>2、Category的声明及实现</h4><pre><code>@interface 需扩展的类 （类别的名称）-（void）appendMethod;@end@implementation 需扩展的类 （类别的名称）-（void）appendMethod{}@end</code></pre><h4 id="3、Category的使用"><a href="#3、Category的使用" class="headerlink" title="3、Category的使用"></a>3、Category的使用</h4><p>如果需要扩展一个类，定义好此类的Category ，则可以通过该类的对象直接调用Category中的扩展方法。与此同时，在Category中也可以访问原有类.h中的属性和方法。</p><p>.h文件：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface pson : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;- (void) run;+ (void) jump;@end</code></pre><p>.m文件</p><pre><code>#import &quot;pson.h&quot;@implementation pson-(void) run{    NSLog(@&quot;run&quot;);}+(void) jump{    NSLog(@&quot;jump&quot;);}@end</code></pre><p>为pson类添加eat方法，Category的.m文件如下所示：</p><p>pson+eat.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;@end</code></pre><p>pson+eat.m文件</p><pre><code>#import &quot;pson+eat.h&quot;@implementation pson (eat)-(void) eat{   //调用原有类的公共方法[self run];//调用原有类的非私有属性NSLog(@&quot;%@&quot;,self.name);}+(void) drink{    NSLog(@&quot;drink&quot;);}@end</code></pre><p>在main方法中</p><pre><code>pson *me = [[pson alloc] init];    [me run];    //调用扩展类中的对象方法    [me eat];    //调用扩展类中的类方法    [pson drink]</code></pre><h4 id="4、Category扩展属性（变量）"><a href="#4、Category扩展属性（变量）" class="headerlink" title="4、Category扩展属性（变量）"></a>4、Category扩展属性（变量）</h4><p>由于Category本质上是个指向类型的结构体指针，在结构体中只有方法的列表，没有属性的列表，所以理论上只能增加方法不能增加属性。</p><p>如何通过Category来扩展属性呢？</p><p>无法添加属性的根本原因是：在Category中@property声明属性，系统不会生成_成员变量和setter、getter。</p><p>解决方法：手动添加setter和getter方法，采用的就是：关联引用（objc_setAssociatedObject和objc_getAssociatedObject）</p><p>其中，</p><p>objc_setAssociatedObject，接收4个参数：想关联到数据的对象、获取数据的键值、存储引用的值、关联的策略；</p><p>objc_getAssociatedObject，接收2个参数：关联到数据的对象、键值</p><p>常见的关联策略，如下表所示：</p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>OBJC <em> ASSOCIATION </em> ASSIGN</td><td>指定值将被简单赋值、没有保留和释放</td></tr><tr><td>OBJC <em> ASSOCIATION </em> RETAIN _ NONATOMIC</td><td>指定值通过非线程安全的方式赋值并保留</td></tr><tr><td>OBJC <em> ASSOCIATION </em> COPY _ NONATOMIC</td><td>指定值通过非线程安全的方式复制</td></tr><tr><td>OBJC <em> ASSOCIATION </em> RETAIN</td><td>指定值通过线程安全的方式赋值并保留</td></tr><tr><td>OBJC <em> ASSOCIATION </em> COPY</td><td>指定值通过线程安全的方式复制</td></tr></tbody></table><p>具体实现例子如下所示：</p><p>Category的.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;+(void) drink;@end</code></pre><p>Category的.m文件</p><pre><code>#import &quot;pson+eat.h&quot;#import &quot;objc/runtime.h&quot;static NSString *key = @&quot;personEatKey&quot;;@implementation pson (eat)-(void) eat{    NSLog(@&quot;eat&quot;);}-(void) setFood:(NSString *)food{    objc_setAssociatedObject(self, &amp;key, food,     OBJC_ASSOCIATION_COPY);}-(NSString *) food{    return objc_getAssociatedObject(self, &amp;key);}@end</code></pre><p>main方法中的使用如下：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &quot;pson.h&quot;#import &quot;pson+eat.h&quot;int main(int argc, const char * argv[]) {    @autoreleasepool {        pson *me = [[pson alloc] init];        [me eat];        me.food = @&quot;鸡蛋&quot;;        NSLog(@&quot;%@&quot;,me.food);    }    return 0;}</code></pre><h3 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、Extension</h3><p>Extension 是Category的特例，少了类别的名称，是匿名分类。声明私有方法和属性的机制。具体实现在原有类的.m文件中。</p><h4 id="1、Extension的格式"><a href="#1、Extension的格式" class="headerlink" title="1、Extension的格式"></a>1、Extension的格式</h4><pre><code>@interface XXX ()    //私有属性    //私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）@end</code></pre><h4 id="2、Extension的实现"><a href="#2、Extension的实现" class="headerlink" title="2、Extension的实现"></a>2、Extension的实现</h4><ul><li>通过单独的.h声明，在原有类的.m中导入。</li><li>直接在原有类的.m中使用。</li></ul><h2 id="Category和Extension的区别-1"><a href="#Category和Extension的区别-1" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><ul><li>Category原则上只能增加方法；而Extension方法和变量都可以。</li><li>Extension声明方法没有被实现，编译器报警。Category在运行时添加、Extension是编译阶段。</li><li>Extension没有自己独立的实现部分。</li><li>Extension是私有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Category 和 Extension 的相关知识以及使用。&lt;br&gt;
    
    </summary>
    
      <category term="wanglibin" scheme="http://xgfe.github.io/categories/wanglibin/"/>
    
    
      <category term="OC" scheme="http://xgfe.github.io/tags/OC/"/>
    
      <category term="Category" scheme="http://xgfe.github.io/tags/Category/"/>
    
      <category term="Extension" scheme="http://xgfe.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://xgfe.github.io/2018/06/24/matengfei/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://xgfe.github.io/2018/06/24/matengfei/webpack入门/</id>
    <published>2018-06-24T12:31:49.000Z</published>
    <updated>2019-06-14T07:45:42.234Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。</p><a id="more"></a><h1 id="1、webpack-简介"><a href="#1、webpack-简介" class="headerlink" title="1、webpack 简介"></a>1、webpack 简介</h1><p>前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p><h2 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h2><ul><li>1、支持 CommonJs 和 AMD 模块，意思也就是我们基本可以无痛迁移旧项目。</li><li>2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader 更是有效支持 ES6 。 </li><li>3、可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。 </li><li>4、将样式文件和图片等静态资源也可视为模块进行打包。配合 loader 加载器，可以支持 sass ，less 等 CSS 预处理器。 </li><li>5、内置有 source map ，即使打包在一起依旧方便调试。</li></ul><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><p>Webpack 具有四个核心的概念，想要入门 Webpack 就得先好好了解这四个核心概念。它们分别是Entry（入口）、Output（输出）、loader 和 Plugins（插件）。接下来详细介绍这四个核心概念。</p><h3 id="1-Entry"><a href="#1-Entry" class="headerlink" title="1. Entry"></a>1. Entry</h3><p>Entry 是 Webpack 的入口起点指示，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。可以在配置文件（webpack.config.js）中配置 entry 属性来指定一个或多个入口点，默认为 ./src（ webpack 4开始引入默认值）。<br>具体配置方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: string | <span class="built_in">Array</span>&lt;string&gt;</span><br></pre></td></tr></table></figure><p>前者一个单独的 string 是配置单独的入口文件，配置为后者（一个数组）时，是多文件入口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./vendors.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置表示从 app 和 vendors 属性开始打包构建依赖树，这样做的好处在于分离自己开发的业务逻辑代码和第三方库的源码，因为第三方库安装后，源码基本就不再变化，这样分开打包有利于提升打包速度，减少了打包文件的个数。</p><h3 id="2-Output"><a href="#2-Output" class="headerlink" title="2. Output"></a>2. Output</h3><p>Output 属性告诉 webpack 在哪里输出它所创建的 bundles ，也可指定 bundles 的名称，默认位置为 ./dist。整个应用结构都会被编译到指定的输出文件夹中去，最基本的属性包括 filename（文件名）和 path（输出路径）。</p><p>值得注意的是，即是你配置了多个入口文件，你也只能有一个输出点。</p><p>具体配置方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/dist'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，output.filename 必须是绝对路径，如果是一个相对路径，打包时 webpack 会抛出异常。</p><p>多个入口时，使用下面的语法输出多个 bundle ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Loaders"><a href="#3-Loaders" class="headerlink" title="3. Loaders"></a>3. Loaders</h3><p>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件，比如 png、csv、xml、css、json 等各种类型的文件，使用合适的 loader 可以让 JavaScript 的 import 导入非 JavaScript 模块。JavaScript 只认为 JavaScript 文件是模块，而 webpack 的设计思想即万物皆模块，为了使得 webpack 能够认识其他“模块”，所以需要 loader 这个“编译器”。</p><p>webpack 中配置 loader 有两个目标：</p><p>（1）test 属性：标志有哪些后缀的文件应该被处理，是一个正则表达式。</p><p>（2）use 属性：指定 test 类型的文件应该使用哪个 loader 进行预处理。</p><p>比如 webpack.config.js :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'...'</span>,</span><br><span class="line">    output: <span class="string">'...'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: <span class="string">'css-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该配置文件指示了所有的 css 文件在 import 时都应该经过 css-loader 处理，经过 css-loader 处理后，可以在 JavaScript 模块中直接使用 import 语句导入 css 模块。但是使用 css-loader 的前提是先使用 npm 安装 css-loader。</p><p>此处需要注意的是定义 loaders 规则时，不是定义在对象的 rules 属性上，而是定义在 module 属性的 rules 属性中。</p><p>配置多个 loader ：</p><p>有时候，导入一个模块可能要先使用多个 loader 进行预处理，这时就要对指定类型的文件配置多个 loader 进行预处理，配置多个 loader ，把 use 属性赋值为数组即可，webpack 会按照数组中 loader 的先后顺序，使用对应的 loader 依次对模块文件进行预处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'style-loader'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Plugins"><a href="#4-Plugins" class="headerlink" title="4. Plugins"></a>4. Plugins</h3><p>loader 用于转换非 JavaScript 类型的文件，而插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，功能十分强大。要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</p><p>插件是 webpack 的支柱功能，目前主要是解决 loader 无法实现的其他许多复杂功能，通过 plugins 属性使用插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Mode"><a href="#5-Mode" class="headerlink" title="5. Mode"></a>5. Mode</h3><p>模式（ Mode ）可以通过配置对象的 mode 属性进行配置，主要值为 production 或者 development。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack 会自动对代码进行压缩等优化，省去了配置的麻烦。</p><p>学习完以上基本概念之后，基本也就入门 webpack 了，因为 webpack 的强大就是建立在这些基本概念之上，利用 webpack 多样的 loaders 和 plugins，可以实现强大的打包功能。</p><h1 id="2、js-模块化"><a href="#2、js-模块化" class="headerlink" title="2、js 模块化"></a>2、js 模块化</h1><h2 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h2><p>命名空间是通过为项目或库创建一个全局对象，然后将所有功能添加到该全局变量中。通过减少程序中全局变量的数量，实现单全局变量，从而在具有大量函数、对象和其他变量的情况下不会造成全局污染，同时也避免了命名冲突等问题。</p><p>然而，在不同的文件中给一个命名空间添加属性的时候，首先要保证这个命名空间是已经存在的，同时不对已有的命名空间造成任何破坏。可以通过非破坏性的命名空间函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> KUI = KUI || &#123;&#125;;</span><br><span class="line">KUI.utils = KUI.utils || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">KUI.utils.namespace = <span class="function"><span class="keyword">function</span>(<span class="params">ns</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = ns.split(<span class="string">"."</span>),</span><br><span class="line">        object = KUI,</span><br><span class="line">        i, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parts[<span class="number">0</span>] === <span class="string">"KUI"</span>)&#123;</span><br><span class="line">        parts = parts.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, len = parts.length; i &lt; len; i+=<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!object[parts[i]])&#123;</span><br><span class="line">            object[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        object = object[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KUI.utils.namespace(<span class="string">"KUI.common"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.common.testing"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.modules.function.plugins"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"format"</span>);</span><br></pre></td></tr></table></figure><p>看一下经过上述后 KUI 都有什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"utils"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"common"</span>: &#123;</span><br><span class="line">        <span class="string">"testing"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"modules"</span>: &#123;</span><br><span class="line">        <span class="string">"function"</span>: &#123;</span><br><span class="line">            <span class="string">"plugins"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"format"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间模式的缺点</p><p>1.需要输入更长的字符，并且需要更长的解析时间；<br>2.对单全局变量的依赖性，即任何代码都可以修改该全局实例，其他代码将获得修改后的实例。</p><h2 id="2-2-CommonJs"><a href="#2-2-CommonJs" class="headerlink" title="2.2 CommonJs"></a>2.2 CommonJs</h2><p>CommonJS 是 nodejs 也就是服务器端广泛使用的模块化机制。<br>该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p><p>根据这个规范，每个文件就是一个模块，有自己的作用域，文件中的变量、函数、类等都是对其他文件不可见的。</p><p>如果想在多个文件分享变量，必须定义为 global 对象的属性。</p><h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>在每个模块内部，module 变量代表当前模块。它的 exports 属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取 module.exports 变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>require 方法用于加载模块，后缀名默认为.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'./app.js'</span>);</span><br></pre></td></tr></table></figure><p>模块加载的顺序，按照其在代码中出现的顺序</p><p>根据参数的不同格式，require 命令去不同路径寻找模块文件。</p><ul><li>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。</li><li>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</li><li>如果参数字符串不以“./” 或 “/”开头，则表示加载的是一个默认提供的核心模块（ node 核心模块，或者通过全局安装或局部安装在 node_modules 目录中的模块）</li></ul><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>一般都会有一个主文件（入口文件），在 index.html 中加载这个入口文件，然后在这个入口文件中加载其他文件。</p><p>可以通过在 package.json 中配置 main 字段来指定入口文件。</p><h3 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h3><p>第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><p>由于 CommonJS 是同步加载模块，这对于服务器端不是一个问题，因为所有的模块都放在本地硬盘。等待模块时间就是硬盘读取文件时间很小。但是，对于浏览器而言，它需要从服务器加载模块，涉及到网速，代理等原因，一旦等待时间过长，浏览器处于”假死”状态。</p><h2 id="2-3-AMD"><a href="#2-3-AMD" class="headerlink" title="2.3 AMD"></a>2.3 AMD</h2><p>AMD 是 “Asynchronous Module Definition” 的缩写，即 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。 </p><p>这里异步指的是不堵塞浏览器其他任务（ dom 构建，css 渲染等），而加载内部是同步的（加载完模块后立即执行回调）。</p><blockquote><p>requirejs 即为遵循AMD规范的模块化工具。 </p></blockquote><p>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。</p><p>RequireJS 主要解决两个问题：</p><ul><li>多个 js 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>js 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。</li></ul><h3 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h3><p>RequireJS 定义了一个函数 define，它是全局变量，用来定义模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p></li><li><p>依赖 dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。<br>依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于 3 ，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。</p></li><li><p>工厂方法 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, beta</span>) </span>&#123;</span><br><span class="line">      exports.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> beta.verb();</span><br><span class="line">          <span class="comment">//Or:</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"beta"</span>).verb();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="加载模块-1"><a href="#加载模块-1" class="headerlink" title="加载模块"></a>加载模块</h3><p>AMD 也采用 require 命令加载模块，但是不同于 CommonJS ，它要求两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数是一个数组，里面的成员是要加载的模块，第二个参数是加载完成后的回调函数。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>require 方法本身也是一个对象，它带有一个 config 方法，用来配置 require.js 运行参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: <span class="string">"vendor/backbone"</span>,</span><br><span class="line">        <span class="string">"underscore"</span>: <span class="string">"vendor/underscore"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: &#123;</span><br><span class="line">            deps: [ <span class="string">"underscore"</span> ],</span><br><span class="line">            exports: <span class="string">"Backbone"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"underscore"</span>: &#123;</span><br><span class="line">            exports: <span class="string">"_"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>paths：paths 参数指定各个模块的位置。这个位置可以是同一个服务器上的相对位置，也可以是外部网址。可以为每个模块定义多个位置，如果第一个位置加载失败，则加载第二个位置。上面就是指定了 jquery 的位置，那么就可以直接在文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require（[&apos;jquery&apos;],function($)&#123;&#125;）</span><br></pre></td></tr></table></figure><p>shim：有些库不是 AMD 兼容的，这时就需要指定 shim 属性的值。shim 可以理解成“垫片”，用来帮助require.js 加载非 AMD 规范的库。</p><h2 id="2-4-CMD"><a href="#2-4-CMD" class="headerlink" title="2.4 CMD"></a>2.4 CMD</h2><p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个requireJS，CMD 有个浏览器的实现 SeaJS ，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块代码</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require 是可以把其他模块导入进来的一个参数; 而 exports 是可以把模块内的一些属性和方法导出的; module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p><ul><li>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块;</li><li>CMD 是按需加载依赖就近,只有在用到某个模块的时候再去 require ;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-5-ES6-Module"><a href="#2-5-ES6-Module" class="headerlink" title="2.5 ES6 Module"></a>2.5 ES6 Module</h2><p>ES6 正式提出了内置的模块化语法，我们在浏览器端无需额外引入 requirejs 来进行模块化。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过 import 命令输入。</p><p>ES6 中的模块有以下特点：</p><ul><li>模块自动运行在严格模式下</li><li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在</li><li>模块顶级作用域的 this 值为 undefined</li><li>对于需要让模块外部代码访问的内容，模块必须导出它们</li></ul><h3 id="定义模块-2"><a href="#定义模块-2" class="headerlink" title="定义模块"></a>定义模块</h3><p>使用 export 关键字将任意变量、函数或者类公开给其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"cz"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象，即导出引用</span></span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;</span><br></pre></td></tr></table></figure><h3 id="重命名模块"><a href="#重命名模块" class="headerlink" title="重命名模块"></a>重命名模块</h3><p>重命名想导出的变量、函数或类的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br></pre></td></tr></table></figure><p>这里将本地的 sum 函数重命名为 add 导出，因此在使用此模块的时候必须使用 add 这个名称。</p><h3 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h3><p>模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中只能设置一个默认导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用 export 导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。</p><p>也可以使用重命名语法来导出默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="加载模块-2"><a href="#加载模块-2" class="headerlink" title="加载模块"></a>加载模块</h3><p>在模块中使用 import 关键字来导入其他模块。<br>import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1,identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure><ul><li>大括号中指定了从给定模块导入的标识符</li><li>from 指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。</li></ul><p>当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入单个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入多个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum,multiply&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全导入一个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line">example.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">example.multiply(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入默认值</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>然而要记住，无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。</p><p>在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; multiply &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export 与 import。</p><h1 id="3、webpack-使用"><a href="#3、webpack-使用" class="headerlink" title="3、webpack 使用"></a>3、webpack 使用</h1><h2 id="3-1-打包-js"><a href="#3-1-打包-js" class="headerlink" title="3.1 打包 js"></a>3.1 打包 js</h2><p>webpack 对各种模块化的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// es module</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./sum'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="keyword">var</span> minus = <span class="built_in">require</span>(<span class="string">'./minux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//amd</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'muti'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(muti(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(minus(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minus.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// muti.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="压缩-JS-代码："><a href="#压缩-JS-代码：" class="headerlink" title="压缩 JS 代码："></a>压缩 JS 代码：</h3><p>现在你写的 JS 代码，在上线之前，都是需要进行压缩的，在没有 webpack 和 gulp 这些工具前，你可能需要找一个压缩软件或者在线进行压缩，在 Webpack 中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个 uglifyjs-webpack-plugin ( JS 压缩插件，简称 uglify )。</p><p>注意：虽然 uglifyjs 是插件，但是 webpack 版本里默认已经集成，不需要再次安装。</p><p>引入：</p><p>我们需要在 webpack.config.js 中引入 uglifyjs-webpack-glugin 插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>引入后在 plugins 配置里new一个 uglify 对象就可以了，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        <span class="keyword">new</span> uglify()</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>这时候在终端中使用 webpack 进行打包，你会发现 JS 代码已经被压缩了。</p><h2 id="3-2-编译-ES6"><a href="#3-2-编译-ES6" class="headerlink" title="3.2 编译 ES6"></a>3.2 编译 ES6</h2><p>在前端开发中都开始使用 ES6 的语法了，虽然说 webpack3 增加了一些 ES6 的转换支持，但是实际效果不是很好。所以我在开发中还是喜欢添加 Babel-loader 的，我也查看了一些别人的 webpack 配置也都增加了 babel-loader，所以这节课我们学习一下如何增加 Babel 支持。</p><p>Babel 是什么？<br>Babel 其实是一个编译 JavaScript 的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：</p><ul><li>使用下一代的 javaScript 代码( ES6, ES7….)，即使这些标准目前并未被当前的浏览器完全支持。</li><li>使用基于 JavaScript 进行了扩展的语言，比如 React 的 JSX 。</li></ul><h3 id="Babel-的安装与配置"><a href="#Babel-的安装与配置" class="headerlink" title="Babel 的安装与配置"></a>Babel 的安装与配置</h3><p>Babel 其实是几个模块化的包，其核心功能位于称为 babel-core 的 npm 包中，webpack 可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析 ES6 的 babel-preset-es2015 包和解析 JSX 的 babel-preset-react 包）。</p><p>安装依赖包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><p>在 webpack 中配置 Babel 的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                <span class="string">"es2015"</span>,<span class="string">"react"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babelrc配置"><a href="#babelrc配置" class="headerlink" title=".babelrc配置"></a>.babelrc配置</h3><p>虽然 Babel 可以直接在 webpack.config.js 中进行配置，但是考虑到 babel 具有非常多的配置选项，如果卸载 webapck.config.js 中会非常的雍长不可阅读，所以我们经常把配置卸载 .babelrc 文件里。</p><p>在项目根目录新建 .babelrc 文件，并把配置写到文件里。</p><p>. babelrc</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.webpack.config.js 里的 loader 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ENV："><a href="#ENV：" class="headerlink" title="ENV："></a>ENV：</h3><p>babel-preset-env 代替 babel-preset-ES2015 , babel 官方推出了 babel-preset-env ，并建议在使用的时候选择 env 代替之前的 ES20** 。env 为我们提供了更智能的编译选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure><p>然后修改 .babelrc 里的配置文件。其实只要把之前的 es2015 换成 env 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-打包公共代码"><a href="#3-3-打包公共代码" class="headerlink" title="3.3 打包公共代码"></a>3.3 打包公共代码</h2><p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件 (又称作 chunk ) 的功能，这个文件包括多个入口 chunk 的公共模块。</p><p>通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p><h3 id="公共chunk-用于-入口chunk-entry-chunk"><a href="#公共chunk-用于-入口chunk-entry-chunk" class="headerlink" title="公共chunk 用于 入口chunk (entry chunk)"></a>公共chunk 用于 入口chunk (entry chunk)</h3><p>生成一个额外的 chunk 包含入口 chunk 的公共模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"commons"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk(commnons chunk) 的名称)</span></span><br><span class="line"></span><br><span class="line">  filename: <span class="string">"commons.js"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk 的文件名)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (模块必须被3个 入口 chunk 共享)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// chunks: ["pageA", "pageB"],</span></span><br><span class="line">  <span class="comment">// (只使用这些 入口chunk)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你必须在 入口 chunk 之前加载生成的这个公共 chunk:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"commons.js"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"entry.bundle.js"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="明确第三方库-chunk"><a href="#明确第三方库-chunk" class="headerlink" title="明确第三方库 chunk"></a>明确第三方库 chunk</h3><p>将你的代码拆分成公共代码和应用代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [<span class="string">"jquery"</span>, <span class="string">"other-lib"</span>],</span><br><span class="line">  app: <span class="string">"./entry"</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">"vendor"</span>,</span><br><span class="line">    <span class="comment">// filename: "vendor.js"</span></span><br><span class="line">    <span class="comment">// (给 chunk 一个不同的名字)</span></span><br><span class="line"></span><br><span class="line">    minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// (随着 entry chunk 越来越多，</span></span><br><span class="line">    <span class="comment">// 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="将公共模块打包进父-chunk"><a href="#将公共模块打包进父-chunk" class="headerlink" title="将公共模块打包进父 chunk"></a>将公共模块打包进父 chunk</h3><p>使用代码拆分功能，一个 chunk 的多个子 chunk 会有公共的依赖。为了防止重复，可以将这些公共模块移入父 chunk。这会减少总体的大小，但会对首次加载时间产生不良影响。如果预期到用户需要下载许多兄弟 chunks（例如，入口 trunk 的子 chunk），那这对改善加载时间将非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  <span class="comment">// names: ["app", "subPageA"]</span></span><br><span class="line">  <span class="comment">// (选择 chunks，或者忽略该项设置以选择全部 chunks)</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="额外的异步公共-chunk"><a href="#额外的异步公共-chunk" class="headerlink" title="额外的异步公共 chunk"></a>额外的异步公共 chunk</h3><p>与上面的类似，但是并非将公共模块移动到父 chunk（增加初始加载时间），而是使用新的异步加载的额外公共 chunk 。当下载额外的 chunk 时，它将自动并行下载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"app"</span>,</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  names: [<span class="string">"app"</span>, <span class="string">"subPageA"</span>]</span><br><span class="line">  <span class="comment">// the name or list of names must match the name or names</span></span><br><span class="line">  <span class="comment">// of the entry points that create the async chunks</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (创建一个异步 公共chunk)</span></span><br><span class="line"></span><br><span class="line">  minChunks: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-4-代码分割和懒加载"><a href="#3-4-代码分割和懒加载" class="headerlink" title="3.4 代码分割和懒加载"></a>3.4 代码分割和懒加载</h2><p>webpack 可以帮助我们将代码分成不同的逻辑块，在需要的时候加载这些代码。</p><h3 id="使用-require-ensure-来拆分代码"><a href="#使用-require-ensure-来拆分代码" class="headerlink" title="使用 require.ensure() 来拆分代码"></a>使用 require.ensure() 来拆分代码</h3><p>require.ensure() 是一种使用 CommonJS 的形式来异步加载模块的策略。在代码中通过 require.ensure([<fileurl>]) 引用模块，其使用方法如下：</fileurl></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>);</span></span><br></pre></td></tr></table></figure><p>第一个参数指定依赖的模块，第二个参数是一个函数，在这个函数里面你可以使用 require 来加载其他的模块，webpack 会收集 ensure 中的依赖，将其打包在一个单独的文件中，在后续用到的时候使用 jsonp 异步地加载进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行代码分割</span></span><br><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'lodash'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);<span class="comment">//上边的require.ensure只会引入进来，但是并不会执行，再次require才会执行。</span></span><br><span class="line">&#125;,<span class="string">'vendor'</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>,<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">        <span class="keyword">var</span> subPageB=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,common)</span><br><span class="line">    <span class="comment">//common表示这个模块的名字</span></span><br></pre></td></tr></table></figure><p>但是仅仅这样配置并不能把公共 js 抽离出来，在多页面应用中可以通过 new webpack.optimize.CommonsChunkPlugin 这个 plugin 来实现，但是对于单页面来说，就需要借助 require.include 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(<span class="string">'./moduleA'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会把公共模块 moduleA 给抽离出来。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 与 require.ensure 最大的区别就是，他在引入的时候会直接执行，而不需要在此 require 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是这样打包出来的是没有 chunkname 的，怎么添加 chunkname 呢？需要 webpack3+ 的魔法注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/*webpackChunkName:'subPageA'*/</span><span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-5-处理css"><a href="#3-5-处理css" class="headerlink" title="3.5 处理css"></a>3.5 处理css</h2><h3 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h3><p>首先，在 src 目录下建立 css 文件夹，和 index.css 文件，并编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: burlywood;</span><br><span class="line">    color:white;</span><br><span class="line">    font-size:<span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立好后，需要引入到入口文件中，才可以打包。在 entery.js 的首行加入代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">'./css/index.css'</span>;</span><br></pre></td></tr></table></figure><p>CSS 和引入做好后，我们就需要使用 loader 来解析 CSS 文件了，这里我们需要两个解析用的 loader，分别是 style-loader 和 css-loader。</p><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>它是用来处理 css 文件中的 url() 等。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure><h3 id="CSS-loader"><a href="#CSS-loader" class="headerlink" title="CSS-loader"></a>CSS-loader</h3><p>它是用来将 css 插入到页面的 style 标签。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><h3 id="loaders配置："><a href="#loaders配置：" class="headerlink" title="loaders配置："></a>loaders配置：</h3><p>修改 webpack.config.js 中 module 属性中的配置代码如下：</p><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h3><p>目前，打包后的文件中，css 是打包在 js 代码里面的，这样不便于以后的维护，所以需要把 CSS 从 js 中分离出来，我们需要使用插件 Extract Text Plugin。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>在 Plugins中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>);</span><br><span class="line"><span class="comment">//css/index.css是分离后的路径位置</span></span><br></pre></td></tr></table></figure><p>修改 Loader 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:<span class="string">"css-loader"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Less"><a href="#配置Less" class="headerlink" title="配置Less"></a>配置Less</h3><p>Less 作为目前很火的 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin 、函数等特性，使 CSS 更易维护和扩展；</p><p>安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less less-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"less-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置sass"><a href="#配置sass" class="headerlink" title="配置sass"></a>配置sass</h3><p>Sass 的打包和分离和 less 的类似，首先下载安装 Sass 所支持的服务与 loader。<br>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev node-sass sass-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"sass-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostCSS-in-webpack"><a href="#PostCSS-in-webpack" class="headerlink" title="PostCSS-in-webpack"></a>PostCSS-in-webpack</h3><p>CSS3 是目前作为一个前端必须要掌握的技能，但是由于现在好多浏览器还是不兼容 CSS3，所以前端需要多写很丑很难看的前缀代码；以前都是边查 Can I Use ，边添加，这样很麻烦，现在配置一个插件 postcss就可以搞定；</p><p>PostCSS 是一个 CSS 的处理平台，它可以帮助你的 CSS 实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下 PostCSS 。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure><p>在根目录下，建立一个 postcss.config.js 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是对 postCSS 一个简单的配置，引入了 autoprefixer 插件。让 postCSS 拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</p><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, </span><br><span class="line">                options: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-Tree-shaking"><a href="#3-6-Tree-shaking" class="headerlink" title="3.6 Tree-shaking"></a>3.6 Tree-shaking</h2><p>Tree-shaking 字面意思就是摇晃树， 其实就是去除那些引用的但却没有使用的代码。<br>Tree-shaking 概念最早由 Rollup.js 提出，后来在 webpack2 中被引入进来，但是这个这一特性能够被支持得益于 ES6 modules 的静态特性。ES6的模块声明相比于传统 CommonJS 的同步 require 有着本质区别。这种 modules 设计保证了依赖关系是提前确定的，使得静态分析成为了可能，与运行时无关。<br>并且 webpack 中并没有直接对 tree-shaking 的配置，需要借助 uglifyjs-webpack-plugin。</p><p>webpack 中 tree-shaking主要分为两个方面:</p><ul><li>JS tree shaking： JS 文件中定义的多个方法或者变量没有全部使用。</li><li>CSS tree shaking： 样式通过 css 选择器没有匹配到相应的 DOM 节点。</li></ul><h3 id="JS-Tree-shaking"><a href="#JS-Tree-shaking" class="headerlink" title="JS Tree-shaking"></a>JS Tree-shaking</h3><p>将文件标记为无副作用( side-effect-free )<br>在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。</p><p>这种方式是通过 package.json 的 “sideEffects” 属性来实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。</p><blockquote><p>「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export 。举例说明，例如 polyfill ，它影响全局作用域，并且通常不提供 export 。</p></blockquote><p>如果你的代码确实有一些副作用，那么可以改为提供一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩输出<br>通过如上方式，我们已经可以通过 import 和 export 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。</p><blockquote><p>注意，–optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。<br>从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。</p></blockquote><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">"production"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了学会使用 tree shaking，你必须……</p><ul><li>使用 ES2015 模块语法（即 import 和 export）。</li><li>在项目 package.json 文件中，添加一个 “sideEffects” 入口。</li><li>引入一个能够删除未引用代码( dead code )的压缩工具( minifier )（例如 UglifyJSPlugin ）。</li></ul><h3 id="CSS-Tree-shaking"><a href="#CSS-Tree-shaking" class="headerlink" title="CSS Tree-shaking"></a>CSS Tree-shaking</h3><p>像 Bootstrap 这样的框架往往会带有很多 CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS 也会越来越多，有时候需求更改，带来了 DOM 结构的更改，这时候我们可能无暇关注 CSS 样式，造成很多 CSS 的冗余。</p><p>PurifyCSS<br>使用 PurifyCSS 可以大大减少 CSS 冗余，比如我们经常使用的 BootStrap (140KB)就可以减少到只有 35KB 大小。这在实际开发当中是非常有用的。</p><p>安装 PurifyCSS-webpack<br>从名字你就可以看出这是一个插件，而不是 loader。所以这个需要安装还需要引入。 PurifyCSS-webpack 要以来于 purify-css 这个包，所以这两个都需要安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i –save-dev purifycss-webpack purify-css</span><br></pre></td></tr></table></figure><p>引入 glob<br>因为我们需要同步检查html模板，所以我们需要引入 node 的 glob 对象使用。在 webpack.config.js 文件头部引入 glob。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br></pre></td></tr></table></figure><p>引入 purifycss-webpack<br>同样在 webpack.config.js 文件头部引入 purifycss-webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCSSPlugin = <span class="built_in">require</span>(<span class="string">"purifycss-webpack"</span>);</span><br></pre></td></tr></table></figure><p>配置 plugins<br>引入完成后我们需要在 webpack.config.js 里配置 plugins 。代码如下，重点看标黄部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="comment">//new uglify() </span></span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash:<span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">'./src/index.html'</span></span><br><span class="line">        </span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">"css/index.css"</span>),</span><br><span class="line">    <span class="keyword">new</span> PurifyCSSPlugin(&#123;</span><br><span class="line">        <span class="comment">// Give paths to parse for rules. These should be absolute!</span></span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里配置了一个 paths ，主要是需找 html 模板，purifycss 根据这个配置会遍历你的文件，查找哪些css 被使用了。</p><p>配置好上边的代码，我们可以故意在 css 文件里写一些用不到的属性，然后用 webpack 打包，你会发现没用的 CSS 已经自动给你删除掉了。在工作中记得一定要配置这个 plugins ，因为这决定你代码的质量，非常有用。</p><h2 id="3-7-文件处理"><a href="#3-7-文件处理" class="headerlink" title="3.7 文件处理"></a>3.7 文件处理</h2><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>在 index.html 文件中增加一个放置 div 的标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"tupian"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>编写 css 文件，把图片作为背景显示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tupian&#123;</span><br><span class="line">   background-image: url(../images/manhua.png);</span><br><span class="line">   width:<span class="number">466</span>px;</span><br><span class="line">   height:<span class="number">453</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 file-loader 和 url-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><p>file-loader ：解决引用路径的问题，拿 background 样式用 url 引入背景图来说，我们都知道， webpack 最终会将各个模块打包成一个文件，因此我们样式中的 url 路径是相对入口 html 页面的，而不是相对于原始 css 文件所在的路径的。这就会导致图片引入失败。这个问题是用 file-loader 解决的，file-loader 可以解析项目中的 url 引入（不仅限于 css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。<br>url-loader：如果图片较多，会发很多 http 请求，会降低页面性能。这个问题可以通过 url-loader 解决。url-loader 会将引入的图片编码，生成 dataURl 。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl ，大于 limit 的还会使用 file-loader 进行 copy。</p><p>配置 url-loader<br>我们安装好后，就可以使用这个 loader 了，记得在 loader 使用时不需要用 require 引入，在plugins 才需要使用 require 引入。</p><p>webpack.config.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块：例如解读 CSS,图片如何转换，压缩</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:<span class="number">500000</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>test： /.(png|jpg|gif)/ 是匹配图片文件后缀名称。</li><li>use：是指定使用的 loader 和 loader 的配置参数。</li><li>limit：是把小于 500000B 的文件打成 Base64 的格式，写入JS 。</li><li>写好后就可以使用 webpack 进行打包了，这回你会发现打包很顺利的完成了。具体的 Base64 的格式，你可以查看视频中的样子。</li></ul><h4 id="为什么只使用了url-loader"><a href="#为什么只使用了url-loader" class="headerlink" title="为什么只使用了url-loader"></a>为什么只使用了url-loader</h4><p>有的小伙伴会发现我们并没有在 webpack.config.js 中使用 file-loader ，但是依然打包成功了。我们需要了解 file-loader 和 url-loader 的关系。url-loader 和 file-loader 是什么关系呢？简答地说，url-loader 封装了 file-loader 。 url-loader 不依赖于 file-loader ，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader ，因为 url-loader内置了 file-loader 。通过上面的介绍，我们可以看到，url-loader 工作分两种情况：</p><ul><li><p>1.文件大小小于 limit 参数， url-loader 将会把文件转为 DataURL（ Base64格式 ）；</p></li><li><p>2.文件大小大于 limit ， url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。</p></li></ul><p>也就是说，其实我们只安装一个 url-loader 就可以了。但是为了以后的操作方便，我们这里就顺便安装上 file-loader。</p><h4 id="如何把图片放到指定的文件夹下"><a href="#如何把图片放到指定的文件夹下" class="headerlink" title="如何把图片放到指定的文件夹下"></a>如何把图片放到指定的文件夹下</h4><p>前边两节课程，打包后的图片并没有放到images文件夹下，要放到 images 文件夹下，其实只需要配置我们的 url-loader 选项就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">     rules: [</span><br><span class="line">         &#123;</span><br><span class="line">           test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">           use: extractTextPlugin.extract(&#123;</span><br><span class="line">             fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">             use: <span class="string">"css-loader"</span></span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,&#123;</span><br><span class="line">            test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit:<span class="number">5000</span>,</span><br><span class="line">                    outputPath:<span class="string">'images/'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="CSS-分离时图片路径处理"><a href="#CSS-分离时图片路径处理" class="headerlink" title="CSS 分离时图片路径处理"></a>CSS 分离时图片路径处理</h3><p>在处理 css 时我们已经学会如何使用 extract-text-webpack-plugin 插件提取 css，利用 extract-text-webpack-plugin 插件很轻松的就把 CSS 文件分离了出来，但是 CSS 路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用 publicPath 解决，我也一直在用。</p><p>publicPath：是在 webpack.config.js 文件的 output 选项中，主要作用就是处理静态文件路径的。</p><p>在处理前，我们在 webpack.config.js 上方声明一个对象，叫 website。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> website =&#123;</span><br><span class="line">    publicPath:<span class="string">"http://192.168.1.108:1717/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 IP 和端口，是你本机的 ip 或者是你 devServer 配置的 IP 和端口。<br>然后在 output 选项中引用这个对象的 publicPath 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出口文件的配置项</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">//输出的路径，用了Node语法</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        <span class="comment">//输出的文件名称</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>配置完成后，你再使用 webpack 命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><h4 id="将字体图标和-css-打包到同一个文件中"><a href="#将字体图标和-css-打包到同一个文件中" class="headerlink" title="将字体图标和 css 打包到同一个文件中"></a>将字体图标和 css 打包到同一个文件中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test:<span class="regexp">/\.(png|woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:&#123;</span><br><span class="line">        loader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: <span class="number">100000</span>,  <span class="comment">//这里要足够大这样所有的字体图标都会打包到css中</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中的 limit 一定要保证大于最大字体文件的大小，因为这个参数是告诉 url-loader，如果文件小于这个参数，那么就以 Data Url 的方式直接构建到文件中。使用这种方式最方便，不用打包后路径的问题，但是缺点就是构建出来的文件特别大，如果线上不要使用这种方式打包。 </p><h4 id="将字体图标独放打包到一个文件夹中"><a href="#将字体图标独放打包到一个文件夹中" class="headerlink" title="将字体图标独放打包到一个文件夹中"></a>将字体图标独放打包到一个文件夹中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.(woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:[</span><br><span class="line">        &#123;</span><br><span class="line">        loader:<span class="string">'file-loader'</span>,</span><br><span class="line">        options:&#123;<span class="attr">name</span>:<span class="string">'fonts/[name].[hash:8].[ext]'</span>&#125;&#125;</span><br><span class="line">        <span class="comment">//项目设置打包到dist下的fonts文件夹下</span></span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>打包中会遇到的问题就是路径不对，可以通过配置 publicPath 解决。</p><h3 id="Json-配置文件使用"><a href="#Json-配置文件使用" class="headerlink" title="Json 配置文件使用"></a>Json 配置文件使用</h3><p>在实际工作中，我们的项目都会配置一个 Json 的文件或者说 API 文件，作为项目的配置文件。有时候你也会从后台读取到一个 json 的文件，这节课就学习如何在 webpack 环境中使用 Json。如果你会 webpack1 或者 webpack2 版本中，你是需要加载一个 json-loader 的 loader 进来的，但是在webpack3.x 版本中，你不再需要另外引入了。</p><p>读出 Json 内容<br>第一步：现在我们的 index.html 模板中加入一个层，并给层一个 Id，为了是在 javascript 代码中可以方便引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"json"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>第二步：到 src 文件夹下，找到入口文件，我这里是 entry.js 文件。修改里边的代码，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json =<span class="built_in">require</span>(<span class="string">'../config.json'</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"json"</span>).innerHTML= json.name;</span><br></pre></td></tr></table></figure><p>这两行代码非常简单，第一行是引入我们的 json 文件，第二行驶写入到到 DOM 中。</p><h2 id="3-8-html-in-webpack"><a href="#3-8-html-in-webpack" class="headerlink" title="3.8 html in webpack"></a>3.8 html in webpack</h2><h3 id="生成html"><a href="#生成html" class="headerlink" title="生成html"></a>生成html</h3><p>html-webpack-plugin 可以根据你设置的模板，在每次运行后生成对应的模板文件，同时所依赖的 CSS/JS 也都会被引入，如果 CSS/JS 中含有 hash 值，则 html-webpack-plugin 生成的模板文件也会引入正确版本的 CSS/JS 文件。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>引入</p><p>在webpack.config.js中引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./app/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: <span class="string">"This is the result"</span>,</span><br><span class="line">            filename: <span class="string">"./index.html"</span>,</span><br><span class="line">            template: <span class="string">"./app/index.html"</span>,</span><br><span class="line">            inject: <span class="string">"body"</span>,</span><br><span class="line">            favicon: <span class="string">""</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                caseSensitive: <span class="literal">false</span>,</span><br><span class="line">                collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            cache: <span class="literal">true</span>,</span><br><span class="line">            chunks: <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后看一下这些参数的意义：</p><ul><li>title: 生成的HTML模板的 title，如果模板中有设置 title 的名字，则会忽略这里的设置</li><li>filename: 生成的模板文件的名字</li><li>template: 模板来源文件</li><li>inject: 引入模块的注入位置；取值有 true/false/body/head</li><li>favicon: 指定页面图标；</li><li>minify: 是 html-webpack-plugin 中集成的 html-minifier ，生成模板文件压缩配置</li><li>caseSensitive: false, //是否大小写敏感</li><li>collapseBooleanAttributes: true, //是否简写 boolean 格式的属性如：disabled=”disabled” 简写为 disabled </li><li>collapseWhitespace: true //是否去除空格</li><li>hash: 是否生成hash添加在引入文件地址的末尾，类似于我们常用的时间戳</li><li>cache: 是否需要缓存，如果填写 true，则文件只有在改变时才会重新生成</li><li>chunks: 引入的模块，这里指定的是 entry 中设置多个 js 时，在这里指定引入的 js，如果不设置则默认全部引入</li></ul><h3 id="html中引入图片"><a href="#html中引入图片" class="headerlink" title="html中引入图片"></a>html中引入图片</h3><p>html-withimg-loader<br>html-withimg-loader 就是我们今天的重点了，这个插件并不是很火，也是我个人喜欢的一个小loader 。解决的问题就是在hmtl文件中引入 <img> 标签的问题。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><p>配置 loader<br>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在终端中可以进行打包了。你会发现 images 被很好的打包了。并且路径也完全正确。</p><h1 id="webpack-环境配置"><a href="#webpack-环境配置" class="headerlink" title="webpack 环境配置"></a>webpack 环境配置</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>在使用 webpack-cli 进行打包时，通过命令 webpack –watch 即可开启 watch 模式，进入 watch 模式之后，一旦依赖树中的某一个模块发生了变化，webpack 就会重新进行编译。</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>在 webpack 中打包生成的文件会覆盖之前的文件，不过生成文件的时候文件名加了 hash 之后会每次都生成不一样的文件，这就会很麻烦，不但会生成很多冗余的文件，还很难搞清楚到底是哪个文件，这就需要引入该插件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="comment">//引入clean-webpack-plugin</span></span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//plugin 插入你想删除的路径，注意在生成出来文件之前，他会删除 public 的文件夹，而不是根据生成的文件来删除对应的文件。</span></span><br><span class="line"><span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'public'</span>]);</span><br></pre></td></tr></table></figure><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack dev server"></a>webpack dev server</h3><p>webpack-dev-server 简介：</p><ul><li>是一个小型 node.js express 服务器</li><li>新建一个开发服务器，可以 serve 我们 pack 以后的代码，并且当代码更新的时候自动刷新浏览器</li><li>启动 webpack-dev-server 后，你在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。<br>两种自动刷新方式：</li><li>iframe mode<br>在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload<br>命令行：webpack-dev-server，无需 –inline<br>浏览器访问：<a href="http://localhost:8080/webpack-dev-server/index.html" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/index.html</a></li><li>inline mode<br>命令行：webpack-dev-server –inline<br>浏览器访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul><p>安装 webpack-dev-server</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var webpack=require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">……</span><br><span class="line">devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    inline: true,//注意：不写hot: true，否则浏览器无法自动更新；也不要写  colors:true，progress:true等，webpack2.x已不支持这些</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">    ……</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ]</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 package.json 里配置运行的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: </span><br><span class="line">&#123; </span><br><span class="line">　　<span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="代理远程接口"><a href="#代理远程接口" class="headerlink" title="代理远程接口"></a>代理远程接口</h2><p>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。<br>webpack-dev-server 使用了非常强大的 http-proxy-middleware 包。</p><p>配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/apis'</span>: &#123;</span><br><span class="line">        target: <span class="string">''</span>, <span class="comment">//要代理到的地址</span></span><br><span class="line">        secure: <span class="literal">false</span>, <span class="comment">//若地址为https，需要设置为false</span></span><br><span class="line">        onProxyReq: <span class="function"><span class="keyword">function</span>(<span class="params">proxyReq, req, res</span>) </span>&#123; <span class="comment">//提前设置一些代理的头部，如token信息等</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//...其他配置请自行查阅文档http-proxy-middleware文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h2><p>DevServer 还支持一 种叫做模块热替换( Hot Module Replacement )的技术可在不刷新整个网页的情况下 做到超 灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输 出 的模块替换掉浏览器中对应的老模块 。</p><p>模块热替换技术的优势如下：</p><ul><li>实时预览反应更快，等待时间更短。</li><li>不刷新浏览器时能保留当前网页的运行状态，例如在使用 Redux 管理数据的应用中搭配模块热替换能做到在代码更新时 Redux 中的数据保持不变。</li></ul><p>总的来说，模块热替换技术在很大程度上提升了开发效率和体验 。</p><p>DevServer 默认不会开启模块热替换模式，要开启该模式，则只 需在启动时带上参数 –hot ，完整的命令是 webpack-dev-server –hot。</p><p>除了通过在启动时带上 –hot 参数，还可以通过接入 Plugin 实现，相关代码如下 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">canst HotModuleReplacementPlugin = <span class="built_in">require</span> (’ webpack/lib/HotModuleReplacementPlugin ’);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">entry:&#123;</span><br><span class="line"><span class="comment">//为每个入口都注入代理客户端</span></span><br><span class="line">main: [’ webpack-dev-server/client?http:<span class="comment">//localhost:8080 /’, ’webpack/hot/dev-server ’,’. / src/main.j s ’],</span></span><br><span class="line">&#125;,</span><br><span class="line"> plugIns : [</span><br><span class="line"><span class="comment">//该插件的作用就是实现模块热替换，实际上若启动时带上 、 --hot 、参数，就会注入该插件，生 成 .hot-update.json 文件。</span></span><br><span class="line"><span class="keyword">new</span> HotModuleReplacementPlugin() ,</span><br><span class="line">],</span><br><span class="line">devServer : &#123;</span><br><span class="line"><span class="comment">//告诉 DevServer 要开启 模块热替换模式 </span></span><br><span class="line">hot: <span class="literal">true</span> ,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>借助于 style-loader 的帮助，CSS 的模块热替换实际上是相当简单的。当更新 CSS 依赖模块时，此 loader 在后台使用 module.hot.accept 来修补(patch) <code>&lt;style&gt;</code>标签。</p><p>但当修改 js 文件时，我们会发现模块热替换没有生效，而是整个页面被刷新了，为了让使用者在使用模块热替换功能时能灵活地控制老模块被替换时的逻辑，webpack 允许在源码中定义一些代码去做相应的处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当开启了模块热替换时 module.hot 才存在 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept([<span class="string">'.IAppComponent'</span>],()=&gt;&#123;</span><br><span class="line"><span class="comment">//在新的 AppComponent 加载成功后重新执行组建渲染逻辑 render(&lt;AppComponentl&gt;, window.document.getElementByid ('app'));</span></span><br><span class="line">&#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 module.hot 是当开启模块热替换后注入全局的 API，用于控制模块热替换的逻辑 。<br>当子模块发生更新时，更新事件会一层层地向上传递，也就是从 AppComponent.js 文件传递到 main.js 文件，直到有某层的文件接收了当前变化的模块，即 main.js 文 件中定义的 module.hot.accept([‘.IAppComponent’], callback)，这时就会调用 callback 函数去执行自定义逻辑。 如果事件一直往上抛，到最外层都没有文件接收它，则会直接刷新网页。</p><h2 id="开启调试-SourceMap"><a href="#开启调试-SourceMap" class="headerlink" title="开启调试 SourceMap"></a>开启调试 SourceMap</h2><p>作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是 webpack 已经为我们充分考虑好了这点，它支持生产 Source Maps 来方便我们的调试。<br>在使用 webpack 时只要通过简单的 devtool 配置，webapck 就会自动给我们生产 source maps 文件，map 文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。</p><p>在配置 devtool 时，webpack 给我们提供了四种选项：</p><ul><li>source-map: 在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的 source map ，但是它会减慢打包速度；</li><li>cheap-module-source-map: 在一个单独的文件中产生一个不带列映射的map ，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li><li>eval-source-map: 使用 eval 打包源文件模块，在同一个文件中生产干净的完整版的 sourcemap ，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li><li>cheap-module-eval-source-map: 这是在打包文件时最快的生产 source map 的方法，生产的 Source map 会和打包后的 JavaScript 文件同行显示，没有影射列，和 eval-source-map 选项具有相似的缺点。<br>四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。</li></ul><p>个人意见是，如果大型项目可以使用 source-map，如果是中小型项目使用 eval-source-map 就完全可以应对，需要强调说明的是，source map 只适用于开发阶段，上线前记得修改这些调试设置。</p><p>简单的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  entry:  __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">"/public"</span>,</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置-ESLint-检查代码格式"><a href="#设置-ESLint-检查代码格式" class="headerlink" title="设置 ESLint 检查代码格式"></a>设置 ESLint 检查代码格式</h2><p>首先，要使 webpack 支持 eslint，就要要安装 eslint-loader ，命令如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">    enforce: <span class="string">"pre"</span>,</span><br><span class="line">    include: [path.resolve(__dirname, <span class="string">'src'</span>)], <span class="comment">// 指定检查的目录</span></span><br><span class="line">    options: &#123; <span class="comment">// 这里的配置项参数将会被传递到 eslint 的 CLIEngine </span></span><br><span class="line">        formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>) <span class="comment">// 指定错误报告的格式规范</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：formatter 默认是 stylish ，如果想用第三方的可以安装该插件，如上方的示例中的 eslint-friendly-formatter 。</p></blockquote><p>其次，要想 webpack 具有 eslint 的能力，就要安装 eslint，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br></pre></td></tr></table></figure><p>最后，项目想要使用那些 eslin 规则，可以创建一个配置项文件 ‘.eslintrc.js’，代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>, </span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [<span class="string">"error"</span>, <span class="number">2</span>],</span><br><span class="line">        <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>],</span><br><span class="line">        <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"arrow-parens"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的 webpack 引入 eslint 已经完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>webpack 确实是一个功能强大的模块打包工具，丰富的 loader 和 plugin 使得其功能多而强。学习 webpack 使得我们可以自定义自己的开发环境，无需依赖 create-react-app 和 Vue-Cli 这类脚手架，也可以针对不同的需求对代码进行不同方案的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。&lt;/p&gt;
    
    </summary>
    
      <category term="matengfei" scheme="http://xgfe.github.io/categories/matengfei/"/>
    
    
      <category term="webpack" scheme="http://xgfe.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端安全科普之 XSS</title>
    <link href="http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/"/>
    <id>http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/</id>
    <published>2018-06-13T03:00:00.000Z</published>
    <updated>2019-06-14T07:08:56.537Z</updated>
    
    <content type="html"><![CDATA[<p>Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。</p><p>XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。</p><p>在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。</p><a id="more"></a><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>跨站脚本的重点在脚本上，绝大多数的 XSS 会采用一段远程或者第三方域上的脚本资源，这样做的好处是攻击代码容易控制。script 标签可以嵌入第三方资源，这是浏览器允许的，对于嵌入的脚本内容，会与本域的脚本内容一样，在整个脚本上下文环境中存在，那么在这个场景中的各种功能都可以由嵌入的脚本实现，也就是说 JavaScript 能做到什么效果，XSS 的威力就有多大。</p><p>JavaScript 可以用用来获取的 Cookie、改变网页内容、URL 跳转，那么存在 XSS 漏洞的网站，就可以盗取用户 Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向 Web 页面中注入 JavaScript 代码。</p><p>XSS 攻击原理主要包括三个部分：</p><ul><li><p>攻击者对某含有漏洞的服务器发起 XSS 攻击（注入 JS 代码）。</p></li><li><p>诱使受害者打开受到攻击的服务器 URL（邮件、留言等，此步骤可选项）。</p></li><li><p>受害者在 Web 浏览器中打开 URL，恶意脚本执行。</p></li></ul><p>XSS 构造的例子：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入内容直接拼接到返回 HTML 里</span><br><span class="line">res.body = &apos;...&lt;div&gt;&apos; + data.用户输入的内容 + &apos;&lt;/div&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入的内容直接拼接到了页面元素的属性中</span><br><span class="line">res.body = &apos;...&lt;img src=&quot; + data.用户输入的图片地址 + &quot;&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&quot; /&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面中</span><br><span class="line">div.innerHTML = data.用户输入的内容</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，innerHTML 中的 script 标签不会被执行，但是攻击者可以这么写：</span><br><span class="line">&lt;img src=&quot;x.png&quot; onload=&quot;alert(123)&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面元素的属性中</span><br><span class="line">a.href = data.用户输入的链接</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，给元素的属性赋值时内容总会被当成字符串，但是攻击者可以这么写，如用户点了链接就会受到攻击：</span><br><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure></code></pre><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><p>XSS 有三种类型，分别是反射型 XSS、存储型 XSS、DOM XSS，下面分别对这三种 XSS 进行介绍。</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 也被称为非持久性 XSS，是最容易出现的一种 XSS 漏洞，指的是发送请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后被浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。它的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">&lt;?php</span><br><span class="line">    echo $_GET[&apos;x&apos;];</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">// 在浏览器地址栏中输入</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/a7271f75b155dbab2e0c3fb758cbe111100565.png" alt="反射型XSS"></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 又被称为永久性 XSS，是最危险的一种跨站脚本，指的是发送请求时，提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统），下次请求目标页面时不用再提交 XSS 代码，存储型 XSS 的攻击是最隐蔽的，其危害性也更大。与反射型 XSS 和 DOM XSS 相比，存储型 XSS 的执行不需要手动触发。最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。它的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>DOM XSS 指的是 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。它的数据流向是：URL-&gt;浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 客户端的脚本</span><br><span class="line">&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 用户点击这个 URL# 后的内容不会发送到服务端，仅在客户端被接收并解释执行。</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/919bcf853c27bbd16656cfa83b8b6ef887889.png" alt="DOM XSS"></p><h4 id="DOM-XSS-场景一：在前端实现页面跳转"><a href="#DOM-XSS-场景一：在前端实现页面跳转" class="headerlink" title="DOM XSS 场景一：在前端实现页面跳转"></a>DOM XSS 场景一：在前端实现页面跳转</h4><p>在前端实现页面跳转，前端通常会通过 JavaScript 实现跳转，最常用到的方法有: location.href / location.replace() / location.assign()。 在该场景下，可以通过伪协议“javascript:”、“data:”在浏览器下执行脚本。但是这种通过伪协议进行攻击已经随着前端工程处理对相关跳转代码逻辑做了很好的完善，基本上不会再出现上述的这种情况。但是如下两种情况却为 Web 攻击打开了天窗：</p><ul><li><p>使用 indexOf 判断 URL 参数是否合法，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。所以如果 URL 中包含了伪代码及攻击代码，就会被攻击。</p></li><li><p>正则表达式判断 URL 是否合法，为了避免使用 indexOf 判断 URL 带来的缺陷，有些开发人员会想到用正则表达式，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别，如果没有加“^”，攻击者仍然可以绕过正则的过滤，在URL中植入伪代码和攻击代码。</p></li><li><p>修复方案：在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是 http、https 或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 </p></li></ul><h4 id="DOM-XSS-场景二：取值写入页面或动态执行"><a href="#DOM-XSS-场景二：取值写入页面或动态执行" class="headerlink" title="DOM XSS 场景二：取值写入页面或动态执行"></a>DOM XSS 场景二：取值写入页面或动态执行</h4><p>除接收 URL 参数经后端处理最后在前端展示外，在 Web 前端通过 JavaScript 获取不同来源的参数值，不经后端处理即刻在 Web 页面进行展示或动态执行的业务场景也十分常见，想要在客户端实现接受参数并写入页面或动态执行，就不得不用到 innerHTML、document.write、eval。因为 JavaScript 取值的来源纷繁复杂，如果忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给 JavaScriptinnerHTML、document.write、eval处理，就有可能招来 DOM-XSS。下面是三种常见的缺陷： </p><ul><li><p>从 URL 中的取参数值写入页面或动态执行，如直接从 URL 的锚参数（即位于#后面的参数）中取值，不经过任何处理直接 innerHTML 写入页面，导致攻击者只需要构造如下URL即可完成一次 DOM XSS 攻击。由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型 XSS 的 Web 应用防火墙（WAF），这类 DOM XSS 也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 </p></li><li><p>从 Cookie 中的取参数值写入页面或动态执行，原理基本同从 URL 中的取参数值写入页面或动态执行，只是换了一个取值来源而已。</p></li><li><p>从 LocalStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 ，如取 window.name 的值，最后直接 innerHTML 到页面中。一般情况下，页面的 window.name 攻击者不可控，故往往会被认为来源相对可信。但借助i frame 的 name 属性，攻击者可以将页面的 window.name 设置为攻击代码，仍然可以构造 DOM XSS。</p></li><li><p>修复方案：</p><ul><li><p>写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的 HTML 特殊字符进行转义处理能防止大部分 DOM-XSS 的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 </p></li><li><p>慎用危险的“eval”。需要强调的是，由于 JavaScript 中的 eval 函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用 eval<br>函数处理不可控的外部数据。 </p></li><li><p>编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从 Cookie，还是从LocalStorage、Referer、Window name、SessionStorage 中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 </p></li></ul></li></ul><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li><p>盗取用户的 Cookie，Cookie 经常被用来存储用户的会话信息，比如用户登录认证后的 session，之后同域内发出的请求都会自动带上认证后的会话信息。如果 Cookie被盗取，攻击者就可以不用通过密码而直接登录用户的账户。Cookie 的重要字段：[name] [value] [domain] [path] [expires] [httponly] [secure]，其含义依次是：名称、值、所属域名、所属相对根路径、过期时间、是否有 HttpOnly 标志、是否有 Secure 标志。如果设置了 HttpOnly 标志，客户端脚本就无法通过document.cookie 获取该 Cookie，这样就能有效地防御 XSS 攻击获取 Cookie。</p></li><li><p>构建 GET 和 POST 请求，如果 Cookie 设置了 HttpOnly 标志，则无法直接劫持 Cookie 来使用了，但是 XSS 可以在 JavaScript 中构建 GET 或者 POST 请求，来实现自己的攻击。只要让用户执行下面这段脚本，就能发起 GET 请求，攻击者通过 XSS 诱导用户来执行。XSS 的攻击过程都是在浏览器通过执行 JavaScript 脚本自动进行，缺少与用户交互的过程。例如在 POST 的请求中，如果需要输入验证码，JS 代码无法解析验证码，攻击也就无法实现。但是针对验证码这种情况，如果 XSS 可以通过把验证码的图片发到远端攻击服务器，服务器解析验证码然后把结果返回给 JS 代码，JS 获取后继续进行攻击，不过就是成本有点高。</p></li><li><p>XSS 钓鱼：上面模拟用户的 POST 请求貌似成本有点高，攻击者可以将 XSS 和钓鱼结合在一起，例如通过 JavaScript 代码模拟出网站的登录框，用户输入用户名和密码后，XSS 将这些信息发送到服务器端，用来进行攻击。</p></li><li><p>获取用户系统信息，此外 XSS 还可以识别用户的浏览器信息、用户安装的软件以及用户真实的 IP 等信息。</p></li><li><p>XSS Worm：这是 XSS 的一种终极利用方式，破坏力和影响力是巨大的，与蠕虫病毒一样具有“传染性”，与系统病毒的唯一区别就是无法对系统底层操作。XSS 蠕虫是针对浏览器的攻击，网站规模越大，攻击效果就越大。一般来说，用户直接发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 Worm 攻击。</p></li></ul><h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><ul><li><p>任何由用户输出的数据都是不可信的。</p></li><li><p>不要在奇怪的地方插入不可信的数据。</p><p><img src="http://vfile.meituan.net/xgfe/0a853e1b33a7dfaeb4aa47f12453026b97763.png" alt="不可信数据"></p></li><li><p>进行输入输出检查，将期望被当成字符串的不可信数据转义后再插入文档中，不同位置需要使用不同的转义逻辑。</p><p><img src="http://vfile.meituan.net/xgfe/3df441ed85fa308c54a059924acd16e0248873.png" alt="输入输出检查"></p></li><li><p>将期望被当成 HTML 的不可信数据使用专业的库消毒后再插入文档中。</p></li><li><p>使用 HttpOnly 的 Cookie，给关键的 Cookie 设置 HttpOnly 属性，这样能够避免 JS 读取 Cookie信息，设置后有助于缓解 XSS，但是 XSS 除了劫持 Cookie 之外，还可以模拟用户的身份进行操作。</p></li><li><p>使用内容安全策略（CSP）是对抗 XSS 的深度防御策略，内容安全策略可以以白名单的方式限定哪些地方的内容可以被加载和执行，如果不存在可以通过本地文件放置恶意代码的其他漏洞，则该策略是有效的。</p></li><li><p>使用设计上就会自动编码来解决XSS问题的框架，如：React JS。了解每个框架的 XSS 保护的局限性，并适当地处理未覆盖的用例。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">XSS攻击手册</a></p></li><li><p><a href="https://www.owasp.org/index.php/XSS_Prevention_Cheat_Sheet" target="_blank" rel="noopener">XSS防御手册</a></p></li><li><p>《Web前端黑客技术揭秘》</p></li><li><p>《Web安全深度剖析》</p></li><li><p>《白帽子讲Web安全》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。&lt;/p&gt;
&lt;p&gt;XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。&lt;/p&gt;
&lt;p&gt;CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。&lt;/p&gt;
&lt;p&gt;界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。&lt;/p&gt;
&lt;p&gt;在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpeiyu" scheme="http://xgfe.github.io/categories/wangpeiyu/"/>
    
    
      <category term="XSS" scheme="http://xgfe.github.io/tags/XSS/"/>
    
      <category term="Web 安全" scheme="http://xgfe.github.io/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
      <category term="前端安全" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前后端通信的几种方式</title>
    <link href="http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/"/>
    <id>http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2019-06-14T07:08:56.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。</p><a id="more"></a><h2 id="一、前后端通信（同源）简介"><a href="#一、前后端通信（同源）简介" class="headerlink" title="一、前后端通信（同源）简介"></a>一、前后端通信（同源）简介</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>同源策略显示从一个源加载的文档或脚本如何来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。源包含三部分内容（协议，端口和域名，默认端口是 80 ）。<br>同源的限制：<br>（1）Cookie , LocalStorage 和 IndexDB 无法获取<br>（2）DOM无法获得和操作<br>（3）Ajax请求不能发送，只是用与同源通信</p><h3 id="2-前后端通信的几种方式"><a href="#2-前后端通信的几种方式" class="headerlink" title="2.前后端通信的几种方式"></a>2.前后端通信的几种方式</h3><ul><li>Ajax（同源下面的通信方式）</li><li>WebSocket（不受同源策略限制）</li><li>CORS（支持跨域也支持同源）</li></ul><h3 id="3-如何创建一个Ajax"><a href="#3-如何创建一个Ajax" class="headerlink" title="3.如何创建一个Ajax"></a>3.如何创建一个Ajax</h3><p>发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）<br>（1）创建 XMLHttpRequest 对象。<br>（2）使用 open 方法设置请求的参数。open ( method , url, 是否异步)。<br>（3）发送请求。<br>（4）注册事件。 注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>（5）获取返回的数据，更新UI。<br>post 请求举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 建立XMLHttpRequest对象       </span><br><span class="line">var xhr = new XMLHttpRequest();        </span><br><span class="line">xhr.open(&apos;post&apos;, &apos;02.post.php&apos;);           </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">// 将数据通过send方法传递       </span><br><span class="line">xhr.send(&apos;name=fox&amp;age=18&apos;);            </span><br><span class="line">xhr.onreadystatechange = function () &#123;                 </span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; </span><br><span class="line">        //判断返回状态  </span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-实际开发中用的原生Ajax请求"><a href="#4-实际开发中用的原生Ajax请求" class="headerlink" title="4.实际开发中用的原生Ajax请求"></a>4.实际开发中用的原生Ajax请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">var util = &#123;&#125;;      </span><br><span class="line">//获取 Ajax 请求之后的 json     </span><br><span class="line">util.json = function (options) &#123;</span><br><span class="line">    var opt = &#123;</span><br><span class="line">        url: &apos;&apos;,</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    Object.assign(opt, options);</span><br><span class="line">    //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api             </span><br><span class="line">    var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    var data = opt.data,</span><br><span class="line">    var type = opt.type.toUpperCase();</span><br><span class="line">    var dataArr = [];</span><br><span class="line">    if (opt.url) &#123;   </span><br><span class="line">        var url = opt.url;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var key in data) &#123;</span><br><span class="line">        dataArr.push(key + &apos;=&apos; + data[key]);</span><br><span class="line">    &#125; </span><br><span class="line">    if (type === &apos;GET&apos;) &#123;</span><br><span class="line">        url = url + &apos;?&apos; + dataArr.join(&apos;&amp;&apos;);</span><br><span class="line">        xhr.open(type, url.replace(/\?$/g, &apos;&apos;), true);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    if (type === &apos;POST&apos;) &#123;</span><br><span class="line">        xhr.open(type, url, true);</span><br><span class="line">        // 如果想要使用post提交数据,需要明确设置Request Header    </span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.send(dataArr.join(&apos;&amp;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">            //304表示：用缓存即可。206表示获取媒体资源的前面一部分                </span><br><span class="line">            var res;</span><br><span class="line">            if (opt.success &amp;&amp; opt.success instanceof Function) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                if (typeof res === &apos;string&apos;) &#123;</span><br><span class="line">                    //将字符串转成json</span><br><span class="line">                    res = JSON.parse(res);                           </span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (opt.error &amp;&amp; opt.error instanceof Function) &#123;</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-WebSocket-介绍"><a href="#5-WebSocket-介绍" class="headerlink" title="5.WebSocket 介绍"></a>5.WebSocket 介绍</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。所以出现了 WebSocket 。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><p>通常WebSocket协议的链接如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure></p><p>WebSocket 的实现需要后端搭建一个 WebSocket 服务器，但是如果想搭建一个 WebSocket 服务器就没有那么轻松了，因为 WebSocket 是一种新的通信协议，目前还是草案，没有成为标准，比如 PyWebSocket , WebSocket-Node , LibWebSockets 等等，这些库文件已经实现了WebSocket 数据包的封装和解析，我们可以调用这些接口，这在很大程度上减少了我们的工作量。<br>具体的实现方式：（在客户端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 再js文件中 创建WebSocket对象</span><br><span class="line">var ws = new WebSocket(‘wss://echo.WebSocket.org’);</span><br><span class="line">ws.onopen = function (evt) &#123;</span><br><span class="line">    console.log(‘connnection……’);</span><br><span class="line">    ws.send(&apos;hello WebSocket&apos;);</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = function (evt) &#123;</span><br><span class="line">    console.log(&apos;received message&apos; + evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;</span><br><span class="line">ws.onclose = dunction(evt)&#123;</span><br><span class="line">    console.log(&apos;connection closed.&apos;);</span><br><span class="line">&#125;   </span><br><span class="line">// ws的使用，以为按钮添加发送信息事件为例</span><br><span class="line">$(&quot;#send&quot;).click(function()&#123;</span><br><span class="line">    ws.send($(&quot;#msg&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="6-CORS-介绍"><a href="#6-CORS-介绍" class="headerlink" title="6.CORS 介绍"></a>6.CORS 介绍</h3><p>CORS是一个 W3C 标准，跨域资源共享（CORS ）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。简言之， CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。<br>下图为各浏览器对于 CORS 的支持情况，看起来相当乐观。主流浏览器都已基本提供对跨域资源共享的支持，所以，CORS 才会在国外使用的如此普遍。<br><img src="http://vfile.meituan.net/xgfe/d87439988ef5ab43251311a668d027d6233940.png" alt=""><br>使用 CORS 需要做服务端和前端的配置：</p><h4 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h4><p>以下是 CORS 协议规定的 HTTP 头，用来进行浏览器发起跨域资源请求时进行协商：</p><ol><li>Origin。HTTP 请求头，任何涉及 CORS 的请求都必需携带。</li><li>Access-Control-Request-Method。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的方法。</li><li>Access-Control-Request-Headers。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的自定义 Header 列表。</li><li>Access-Control-Allow-Origin。HTTP 响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符 * 表示允许任何域的JavaScript 访问资源，但是在响应一个携带身份信息( Credential )的 HTTP 请求时，Access-Control-Allow-Origin 必需指定具体的域，不能用通配符。</li><li>Access-Control-Allow-Methods。HTTP 响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li><li>Access-Control-Allow-Headers。HTTP 响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li><li>Access-Control-Max-Age。HTTP 响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li><li>Access-Control-Allow-Credentials。HTTP 响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回。</li></ol><p>实际应用中，服务端例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//允许跨域访问  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,PUT&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Test&quot;);</span><br></pre></td></tr></table></figure><h4 id="前端的配置"><a href="#前端的配置" class="headerlink" title="前端的配置"></a>前端的配置</h4><p>前端的配置主要从简单请求、非简单请求和携带身份凭证这三点进行讲解。<br>浏览器将CORS请求分成两类：简单请求（ simple request ）和非简单请求（ not-so-simple request ）。<br>1.简单请求：<br>使用下列方法：GET、 HEAD、 POST<br>HTTP的头信息主要是以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值属于下列之一: <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><p>简单请求如图所示：<br><img src="http://vfile.meituan.net/xgfe/63958e7743ea262c379f4466c52844a636486.png" alt=""><br>2.非简单请求：<br>不满足简单请求条件的请求则要先进行预检请求，即使用 OPTIONS 方法发起一个预检请求到服务器，已获知服务器是否允许该实际请求。<br>非简单请求如下所示：<br><img src="http://vfile.meituan.net/xgfe/cf3757d6cc10ac2d4c9c023af564900f126443.png" alt=""><br>浏览器与服务器之间请求只进行了一次。<br>下面是 PUT 请求第一次返回的结果：<br><img src="http://vfile.meituan.net/xgfe/33d389422e08f9f730faa7757ef26bba81218.png" alt=""><br><img src="http://vfile.meituan.net/xgfe/000d4cf1b6d92837affcddef925df2a176640.png" alt=""><br>通过PUT请求结果可以看出，当检测到 PUT 请求为非简单请求时，浏览器便会发送一个预检请求，目的是询问，自定义头部 X-Custom-Header 的 PUT 请求是否被允许，浏览器返回了所有可以请求的方法和自定义的头部（把所有可以的返回是为了避免多次预检请求），这时候预检请求成功了，便会发送真正的PUT请求。</p><p>关于预检请求，需要注意一下两点：</p><ul><li>预检请求对 js 来说是透明的，js 获取不到预检请求的任何信息。</li><li>预检请求并不是每次请求都发生，服务端设置的 Access-Control-Max-Age 头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发生预检请求。</li></ul><p>3.携带身份凭证<br>大部分的请求是需要用户携带着用户信息的，比如在一个登录的系统中，用户会携带着相应的 cookie 或 token ，但 CORS 跨域默认是不带身份凭证的。<br>如果需要附带身份凭证，在发送请求时，通过将 withCredentials 属性设置为 true ，可以指定某个请求可以发送凭据。<br>下面提供针对 XMLHttpRequest 附带身份凭证的兼容性写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function createCORSRequest(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr == 304) &#123;</span><br><span class="line">                console.log(xhr.response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(&apos;withCredentials&apos; in xhr) &#123;</span><br><span class="line">        xhr.open(method,url, true);</span><br><span class="line">    &#125; else if(typeof XDomainRequest != &apos;undefined&apos;) &#123;</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附带身份凭证对服务端有两个要求：</p><ol><li>服务端的 Access-Control-Allow-Origin 头部不能设置为 *</li><li>服务端的 Access-Control-Allow-Credentials 头部设置为 true</li></ol><h2 id="二、-前后端跨域通信"><a href="#二、-前后端跨域通信" class="headerlink" title="二、 前后端跨域通信"></a>二、 前后端跨域通信</h2><ul><li>JSONP</li><li>Hash</li><li>WebSocket</li><li>CORS</li></ul><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 的工作原理：<br>本质是利用了 script 标签具有可跨域的特性，由服务端返回预先定义好的 javascript 全局函数的调用，并且将服务端数据以该函数参数的形式传递过来。比如说，客户端这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>实际开发中，前端的 JSONP 是这样实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> var util = &#123;&#125;; </span><br><span class="line"> //定义方法：动态创建script标签</span><br><span class="line"> util.createScript = function (url, charset) &#123;</span><br><span class="line">     var script = document.createElement(&apos;script&apos;);</span><br><span class="line">     script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">     charset &amp;&amp; script.setAttribute(&apos;charset&apos;, charset);</span><br><span class="line">     script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">     script.async = true;</span><br><span class="line">     return script;</span><br><span class="line">&#125;;</span><br><span class="line"> util.jsonp = function (url, onsuccess, onerror, charset) &#123;  </span><br><span class="line">     //事先约定好的函数名</span><br><span class="line">     var callbackName = util.getName(&apos;tt_player&apos;);  </span><br><span class="line">     //根据回调名称注册一个全局的函数 </span><br><span class="line">     window[callbackName] = function () &#123;               </span><br><span class="line">         if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">             onsuccess(arguments[0]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //动态创建一个script标签</span><br><span class="line">     var script = util.createScript(url + &apos;&amp;callback=&apos; + callbackName, charset);   </span><br><span class="line">     //监听加载成功的事件，获取数据</span><br><span class="line">     script.onreadystatechange = function () &#123;      </span><br><span class="line">         if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123;              </span><br><span class="line">             if (script.parentNode) &#123;</span><br><span class="line">                 // 删除函数或变量</span><br><span class="line">                 script.parentNode.removeChild(script);  </span><br><span class="line">             &#125;      </span><br><span class="line">             //最后不要忘了删除           </span><br><span class="line">             window[callbackName] = null;  </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     script.onerror = function () &#123;                              </span><br><span class="line">         if (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">             onerror();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //往html中增加这个标签，目的是把请求发送出去</span><br><span class="line">     document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><p>url 的#后面的内容就叫 Hash 。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。<br>补充：url 的?后面的内容叫 Search 。 Search 的改变，会导致页面刷新，因此不能做跨域通信。<br>使用举例：<br>场景：我的页面 A 通过 iframe 或 frame 嵌入了跨域的页面 B。<br>现在，我这个 A 页面想给B页面发消息，怎么操作呢？<br>（1）首先，在我的A页面中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码  </span><br><span class="line">var B = document.getElementsByTagName(&apos;iframe&apos;);  </span><br><span class="line">//我们可以把JS对象，通过JSON.stringify()方法转成json字符串，发给B   </span><br><span class="line">B.src = B.src + &apos;#&apos; + &apos;jsonString&apos;;</span><br></pre></td></tr></table></figure><p>（2）然后，在 B 页面中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// B 中的伪代码     </span><br><span class="line">window.onhashchange = function () &#123; </span><br><span class="line">     //通过onhashchange方法监听，url中的hash是否发生变化         </span><br><span class="line">     var data = window.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>总结：<br>本文主要对前后端通信的几种方式做了简单介绍，希望对大家对前后端通信方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://blog.csdn.net/a54654132/article/details/77604597" target="_blank" rel="noopener">https://blog.csdn.net/a54654132/article/details/77604597</a><br><a href="https://www.cnblogs.com/yanglang/p/6720887.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/6720887.html</a><br><a href="https://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/8523576.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/6337580.html</a><br><a href="https://blog.csdn.net/qq_27905183/article/details/71023542" target="_blank" rel="noopener">https://blog.csdn.net/qq_27905183/article/details/71023542</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ANJING" scheme="http://xgfe.github.io/categories/ANJING/"/>
    
    
      <category term="前后端通信" scheme="http://xgfe.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的十种方法</title>
    <link href="http://xgfe.github.io/2018/06/07/yuxue/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://xgfe.github.io/2018/06/07/yuxue/数组去重的十种方法/</id>
    <published>2018-06-07T03:12:00.000Z</published>
    <updated>2019-06-14T07:08:56.540Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。</p><a id="more"></a><h2 id="一、-双重遍历"><a href="#一、-双重遍历" class="headerlink" title="一、 双重遍历"></a>一、 双重遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.splice(j,<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.unique();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr1.unique1();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>双重遍历的方式是最容易想到且最容易实现的方式，兼容性比较好，但是时间复杂度比较高；还有一点是不能对 NaN 进行去重。</p><h2 id="二、-indexOf"><a href="#二、-indexOf" class="headerlink" title="二、 indexOf"></a>二、 indexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(newArr.indexOf(<span class="keyword">this</span>[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2.unique2();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="三、-数组下标判断"><a href="#三、-数组下标判断" class="headerlink" title="三、 数组下标判断"></a>三、 数组下标判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) === i) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line">arr3.unique3();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>因为 indexOf 使用的内部严格相等比较算法，所以在检索NaN时会返回-1 ，进而会导致方法3直接过滤掉了 NaN。</p><h2 id="四、排序再去重"><a href="#四、排序再去重" class="headerlink" title="四、排序再去重"></a>四、排序再去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];<span class="keyword">this</span>.sort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] !== newArr[newArr.length<span class="number">-1</span>]) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr4.unique4();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>优点是利用 js 内置的排序方法，速度快，比较的是排序后的相邻元素。最大的不同是更改了原数组的排序。</p><h2 id="五、利用对象的属性"><a href="#五、利用对象的属性" class="headerlink" title="五、利用对象的属性"></a>五、利用对象的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!obj[<span class="keyword">this</span>[i]])&#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">obj[<span class="keyword">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr5.unique5();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">let</span> arr6 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique6 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> tmpKey;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">tmpKey = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i]);</span><br><span class="line"><span class="keyword">if</span>(!obj[tmpKey]) &#123;</span><br><span class="line">obj[tmpKey] = <span class="number">1</span>;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr6.unique6();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>由于对象的键名只能是 String，所以版本1的局限性在于</p><ol><li><p>无法区分隐式类型转换成字符串后一样的值，比如 1 和 “1”</p></li><li><p>无法处理复杂类型，比如对象（因为对象作为key会变成[ object Object ]）</p></li><li><p>特殊数据，比如 <code>__proto__</code> 会挂掉，因为obj对象的 <code>__proto__</code> 属性无法被重写</p></li></ol><p>版本2的优化则解决了这三个问题。缺点就是实现的方式比较麻烦。</p><h2 id="六、-reduce"><a href="#六、-reduce" class="headerlink" title="六、 reduce"></a>六、 reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique7 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">initialValue, current</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(initialValue.length === <span class="number">0</span> || initialValue[initialValue.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">initialValue.push(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> initialValue;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr7.unique7();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>原理实际同方法四，都是进行排序后比较相邻的两个值。</p><h2 id="七、-filter"><a href="#七、-filter" class="headerlink" title="七、 filter"></a>七、 filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr8 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique8 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.indexOf(ele) === index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr8.unique8();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><h2 id="八、-es6-includes"><a href="#八、-es6-includes" class="headerlink" title="八、 es6 includes"></a>八、 es6 includes</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr9 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>,  <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique9 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!newArr.includes(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr9.unique9();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>与 indexOf 类似，但不同的是 indexOf 使用的严格比较，includes 使用的是叫做 SameValueZero 的比较，规范中给出 If x is NaN and y is NaN, return true. 也就是 includes 可以对NaN去重。</p><h2 id="九、-es6-Map"><a href="#九、-es6-Map" class="headerlink" title="九、 es6 Map"></a>九、 es6 Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr10 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique10 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tmp.get(<span class="keyword">this</span>[i]))&#123;</span><br><span class="line">tmp.set(<span class="keyword">this</span>[i], <span class="number">1</span>);</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr10.unique10();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="十、-es6-Set"><a href="#十、-es6-Set" class="headerlink" title="十、 es6 Set"></a>十、 es6 Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr11 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr11)]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>利用 set 对象存储任何类型的唯一值的特性来达到去重的目的。</p><p>再来来看看这几种方式直观的性能对比。<br>通过以下的模拟数据的形式来执行我们上面介绍的每一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复100次生成1~10000的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArr</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> create = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line">            create.push(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算去重函数的时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    fn();</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">var</span> result = date2 - date1;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lgArr = createArr();</span><br><span class="line"><span class="keyword">const</span> res = checkTime(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> lgArr.unique()&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&#123;method：loop，time:"</span> + res + <span class="string">"&#125;"</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://vfile.meituan.net/xgfe/84a60f898fc7283c3ce2dc70d770b137116872.png" alt=""></p><p>在考虑兼容性,并且可以接受以上所说的 Object.key 的限制时，用对象属性方式是最快的。如果考虑这些限制，就要用到对象属性的优化方案，增加对 key 的类型的判断，但这样做显然会麻烦很多，如果处理不好还可能导致结果出错。那么在数据量比较小的情况下，选用 indexof 不失为一种更加稳妥的办法。</p><p>在现代浏览器中当然首选的是 es6 的 set 和 map ,方便易用。在不关注排序的情况下，reduce 和 sort 也是比较可取的方式。<br>以上仅仅是从时间维度上的个人分析。实际工作中还要根据情况进行综合考虑来选择最合适的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。&lt;/p&gt;
    
    </summary>
    
      <category term="yuxue" scheme="http://xgfe.github.io/categories/yuxue/"/>
    
    
      <category term="数组" scheme="http://xgfe.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="去重" scheme="http://xgfe.github.io/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
</feed>
